#![no_std]
#![allow(nonstandard_style)]
extern crate c_types;
/* automatically generated by rust-bindgen 0.64.0 */

pub const SL_STATUS_SPACE_MASK: u32 = 65280;
pub const SL_STATUS_GENERIC_SPACE: u32 = 0;
pub const SL_STATUS_PLATFORM_1_SPACE: u32 = 256;
pub const SL_STATUS_PLATFORM_2_SPACE: u32 = 512;
pub const SL_STATUS_HARDWARE_SPACE: u32 = 768;
pub const SL_STATUS_BLUETOOTH_SPACE: u32 = 1024;
pub const SL_STATUS_BLUETOOTH_MESH_SPACE: u32 = 1280;
pub const SL_STATUS_CAN_CANOPEN_SPACE: u32 = 1536;
pub const SL_STATUS_CONNECT_SPACE: u32 = 1792;
pub const SL_STATUS_NET_SUITE_SPACE: u32 = 2048;
pub const UINT32_THREAD_SPACE: u32 = 2304;
pub const SL_STATUS_USB_SPACE: u32 = 2560;
pub const SL_STATUS_WIFI_SPACE: u32 = 2816;
pub const SL_STATUS_ZIGBEE_SPACE: u32 = 3072;
pub const SL_STATUS_Z_WAVE_SPACE: u32 = 3328;
pub const SL_STATUS_GECKO_OS_1_SPACE: u32 = 3584;
pub const SL_STATUS_GECKO_OS_2_SPACE: u32 = 3840;
pub const SL_STATUS_BLUETOOTH_CTRL_SPACE: u32 = 4096;
pub const SL_STATUS_BLUETOOTH_ATT_SPACE: u32 = 4352;
pub const SL_STATUS_BLUETOOTH_SMP_SPACE: u32 = 4608;
pub const SL_STATUS_BLUETOOTH_MESH_FOUNDATION_SPACE: u32 = 4864;
pub const SL_STATUS_OK: u32 = 0;
pub const SL_STATUS_FAIL: u32 = 1;
pub const SL_STATUS_INVALID_STATE: u32 = 2;
pub const SL_STATUS_NOT_READY: u32 = 3;
pub const SL_STATUS_BUSY: u32 = 4;
pub const SL_STATUS_IN_PROGRESS: u32 = 5;
pub const SL_STATUS_ABORT: u32 = 6;
pub const UINT32_TIMEOUT: u32 = 7;
pub const SL_STATUS_PERMISSION: u32 = 8;
pub const SL_STATUS_WOULD_BLOCK: u32 = 9;
pub const SL_STATUS_IDLE: u32 = 10;
pub const SL_STATUS_IS_WAITING: u32 = 11;
pub const SL_STATUS_NONE_WAITING: u32 = 12;
pub const SL_STATUS_SUSPENDED: u32 = 13;
pub const SL_STATUS_NOT_AVAILABLE: u32 = 14;
pub const SL_STATUS_NOT_SUPPORTED: u32 = 15;
pub const SL_STATUS_INITIALIZATION: u32 = 16;
pub const SL_STATUS_NOT_INITIALIZED: u32 = 17;
pub const SL_STATUS_ALREADY_INITIALIZED: u32 = 18;
pub const SL_STATUS_DELETED: u32 = 19;
pub const SL_STATUS_ISR: u32 = 20;
pub const SL_STATUS_NETWORK_UP: u32 = 21;
pub const SL_STATUS_NETWORK_DOWN: u32 = 22;
pub const SL_STATUS_NOT_JOINED: u32 = 23;
pub const SL_STATUS_NO_BEACONS: u32 = 24;
pub const SL_STATUS_ALLOCATION_FAILED: u32 = 25;
pub const SL_STATUS_NO_MORE_RESOURCE: u32 = 26;
pub const SL_STATUS_EMPTY: u32 = 27;
pub const SL_STATUS_FULL: u32 = 28;
pub const SL_STATUS_WOULD_OVERFLOW: u32 = 29;
pub const SL_STATUS_HAS_OVERFLOWED: u32 = 30;
pub const SL_STATUS_OWNERSHIP: u32 = 31;
pub const SL_STATUS_IS_OWNER: u32 = 32;
pub const SL_STATUS_INVALID_PARAMETER: u32 = 33;
pub const SL_STATUS_NULL_POINTER: u32 = 34;
pub const SL_STATUS_INVALID_CONFIGURATION: u32 = 35;
pub const SL_STATUS_INVALID_MODE: u32 = 36;
pub const SL_STATUS_INVALID_HANDLE: u32 = 37;
pub const SL_STATUS_INVALID_TYPE: u32 = 38;
pub const SL_STATUS_INVALID_INDEX: u32 = 39;
pub const SL_STATUS_INVALID_RANGE: u32 = 40;
pub const SL_STATUS_INVALID_KEY: u32 = 41;
pub const SL_STATUS_INVALID_CREDENTIALS: u32 = 42;
pub const SL_STATUS_INVALID_COUNT: u32 = 43;
pub const SL_STATUS_NOT_FOUND: u32 = 44;
pub const SL_STATUS_ALREADY_EXISTS: u32 = 45;
pub const SL_STATUS_IO: u32 = 46;
pub const SL_STATUS_IO_TIMEOUT: u32 = 47;
pub const UINT32_TRANSMIT: u32 = 48;
pub const UINT32_TRANSMIT_UNDERFLOW: u32 = 49;
pub const UINT32_TRANSMIT_INCOMPLETE: u32 = 50;
pub const UINT32_TRANSMIT_BUSY: u32 = 51;
pub const SL_STATUS_RECEIVE: u32 = 52;
pub const SL_STATUS_OBJECT_READ: u32 = 53;
pub const SL_STATUS_OBJECT_WRITE: u32 = 54;
pub const SL_STATUS_MESSAGE_TOO_LONG: u32 = 55;
pub const SL_STATUS_EEPROM_MFG_VERSION_MISMATCH: u32 = 56;
pub const SL_STATUS_EEPROM_STACK_VERSION_MISMATCH: u32 = 57;
pub const SL_STATUS_FLASH_WRITE_INHIBITED: u32 = 58;
pub const SL_STATUS_FLASH_VERIFY_FAILED: u32 = 59;
pub const SL_STATUS_FLASH_PROGRAM_FAILED: u32 = 60;
pub const SL_STATUS_FLASH_ERASE_FAILED: u32 = 61;
pub const SL_STATUS_MAC_NO_DATA: u32 = 62;
pub const SL_STATUS_MAC_NO_ACK_RECEIVED: u32 = 63;
pub const SL_STATUS_MAC_INDIRECT_TIMEOUT: u32 = 64;
pub const SL_STATUS_MAC_UNKNOWN_HEADER_TYPE: u32 = 65;
pub const SL_STATUS_MAC_ACK_HEADER_TYPE: u32 = 66;
pub const SL_STATUS_MAC_COMMAND_TRANSMIT_FAILURE: u32 = 67;
pub const SL_STATUS_CLI_STORAGE_NVM_OPEN_ERROR: u32 = 68;
pub const SL_STATUS_SECURITY_IMAGE_CHECKSUM_ERROR: u32 = 69;
pub const SL_STATUS_SECURITY_DECRYPT_ERROR: u32 = 70;
pub const SL_STATUS_COMMAND_IS_INVALID: u32 = 71;
pub const SL_STATUS_COMMAND_TOO_LONG: u32 = 72;
pub const SL_STATUS_COMMAND_INCOMPLETE: u32 = 73;
pub const SL_STATUS_BT_OUT_OF_BONDS: u32 = 1026;
pub const SL_STATUS_BT_UNSPECIFIED: u32 = 1027;
pub const SL_STATUS_BT_HARDWARE: u32 = 1028;
pub const SL_STATUS_BT_NO_BONDING: u32 = 1030;
pub const SL_STATUS_BT_CRYPTO: u32 = 1031;
pub const SL_STATUS_BT_DATA_CORRUPTED: u32 = 1032;
pub const SL_STATUS_BT_INVALID_SYNC_HANDLE: u32 = 1034;
pub const SL_STATUS_BT_INVALID_MODULE_ACTION: u32 = 1035;
pub const SL_STATUS_BT_RADIO: u32 = 1036;
pub const SL_STATUS_BT_L2CAP_REMOTE_DISCONNECTED: u32 = 1037;
pub const SL_STATUS_BT_L2CAP_LOCAL_DISCONNECTED: u32 = 1038;
pub const SL_STATUS_BT_L2CAP_CID_NOT_EXIST: u32 = 1039;
pub const SL_STATUS_BT_L2CAP_LE_DISCONNECTED: u32 = 1040;
pub const SL_STATUS_BT_L2CAP_FLOW_CONTROL_VIOLATED: u32 = 1042;
pub const SL_STATUS_BT_L2CAP_FLOW_CONTROL_CREDIT_OVERFLOWED: u32 = 1043;
pub const SL_STATUS_BT_L2CAP_NO_FLOW_CONTROL_CREDIT: u32 = 1044;
pub const SL_STATUS_BT_L2CAP_CONNECTION_REQUEST_TIMEOUT: u32 = 1045;
pub const SL_STATUS_BT_L2CAP_INVALID_CID: u32 = 1046;
pub const SL_STATUS_BT_L2CAP_WRONG_STATE: u32 = 1047;
pub const SL_STATUS_BT_PS_STORE_FULL: u32 = 1051;
pub const SL_STATUS_BT_PS_KEY_NOT_FOUND: u32 = 1052;
pub const SL_STATUS_BT_APPLICATION_MISMATCHED_OR_INSUFFICIENT_SECURITY: u32 = 1053;
pub const SL_STATUS_BT_APPLICATION_ENCRYPTION_DECRYPTION_ERROR: u32 = 1054;
pub const SL_STATUS_BT_CTRL_UNKNOWN_CONNECTION_IDENTIFIER: u32 = 4098;
pub const SL_STATUS_BT_CTRL_AUTHENTICATION_FAILURE: u32 = 4101;
pub const SL_STATUS_BT_CTRL_PIN_OR_KEY_MISSING: u32 = 4102;
pub const SL_STATUS_BT_CTRL_MEMORY_CAPACITY_EXCEEDED: u32 = 4103;
pub const SL_STATUS_BT_CTRL_CONNECTION_TIMEOUT: u32 = 4104;
pub const SL_STATUS_BT_CTRL_CONNECTION_LIMIT_EXCEEDED: u32 = 4105;
pub const SL_STATUS_BT_CTRL_SYNCHRONOUS_CONNECTIONTION_LIMIT_EXCEEDED: u32 = 4106;
pub const SL_STATUS_BT_CTRL_ACL_CONNECTION_ALREADY_EXISTS: u32 = 4107;
pub const SL_STATUS_BT_CTRL_COMMAND_DISALLOWED: u32 = 4108;
pub const SL_STATUS_BT_CTRL_CONNECTION_REJECTED_DUE_TO_LIMITED_RESOURCES: u32 = 4109;
pub const SL_STATUS_BT_CTRL_CONNECTION_REJECTED_DUE_TO_SECURITY_REASONS: u32 = 4110;
pub const SL_STATUS_BT_CTRL_CONNECTION_REJECTED_DUE_TO_UNACCEPTABLE_BD_ADDR: u32 = 4111;
pub const SL_STATUS_BT_CTRL_CONNECTION_ACCEPT_TIMEOUT_EXCEEDED: u32 = 4112;
pub const SL_STATUS_BT_CTRL_UNSUPPORTED_FEATURE_OR_PARAMETER_VALUE: u32 = 4113;
pub const SL_STATUS_BT_CTRL_INVALID_COMMAND_PARAMETERS: u32 = 4114;
pub const SL_STATUS_BT_CTRL_REMOTE_USER_TERMINATED: u32 = 4115;
pub const SL_STATUS_BT_CTRL_REMOTE_DEVICE_TERMINATED_CONNECTION_DUE_TO_LOW_RESOURCES: u32 = 4116;
pub const SL_STATUS_BT_CTRL_REMOTE_POWERING_OFF: u32 = 4117;
pub const SL_STATUS_BT_CTRL_CONNECTION_TERMINATED_BY_LOCAL_HOST: u32 = 4118;
pub const SL_STATUS_BT_CTRL_REPEATED_ATTEMPTS: u32 = 4119;
pub const SL_STATUS_BT_CTRL_PAIRING_NOT_ALLOWED: u32 = 4120;
pub const SL_STATUS_BT_CTRL_UNSUPPORTED_REMOTE_FEATURE: u32 = 4122;
pub const SL_STATUS_BT_CTRL_UNSPECIFIED_ERROR: u32 = 4127;
pub const SL_STATUS_BT_CTRL_LL_RESPONSE_TIMEOUT: u32 = 4130;
pub const SL_STATUS_BT_CTRL_LL_PROCEDURE_COLLISION: u32 = 4131;
pub const SL_STATUS_BT_CTRL_ENCRYPTION_MODE_NOT_ACCEPTABLE: u32 = 4133;
pub const SL_STATUS_BT_CTRL_LINK_KEY_CANNOT_BE_CHANGED: u32 = 4134;
pub const SL_STATUS_BT_CTRL_INSTANT_PASSED: u32 = 4136;
pub const SL_STATUS_BT_CTRL_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED: u32 = 4137;
pub const SL_STATUS_BT_CTRL_DIFFERENT_TRANSACTION_COLLISION: u32 = 4138;
pub const SL_STATUS_BT_CTRL_CHANNEL_ASSESSMENT_NOT_SUPPORTED: u32 = 4142;
pub const SL_STATUS_BT_CTRL_INSUFFICIENT_SECURITY: u32 = 4143;
pub const SL_STATUS_BT_CTRL_PARAMETER_OUT_OF_MANDATORY_RANGE: u32 = 4144;
pub const SL_STATUS_BT_CTRL_SIMPLE_PAIRING_NOT_SUPPORTED_BY_HOST: u32 = 4151;
pub const SL_STATUS_BT_CTRL_HOST_BUSY_PAIRING: u32 = 4152;
pub const SL_STATUS_BT_CTRL_CONNECTION_REJECTED_DUE_TO_NO_SUITABLE_CHANNEL_FOUND: u32 = 4153;
pub const SL_STATUS_BT_CTRL_CONTROLLER_BUSY: u32 = 4154;
pub const SL_STATUS_BT_CTRL_UNACCEPTABLE_CONNECTION_INTERVAL: u32 = 4155;
pub const SL_STATUS_BT_CTRL_ADVERTISING_TIMEOUT: u32 = 4156;
pub const SL_STATUS_BT_CTRL_CONNECTION_TERMINATED_DUE_TO_MIC_FAILURE: u32 = 4157;
pub const SL_STATUS_BT_CTRL_CONNECTION_FAILED_TO_BE_ESTABLISHED: u32 = 4158;
pub const SL_STATUS_BT_CTRL_MAC_CONNECTION_FAILED: u32 = 4159;
pub const SL_STATUS_BT_CTRL_COARSE_CLOCK_ADJUSTMENT_REJECTED_BUT_WILL_TRY_TO_ADJUST_USING_CLOCK_DRAGGING : u32 = 4160 ;
pub const SL_STATUS_BT_CTRL_UNKNOWN_ADVERTISING_IDENTIFIER: u32 = 4162;
pub const SL_STATUS_BT_CTRL_LIMIT_REACHED: u32 = 4163;
pub const SL_STATUS_BT_CTRL_OPERATION_CANCELLED_BY_HOST: u32 = 4164;
pub const SL_STATUS_BT_CTRL_PACKET_TOO_LONG: u32 = 4165;
pub const SL_STATUS_BT_ATT_INVALID_HANDLE: u32 = 4353;
pub const SL_STATUS_BT_ATT_READ_NOT_PERMITTED: u32 = 4354;
pub const SL_STATUS_BT_ATT_WRITE_NOT_PERMITTED: u32 = 4355;
pub const SL_STATUS_BT_ATT_INVALID_PDU: u32 = 4356;
pub const SL_STATUS_BT_ATT_INSUFFICIENT_AUTHENTICATION: u32 = 4357;
pub const SL_STATUS_BT_ATT_REQUEST_NOT_SUPPORTED: u32 = 4358;
pub const SL_STATUS_BT_ATT_INVALID_OFFSET: u32 = 4359;
pub const SL_STATUS_BT_ATT_INSUFFICIENT_AUTHORIZATION: u32 = 4360;
pub const SL_STATUS_BT_ATT_PREPARE_QUEUE_FULL: u32 = 4361;
pub const SL_STATUS_BT_ATT_ATT_NOT_FOUND: u32 = 4362;
pub const SL_STATUS_BT_ATT_ATT_NOT_LONG: u32 = 4363;
pub const SL_STATUS_BT_ATT_INSUFFICIENT_ENC_KEY_SIZE: u32 = 4364;
pub const SL_STATUS_BT_ATT_INVALID_ATT_LENGTH: u32 = 4365;
pub const SL_STATUS_BT_ATT_UNLIKELY_ERROR: u32 = 4366;
pub const SL_STATUS_BT_ATT_INSUFFICIENT_ENCRYPTION: u32 = 4367;
pub const SL_STATUS_BT_ATT_UNSUPPORTED_GROUP_TYPE: u32 = 4368;
pub const SL_STATUS_BT_ATT_INSUFFICIENT_RESOURCES: u32 = 4369;
pub const SL_STATUS_BT_ATT_OUT_OF_SYNC: u32 = 4370;
pub const SL_STATUS_BT_ATT_VALUE_NOT_ALLOWED: u32 = 4371;
pub const SL_STATUS_BT_ATT_APPLICATION: u32 = 4480;
pub const SL_STATUS_BT_SMP_PASSKEY_ENTRY_FAILED: u32 = 4609;
pub const SL_STATUS_BT_SMP_OOB_NOT_AVAILABLE: u32 = 4610;
pub const SL_STATUS_BT_SMP_AUTHENTICATION_REQUIREMENTS: u32 = 4611;
pub const SL_STATUS_BT_SMP_CONFIRM_VALUE_FAILED: u32 = 4612;
pub const SL_STATUS_BT_SMP_PAIRING_NOT_SUPPORTED: u32 = 4613;
pub const SL_STATUS_BT_SMP_ENCRYPTION_KEY_SIZE: u32 = 4614;
pub const SL_STATUS_BT_SMP_COMMAND_NOT_SUPPORTED: u32 = 4615;
pub const SL_STATUS_BT_SMP_UNSPECIFIED_REASON: u32 = 4616;
pub const SL_STATUS_BT_SMP_REPEATED_ATTEMPTS: u32 = 4617;
pub const SL_STATUS_BT_SMP_INVALID_PARAMETERS: u32 = 4618;
pub const SL_STATUS_BT_SMP_DHKEY_CHECK_FAILED: u32 = 4619;
pub const SL_STATUS_BT_SMP_NUMERIC_COMPARISON_FAILED: u32 = 4620;
pub const SL_STATUS_BT_SMP_BREDR_PAIRING_IN_PROGRESS: u32 = 4621;
pub const SL_STATUS_BT_SMP_CROSS_TRANSPORT_KEY_DERIVATION_GENERATION_NOT_ALLOWED: u32 = 4622;
pub const SL_STATUS_BT_MESH_ALREADY_EXISTS: u32 = 1281;
pub const SL_STATUS_BT_MESH_DOES_NOT_EXIST: u32 = 1282;
pub const SL_STATUS_BT_MESH_LIMIT_REACHED: u32 = 1283;
pub const SL_STATUS_BT_MESH_INVALID_ADDRESS: u32 = 1284;
pub const SL_STATUS_BT_MESH_MALFORMED_DATA: u32 = 1285;
pub const SL_STATUS_BT_MESH_ALREADY_INITIALIZED: u32 = 1286;
pub const SL_STATUS_BT_MESH_NOT_INITIALIZED: u32 = 1287;
pub const SL_STATUS_BT_MESH_NO_FRIEND_OFFER: u32 = 1288;
pub const SL_STATUS_BT_MESH_PROV_LINK_CLOSED: u32 = 1289;
pub const SL_STATUS_BT_MESH_PROV_INVALID_PDU: u32 = 1290;
pub const SL_STATUS_BT_MESH_PROV_INVALID_PDU_FORMAT: u32 = 1291;
pub const SL_STATUS_BT_MESH_PROV_UNEXPECTED_PDU: u32 = 1292;
pub const SL_STATUS_BT_MESH_PROV_CONFIRMATION_FAILED: u32 = 1293;
pub const SL_STATUS_BT_MESH_PROV_OUT_OF_RESOURCES: u32 = 1294;
pub const SL_STATUS_BT_MESH_PROV_DECRYPTION_FAILED: u32 = 1295;
pub const SL_STATUS_BT_MESH_PROV_UNEXPECTED_ERROR: u32 = 1296;
pub const SL_STATUS_BT_MESH_PROV_CANNOT_ASSIGN_ADDR: u32 = 1297;
pub const SL_STATUS_BT_MESH_ADDRESS_TEMPORARILY_UNAVAILABLE: u32 = 1298;
pub const SL_STATUS_BT_MESH_ADDRESS_ALREADY_USED: u32 = 1299;
pub const SL_STATUS_BT_MESH_FOUNDATION_INVALID_ADDRESS: u32 = 4865;
pub const SL_STATUS_BT_MESH_FOUNDATION_INVALID_MODEL: u32 = 4866;
pub const SL_STATUS_BT_MESH_FOUNDATION_INVALID_APP_KEY: u32 = 4867;
pub const SL_STATUS_BT_MESH_FOUNDATION_INVALID_NET_KEY: u32 = 4868;
pub const SL_STATUS_BT_MESH_FOUNDATION_INSUFFICIENT_RESOURCES: u32 = 4869;
pub const SL_STATUS_BT_MESH_FOUNDATION_KEY_INDEX_EXISTS: u32 = 4870;
pub const SL_STATUS_BT_MESH_FOUNDATION_INVALID_PUBLISH_PARAMS: u32 = 4871;
pub const SL_STATUS_BT_MESH_FOUNDATION_NOT_SUBSCRIBE_MODEL: u32 = 4872;
pub const SL_STATUS_BT_MESH_FOUNDATION_STORAGE_FAILURE: u32 = 4873;
pub const SL_STATUS_BT_MESH_FOUNDATION_NOT_SUPPORTED: u32 = 4874;
pub const SL_STATUS_BT_MESH_FOUNDATION_CANNOT_UPDATE: u32 = 4875;
pub const SL_STATUS_BT_MESH_FOUNDATION_CANNOT_REMOVE: u32 = 4876;
pub const SL_STATUS_BT_MESH_FOUNDATION_CANNOT_BIND: u32 = 4877;
pub const SL_STATUS_BT_MESH_FOUNDATION_TEMPORARILY_UNABLE: u32 = 4878;
pub const SL_STATUS_BT_MESH_FOUNDATION_CANNOT_SET: u32 = 4879;
pub const SL_STATUS_BT_MESH_FOUNDATION_UNSPECIFIED: u32 = 4880;
pub const SL_STATUS_BT_MESH_FOUNDATION_INVALID_BINDING: u32 = 4881;
pub const SL_STATUS_WIFI_INVALID_KEY: u32 = 2817;
pub const SL_STATUS_WIFI_FIRMWARE_DOWNLOAD_TIMEOUT: u32 = 2818;
pub const SL_STATUS_WIFI_UNSUPPORTED_MESSAGE_ID: u32 = 2819;
pub const SL_STATUS_WIFI_WARNING: u32 = 2820;
pub const SL_STATUS_WIFI_NO_PACKET_TO_RECEIVE: u32 = 2821;
pub const SL_STATUS_WIFI_SLEEP_GRANTED: u32 = 2824;
pub const SL_STATUS_WIFI_SLEEP_NOT_GRANTED: u32 = 2825;
pub const SL_STATUS_WIFI_SECURE_LINK_MAC_KEY_ERROR: u32 = 2832;
pub const SL_STATUS_WIFI_SECURE_LINK_MAC_KEY_ALREADY_BURNED: u32 = 2833;
pub const SL_STATUS_WIFI_SECURE_LINK_RAM_MODE_NOT_ALLOWED: u32 = 2834;
pub const SL_STATUS_WIFI_SECURE_LINK_FAILED_UNKNOWN_MODE: u32 = 2835;
pub const SL_STATUS_WIFI_SECURE_LINK_EXCHANGE_FAILED: u32 = 2836;
pub const SL_STATUS_WIFI_WRONG_STATE: u32 = 2840;
pub const SL_STATUS_WIFI_CHANNEL_NOT_ALLOWED: u32 = 2841;
pub const SL_STATUS_WIFI_NO_MATCHING_AP: u32 = 2842;
pub const SL_STATUS_WIFI_CONNECTION_ABORTED: u32 = 2843;
pub const SL_STATUS_WIFI_CONNECTION_TIMEOUT: u32 = 2844;
pub const SL_STATUS_WIFI_CONNECTION_REJECTED_BY_AP: u32 = 2845;
pub const SL_STATUS_WIFI_CONNECTION_AUTH_FAILURE: u32 = 2846;
pub const SL_STATUS_WIFI_RETRY_EXCEEDED: u32 = 2847;
pub const SL_STATUS_WIFI_TX_LIFETIME_EXCEEDED: u32 = 2848;
/* automatically generated by rust-bindgen 0.64.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 32;
pub const __WORDSIZE32_SIZE_ULONG: u32 = 0;
pub const __WORDSIZE32_PTRDIFF_LONG: u32 = 0;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 0;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 32;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 0;
pub const __STATFS_MATCHES_STATFS64: u32 = 0;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 2147483647;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const SL_WFX_API_VERSION_MINOR: u32 = 8;
pub const SL_WFX_API_VERSION_MAJOR: u32 = 3;
pub const SL_WFX_SSID_SIZE: u32 = 32;
pub const SL_WFX_MAC_ADDR_SIZE: u32 = 6;
pub const SL_WFX_BSSID_SIZE: u32 = 6;
pub const GENERAL_INTERFACE_ID: u32 = 2;
pub const SL_WFX_MSG_ID_MASK: u32 = 255;
pub const SL_WFX_MSG_TYPE_MASK: u32 = 128;
pub const SL_WFX_MSG_SEQ_RANGE: u32 = 7;
pub const SL_WFX_REQ_BASE: u32 = 0;
pub const SL_WFX_CNF_BASE: u32 = 0;
pub const SL_WFX_IND_BASE: u32 = 128;
pub const SL_WFX_OPN_SIZE: u32 = 14;
pub const SL_WFX_UID_SIZE: u32 = 8;
pub const SL_WFX_DISABLED_CHANNEL_LIST_SIZE: u32 = 2;
pub const SL_WFX_FIRMWARE_LABEL_SIZE: u32 = 128;
pub const SL_WFX_EXCEPTION_DATA_SIZE_MAX: u32 = 1600;
pub const SL_WFX_KEY_VALUE_SIZE: u32 = 32;
pub const SL_WFX_HOST_PUB_KEY_SIZE: u32 = 32;
pub const SL_WFX_HOST_PUB_KEY_MAC_SIZE: u32 = 64;
pub const SL_WFX_NCP_PUB_KEY_SIZE: u32 = 32;
pub const SL_WFX_NCP_PUB_KEY_MAC_SIZE: u32 = 64;
pub const SL_WFX_SESSION_KEY_PROTECTION_DISABLE_MAGIC: u32 = 4196525571;
pub const SL_WFX_ENCR_BMP_SIZE: u32 = 32;
pub const SL_WFX_FMAC_MAC_ADDR_SIZE: u32 = 6;
pub const SL_WFX_FMAC_BSSID_SIZE: u32 = 6;
pub const SL_WFX_PASSWORD_SIZE: u32 = 64;
pub const SL_WFX_CHANNEL_NUMBER_SIZE: u32 = 14;
pub const SL_WFX_SSID_DEF_SIZE: u32 = 2;
pub const SL_WFX_FMAC_SSID_SIZE: u32 = 32;
pub const SL_WFX_ARP_IP_ADDR_SIZE: u32 = 2;
pub const SL_WFX_NS_IP_ADDR_SIZE: u32 = 2;
pub const SL_WFX_IPV6_ADDR_SIZE: u32 = 16;
pub const SL_WFX_IE_DATA_FILTER_SIZE: u32 = 16;
pub const FIRMWARE_VERSION: &[u8; 7usize] = b"3.16.0\0";
pub const FMAC_DRIVER_VERSION_MAJOR: u32 = 3;
pub const FMAC_DRIVER_VERSION_MINOR: u32 = 6;
pub const FMAC_DRIVER_VERSION_REVISION: u32 = 0;
pub const FMAC_DRIVER_VERSION_RC: u32 = 255;
pub const FMAC_DRIVER_RC_RELEASE: u32 = 255;
pub const FMAC_DRIVER_RC_DEVELOPMENT: u32 = 0;
pub const FMAC_DRIVER_VERSION_STRING_SUFFIX: &[u8; 1usize] = b"\0";
pub const FMAC_DRIVER_VERSION: u32 = 50725119;
pub const SL_WFX_DEFAULT_REQUEST_TIMEOUT_MS: u32 = 5000;
pub const SL_WFX_SLK_CURVE25519: u32 = 0;
pub const SL_WFX_SDIO_BLOCK_SIZE: u32 = 64;
pub const SL_WAIT_FOREVER: u32 = 4294967295;
pub const SL_WFX_ROUND_UP_VALUE: u32 = 64;
pub const SL_WFX_DEBUG_MASK: u32 = 0;
pub const SL_WFX_DEBUG_ERROR: u32 = 1;
pub const SL_WFX_DEBUG_INIT: u32 = 2;
pub const SL_WFX_DEBUG_SLEEP: u32 = 4;
pub const SL_WFX_DEBUG_SLK: u32 = 8;
pub const SL_WFX_DEBUG_RX: u32 = 16;
pub const SL_WFX_DEBUG_RX_RAW: u32 = 32;
pub const SL_WFX_DEBUG_RX_REG: u32 = 64;
pub const SL_WFX_DEBUG_TX: u32 = 128;
pub const SL_WFX_DEBUG_TX_RAW: u32 = 256;
pub const SL_WFX_DEBUG_TX_REG: u32 = 512;
pub const SL_WFX_DEBUG_FW_LOAD: u32 = 1024;
pub const SL_WFX_PDS_KEY_A: u8 = 97u8;
pub const SL_WFX_PDS_KEY_B: u8 = 98u8;
pub const SL_WFX_PDS_KEY_C: u8 = 99u8;
pub const SL_WFX_PDS_KEY_D: u8 = 100u8;
pub const SL_WFX_PDS_KEY_E: u8 = 101u8;
pub const SL_WFX_PDS_KEY_F: u8 = 102u8;
pub const SL_WFX_PDS_ANTENNA_SEL_KEY: u8 = 106u8;
pub const SL_WFX_PTE_INFO: u32 = 151044288;
pub const SL_WFX_MSG_ID_GENERAL_API_MASK: u32 = 32;
pub const SL_WFX_MSG_INFO_INTERFACE_OFFSET: u32 = 1;
pub const SL_WFX_MSG_INFO_INTERFACE_MASK: u32 = 6;
pub const SYS_BASE_ADDR_SILICON: u32 = 0;
pub const PAC_BASE_ADDRESS_SILICON: u32 = 150994944;
pub const PAC_SHARED_MEMORY_SILICON: u32 = 150994944;
pub const DOWNLOAD_BOOT_LOADER_OFFSET: u32 = 0;
pub const DOWNLOAD_FIFO_SIZE: u32 = 32768;
pub const DOWNLOAD_CTRL_DATA_DWORDS: u32 = 26;
pub const DOWNLOAD_CTRL_OFFSET: u32 = 151044096;
pub const DOWNLOAD_IMAGE_SIZE_REG: u32 = 151044096;
pub const DOWNLOAD_DEBUG_DATA_LEN: u32 = 108;
pub const DOWNLOAD_BLOCK_SIZE: u32 = 1024;
pub const ADDR_DWL_CTRL_AREA: u32 = 151044096;
pub const FW_KEYSET_SIZE: u32 = 8;
pub const FW_SIGNATURE_SIZE: u32 = 64;
pub const FW_HASH_SIZE: u32 = 8;
pub const ADDR_DWL_CTRL_AREA_IMAGE_SIZE: u32 = 151044096;
pub const ADDR_DWL_CTRL_AREA_PUT: u32 = 151044100;
pub const ADDR_DWL_CTRL_AREA_GET: u32 = 151044104;
pub const ADDR_DWL_CTRL_AREA_HOST_STATUS: u32 = 151044108;
pub const ADDR_DWL_CTRL_AREA_NCP_STATUS: u32 = 151044112;
pub const ADDR_DWL_CTRL_AREA_SIGNATURE: u32 = 151044116;
pub const ADDR_DWL_CTRL_AREA_FW_HASH: u32 = 151044180;
pub const ADDR_DWL_CTRL_AREA_FW_VERSION: u32 = 151044188;
pub const HOST_STATE_UNDEF: u32 = 4294967295;
pub const HOST_STATE_NOT_READY: u32 = 305419896;
pub const HOST_STATE_READY: u32 = 2271560481;
pub const HOST_STATE_HOST_INFO_READ: u32 = 2807283097;
pub const HOST_STATE_UPLOAD_PENDING: u32 = 2882395322;
pub const HOST_STATE_UPLOAD_COMPLETE: u32 = 3569765017;
pub const HOST_STATE_OK_TO_JUMP: u32 = 391104642;
pub const NCP_STATE_UNDEF: u32 = 4294967295;
pub const NCP_STATE_NOT_READY: u32 = 305419896;
pub const NCP_STATE_INFO_READY: u32 = 3176394649;
pub const NCP_STATE_READY: u32 = 2271560481;
pub const NCP_STATE_DOWNLOAD_PENDING: u32 = 2882395322;
pub const NCP_STATE_DOWNLOAD_COMPLETE: u32 = 3405709002;
pub const NCP_STATE_AUTH_OK: u32 = 3569765017;
pub const NCP_STATE_AUTH_FAIL: u32 = 391104642;
pub const NCP_STATE_PUB_KEY_RDY: u32 = 2058624281;
pub const ADDR_DOWNLOAD_FIFO_BASE: u32 = 151011328;
pub const ADDR_DOWNLOAD_FIFO_END: u32 = 151044096;
pub const ADDR_SHARED_RAM_DEBUG_AREA: u32 = 151003136;
pub const SL_WFX_CONT_REGISTER_SIZE: u32 = 2;
pub const SL_WFX_CONT_NEXT_LEN_MASK: u32 = 4095;
pub const SL_WFX_CONT_FRAME_TYPE_OFFSET: u32 = 14;
pub const SL_WFX_CONFIG_ERROR_MASK: u32 = 15;
pub const SL_WFX_CONFIG_REVISION_OFFSET: u32 = 24;
pub const SL_WFX_CONFIG_REVISION_MASK: u32 = 7;
pub const SL_WFX_CONFIG_TYPE_OFFSET: u32 = 31;
pub const SL_WFX_CONFIG_TYPE_MASK: u32 = 1;
pub const SL_WFX_SDIO_CCCR_IO_QUEUE_ENABLE: u32 = 2;
pub const SL_WFX_SDIO_CCCR_IRQ_ENABLE: u32 = 4;
pub const SL_WFX_SDIO_CCCR_BUS_INTERFACE_CONTROL: u32 = 7;
pub const SL_WFX_SDIO_CCCR_HIGH_SPEED_ENABLE: u32 = 19;
pub const SL_WFX_SDIO_FBR1_BLOCK_SIZE_LSB: u32 = 272;
pub const SL_WFX_SDIO_FBR1_BLOCK_SIZE_MSB: u32 = 273;
pub const FW_VERSION_VALUE: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &[u8; 6usize] = b"stosl\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 24;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 36;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 32;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 20;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 0;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub type __u_char = c_types::c_uchar;
pub type __u_short = c_types::c_ushort;
pub type __u_int = c_types::c_uint;
pub type __u_long = c_types::c_ulong;
pub type __int8_t = c_types::c_schar;
pub type __uint8_t = c_types::c_uchar;
pub type __int16_t = c_types::c_short;
pub type __uint16_t = c_types::c_ushort;
pub type __int32_t = c_types::c_int;
pub type __uint32_t = c_types::c_uint;
pub type __int64_t = c_types::c_longlong;
pub type __uint64_t = c_types::c_ulonglong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = c_types::c_longlong;
pub type __u_quad_t = c_types::c_ulonglong;
pub type __intmax_t = c_types::c_longlong;
pub type __uintmax_t = c_types::c_ulonglong;
pub type __dev_t = __uint64_t;
pub type __uid_t = c_types::c_uint;
pub type __gid_t = c_types::c_uint;
pub type __ino_t = c_types::c_ulong;
pub type __ino64_t = __uint64_t;
pub type __mode_t = c_types::c_uint;
pub type __nlink_t = c_types::c_uint;
pub type __off_t = c_types::c_long;
pub type __off64_t = __int64_t;
pub type __pid_t = c_types::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __fsid_t {
    pub __val: [c_types::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::core::mem::MaybeUninit<__fsid_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = c_types::c_long;
pub type __rlim_t = c_types::c_ulong;
pub type __rlim64_t = __uint64_t;
pub type __id_t = c_types::c_uint;
pub type __time_t = c_types::c_long;
pub type __useconds_t = c_types::c_uint;
pub type __suseconds_t = c_types::c_long;
pub type __daddr_t = c_types::c_int;
pub type __key_t = c_types::c_int;
pub type __clockid_t = c_types::c_int;
pub type __timer_t = *mut c_types::c_void;
pub type __blksize_t = c_types::c_long;
pub type __blkcnt_t = c_types::c_long;
pub type __blkcnt64_t = __int64_t;
pub type __fsblkcnt_t = c_types::c_ulong;
pub type __fsblkcnt64_t = __uint64_t;
pub type __fsfilcnt_t = c_types::c_ulong;
pub type __fsfilcnt64_t = __uint64_t;
pub type __fsword_t = c_types::c_int;
pub type __ssize_t = c_types::c_int;
pub type __syscall_slong_t = c_types::c_long;
pub type __syscall_ulong_t = c_types::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut c_types::c_char;
pub type __intptr_t = c_types::c_int;
pub type __socklen_t = c_types::c_uint;
pub type __sig_atomic_t = c_types::c_int;
pub type __time64_t = __int64_t;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = c_types::c_schar;
pub type int_fast16_t = c_types::c_int;
pub type int_fast32_t = c_types::c_int;
pub type int_fast64_t = c_types::c_longlong;
pub type uint_fast8_t = c_types::c_uchar;
pub type uint_fast16_t = c_types::c_uint;
pub type uint_fast32_t = c_types::c_uint;
pub type uint_fast64_t = c_types::c_ulonglong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = "   DATA TYPES   *******************************"]
pub type sl_status_t = u32;
#[doc = "<Firmware rollback error, no data returned"]
pub const sl_wfx_error_e_SL_WFX_ERROR_FIRMWARE_ROLLBACK: sl_wfx_error_e = 0;
#[doc = "<Not used anymore"]
pub const sl_wfx_error_e_SL_WFX_ERROR_DEPRECATED_0: sl_wfx_error_e = 1;
#[doc = "<Not used anymore"]
pub const sl_wfx_error_e_SL_WFX_ERROR_DEPRECATED_1: sl_wfx_error_e = 2;
#[doc = "<Secure Link Session key is invalid (probably not initialized)"]
pub const sl_wfx_error_e_SL_WFX_ERROR_INVALID_SESSION_KEY: sl_wfx_error_e = 3;
#[doc = "<Out-of-range power supply voltage detected, the last voltage value is returned. Param: measured voltage (mV)"]
pub const sl_wfx_error_e_SL_WFX_ERROR_OOR_VOLTAGE: sl_wfx_error_e = 4;
#[doc = "<Wrong PDS version detected, no data returned"]
pub const sl_wfx_error_e_SL_WFX_ERROR_PDS_VERSION: sl_wfx_error_e = 5;
#[doc = "<Out-of-range temperature, no data returned"]
pub const sl_wfx_error_e_SL_WFX_ERROR_OOR_TEMPERATURE: sl_wfx_error_e = 6;
#[doc = "<Requests from Host are forbidden until the end of key exchange (Host should wait for the associated indication)"]
pub const sl_wfx_error_e_SL_WFX_ERROR_REQ_DURING_KEY_EXCHANGE: sl_wfx_error_e = 7;
#[doc = "<Not used anymore"]
pub const sl_wfx_error_e_SL_WFX_ERROR_DEPRECATED_2: sl_wfx_error_e = 8;
#[doc = "<Not used anymore"]
pub const sl_wfx_error_e_SL_WFX_ERROR_DEPRECATED_3: sl_wfx_error_e = 9;
#[doc = "<An error occured during message decryption (can be a counter mismatch or wrong CCM tag)"]
pub const sl_wfx_error_e_SL_WFX_ERROR_SECURELINK_DECRYPTION: sl_wfx_error_e = 10;
#[doc = "< Encryption state of the received message doesn't match the SecureLink bitmap. Param: was encrypted"]
pub const sl_wfx_error_e_SL_WFX_ERROR_SECURELINK_WRONG_ENCRYPTION_STATE: sl_wfx_error_e = 11;
#[doc = "<SPI or SDIO bus clock is too slow (<1kHz)"]
pub const sl_wfx_error_e_SL_WFX_SPI_OR_SDIO_FREQ_TOO_LOW: sl_wfx_error_e = 12;
#[doc = "<Not used anymore"]
pub const sl_wfx_error_e_SL_WFX_ERROR_DEPRECATED_4: sl_wfx_error_e = 13;
#[doc = "<Not used anymore"]
pub const sl_wfx_error_e_SL_WFX_ERROR_DEPRECATED_5: sl_wfx_error_e = 14;
#[doc = "<HIF HW has reported an error. Param: HIF status register"]
pub const sl_wfx_error_e_SL_WFX_HIF_BUS_ERROR: sl_wfx_error_e = 15;
#[doc = "<Unknown TestFeatureMode during test feature init"]
pub const sl_wfx_error_e_SL_WFX_PDS_TESTFEATURE_MODE_ERROR: sl_wfx_error_e = 16;
#[doc = "<The SecureLink bitmap must be configured right after key exchange"]
pub const sl_wfx_error_e_SL_WFX_ERROR_SECURELINK_EXPECTED_BITMAP: sl_wfx_error_e = 17;
#[doc = " @brief specifies the type of error reported by the indication message sl_wfx_error_ind_body_t\n"]
pub type sl_wfx_error_e = c_types::c_uint;
#[doc = " @brief specifies the type of error reported by the indication message sl_wfx_error_ind_body_t\n"]
pub use self::sl_wfx_error_e as sl_wfx_error_t;
#[doc = "< Data rate 802.11b 1Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_B_1MBPS: sl_wfx_rate_index_e = 0;
#[doc = "< Data rate 802.11b 2Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_B_2MBPS: sl_wfx_rate_index_e = 1;
#[doc = "< Data rate 802.11b 5.5Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_B_5P5MBPS: sl_wfx_rate_index_e = 2;
#[doc = "< Data rate 802.11b 11Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_B_11MBPS: sl_wfx_rate_index_e = 3;
#[doc = "<ERP-PBCC, not supported"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_PBCC_22MBPS: sl_wfx_rate_index_e = 4;
#[doc = "<ERP-PBCC, not supported"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_PBCC_33MBPS: sl_wfx_rate_index_e = 5;
#[doc = "< Data rate 802.11g 6Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_G_6MBPS: sl_wfx_rate_index_e = 6;
#[doc = "< Data rate 802.11g 9Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_G_9MBPS: sl_wfx_rate_index_e = 7;
#[doc = "< Data rate 802.11g 12Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_G_12MBPS: sl_wfx_rate_index_e = 8;
#[doc = "< Data rate 802.11g 18Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_G_18MBPS: sl_wfx_rate_index_e = 9;
#[doc = "< Data rate 802.11g 24Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_G_24MBPS: sl_wfx_rate_index_e = 10;
#[doc = "< Data rate 802.11g 36Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_G_36MBPS: sl_wfx_rate_index_e = 11;
#[doc = "< Data rate 802.11g 48Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_G_48MBPS: sl_wfx_rate_index_e = 12;
#[doc = "< Data rate 802.11g 54Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_G_54MBPS: sl_wfx_rate_index_e = 13;
#[doc = "< Data rate 802.11n 6.5Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_N_6P5MBPS: sl_wfx_rate_index_e = 14;
#[doc = "< Data rate 802.11n 13Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_N_13MBPS: sl_wfx_rate_index_e = 15;
#[doc = "< Data rate 802.11n 19.5Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_N_19P5MBPS: sl_wfx_rate_index_e = 16;
#[doc = "< Data rate 802.11n 26Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_N_26MBPS: sl_wfx_rate_index_e = 17;
#[doc = "< Data rate 802.11n 39Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_N_39MBPS: sl_wfx_rate_index_e = 18;
#[doc = "< Data rate 802.11n 52Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_N_52MBPS: sl_wfx_rate_index_e = 19;
#[doc = "< Data rate 802.11n 58.5Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_N_58P5MBPS: sl_wfx_rate_index_e = 20;
#[doc = "< Data rate 802.11n 65Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_N_65MBPS: sl_wfx_rate_index_e = 21;
#[doc = "< Number of defined data rates"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_NUM_ENTRIES: sl_wfx_rate_index_e = 22;
#[doc = " @brief List of possible transmission rates.\n\n Note that ERP-PBCC is not supported by the hardware. The rate indices for 22 Mbit/s and 33 Mbit/s are only provided for standard compatibility.@n\n Data rates (in the names) are for 20 MHz channel operation. Corresponding data rates for 10 MHz channel operation are half of them.\n\n In this API, some parameters such as 'basic_rate_set' encode a list of rates in a bitstream format.@n\n     for instance SUPPORTED_B_RATES_MASK = 0x0000000F @n\n                  SUPPORTED_G_RATES_MASK = 0x00003FC0 @n\n                  SUPPORTED_N_RATES_MASK = 0x003FC000"]
pub type sl_wfx_rate_index_e = c_types::c_uint;
#[doc = " @brief List of possible transmission rates.\n\n Note that ERP-PBCC is not supported by the hardware. The rate indices for 22 Mbit/s and 33 Mbit/s are only provided for standard compatibility.@n\n Data rates (in the names) are for 20 MHz channel operation. Corresponding data rates for 10 MHz channel operation are half of them.\n\n In this API, some parameters such as 'basic_rate_set' encode a list of rates in a bitstream format.@n\n     for instance SUPPORTED_B_RATES_MASK = 0x0000000F @n\n                  SUPPORTED_G_RATES_MASK = 0x00003FC0 @n\n                  SUPPORTED_N_RATES_MASK = 0x003FC000"]
pub use self::sl_wfx_rate_index_e as sl_wfx_rate_index_t;
#[doc = " @brief General Message header structure\n"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_header_s {
    #[doc = "< Message length in bytes including this uint16_t.\n< Maximum value is 8188 but maximum Request size is FW dependent and reported in the ::sl_wfx_startup_ind_body_t::size_inp_ch_buf."]
    pub length: u16,
    #[doc = "< Contains the message Id indexed by sl_wfx_general_commands_ids_t or sl_wfx_message_ids_t."]
    pub id: u8,
    #[doc = "< TODO comment missing"]
    pub info: u8,
}
#[test]
fn bindgen_test_layout_sl_wfx_header_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_header_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_header_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_header_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_header_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_header_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_header_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_header_s),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_header_s),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief General Message header structure\n"]
pub type sl_wfx_header_t = sl_wfx_header_s;
#[doc = " @brief Generic message structure for all requests, confirmations and indications\n"]
#[repr(C, packed)]
pub struct sl_wfx_generic_message_s {
    #[doc = "<4 bytes header"]
    pub header: sl_wfx_header_t,
    #[doc = "<variable size payload of the message"]
    pub body: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_generic_message_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_generic_message_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_generic_message_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_generic_message_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_generic_message_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_generic_message_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_generic_message_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_generic_message_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Generic message structure for all requests, confirmations and indications\n"]
pub type sl_wfx_generic_message_t = sl_wfx_generic_message_s;
#[doc = " @brief Generic confirmation message with the body reduced to the status field.\n\n This structure is not related to a specific confirmation ID. @n\n It is a global simplified structure that can be used to easily access the header and status fields.\n\n All confirmation bodies start with a status word and in a lot of them it is followed by other data (not present in this structure)."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_generic_confirmation_s {
    #[doc = "<4 bytes header"]
    pub header: sl_wfx_header_t,
    #[doc = "<See enum sl_wfx_status_t"]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_generic_confirmation_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_generic_confirmation_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_generic_confirmation_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_generic_confirmation_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_generic_confirmation_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_generic_confirmation_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_generic_confirmation_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_generic_confirmation_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Generic confirmation message with the body reduced to the status field.\n\n This structure is not related to a specific confirmation ID. @n\n It is a global simplified structure that can be used to easily access the header and status fields.\n\n All confirmation bodies start with a status word and in a lot of them it is followed by other data (not present in this structure)."]
pub type sl_wfx_generic_confirmation_t = sl_wfx_generic_confirmation_s;
#[doc = "< \\b CONFIGURATION request Id use body sl_wfx_configuration_req_body_t and returns sl_wfx_configuration_cnf_body_t"]
pub const sl_wfx_generic_requests_ids_e_SL_WFX_CONFIGURATION_REQ_ID: sl_wfx_generic_requests_ids_e =
    9;
#[doc = "< \\b CONTROL_GPIO request Id use body sl_wfx_control_gpio_req_body_t and returns sl_wfx_control_gpio_cnf_body_t"]
pub const sl_wfx_generic_requests_ids_e_SL_WFX_CONTROL_GPIO_REQ_ID: sl_wfx_generic_requests_ids_e =
    38;
#[doc = "< \\b SET_SECURELINK_MAC_KEY request Id use body sl_wfx_set_securelink_mac_key_req_body_t and returns sl_wfx_set_securelink_mac_key_cnf_body_t"]
pub const sl_wfx_generic_requests_ids_e_SL_WFX_SET_SECURELINK_MAC_KEY_REQ_ID:
    sl_wfx_generic_requests_ids_e = 39;
#[doc = "< \\b SECURELINK_EXCHANGE_PUB_KEYS request Id use body sl_wfx_securelink_exchange_pub_keys_req_body_t and returns sl_wfx_securelink_exchange_pub_keys_cnf_body_t"]
pub const sl_wfx_generic_requests_ids_e_SL_WFX_SECURELINK_EXCHANGE_PUB_KEYS_REQ_ID:
    sl_wfx_generic_requests_ids_e = 40;
#[doc = "< \\b SECURELINK_CONFIGURE request Id use body sl_wfx_securelink_configure_req_body_t and returns sl_wfx_securelink_exchange_pub_keys_cnf_body_t"]
pub const sl_wfx_generic_requests_ids_e_SL_WFX_SECURELINK_CONFIGURE_REQ_ID:
    sl_wfx_generic_requests_ids_e = 41;
#[doc = "< \\b PREVENT_ROLLBACK request Id use body sl_wfx_prevent_rollback_req_body_t and returns sl_wfx_prevent_rollback_cnf_body_t"]
pub const sl_wfx_generic_requests_ids_e_SL_WFX_PREVENT_ROLLBACK_REQ_ID:
    sl_wfx_generic_requests_ids_e = 42;
#[doc = "< \\b PTA_SETTINGS request Id use body sl_wfx_pta_settings_req_body_t and returns sl_wfx_pta_settings_cnf_body_t"]
pub const sl_wfx_generic_requests_ids_e_SL_WFX_PTA_SETTINGS_REQ_ID: sl_wfx_generic_requests_ids_e =
    43;
#[doc = "< \\b PTA_PRIORITY request Id use body sl_wfx_pta_priority_req_body_t and returns sl_wfx_pta_priority_cnf_body_t"]
pub const sl_wfx_generic_requests_ids_e_SL_WFX_PTA_PRIORITY_REQ_ID: sl_wfx_generic_requests_ids_e =
    44;
#[doc = "< \\b PTA_STATE request Id use body sl_wfx_pta_state_req_body_t and returns sl_wfx_pta_state_cnf_body_t"]
pub const sl_wfx_generic_requests_ids_e_SL_WFX_PTA_STATE_REQ_ID: sl_wfx_generic_requests_ids_e = 45;
#[doc = "< \\b SET_CCA_CONFIG request Id uses body sl_wfx_set_cca_config_req_body_t and returns sl_wfx_set_cca_config_cnf_body_t"]
pub const sl_wfx_generic_requests_ids_e_SL_WFX_SET_CCA_CONFIG_REQ_ID:
    sl_wfx_generic_requests_ids_e = 46;
#[doc = "< \\b SHUT_DOWN request Id use body sl_wfx_shut_down_req_t and never returns"]
pub const sl_wfx_generic_requests_ids_e_SL_WFX_SHUT_DOWN_REQ_ID: sl_wfx_generic_requests_ids_e = 50;
#[doc = " @brief General request message IDs\n\n API general request message IDs available in both split and full MAC.\n These are messages from the host towards the WLAN."]
pub type sl_wfx_generic_requests_ids_e = c_types::c_uint;
#[doc = " @brief General request message IDs\n\n API general request message IDs available in both split and full MAC.\n These are messages from the host towards the WLAN."]
pub use self::sl_wfx_generic_requests_ids_e as sl_wfx_generic_requests_ids_t;
#[doc = "< \\b CONFIGURATION confirmation Id returns body sl_wfx_configuration_cnf_body_t"]
pub const sl_wfx_general_confirmations_ids_e_SL_WFX_CONFIGURATION_CNF_ID:
    sl_wfx_general_confirmations_ids_e = 9;
#[doc = "< \\b CONTROL_GPIO confirmation Id returns body sl_wfx_control_gpio_cnf_body_t"]
pub const sl_wfx_general_confirmations_ids_e_SL_WFX_CONTROL_GPIO_CNF_ID:
    sl_wfx_general_confirmations_ids_e = 38;
#[doc = "< \\b SET_SECURELINK_MAC_KEY confirmation Id returns body sl_wfx_set_securelink_mac_key_cnf_body_t"]
pub const sl_wfx_general_confirmations_ids_e_SL_WFX_SET_SECURELINK_MAC_KEY_CNF_ID:
    sl_wfx_general_confirmations_ids_e = 39;
#[doc = "< \\b SECURELINK_EXCHANGE_PUB_KEYS confirmation Id returns body sl_wfx_securelink_exchange_pub_keys_cnf_body_t"]
pub const sl_wfx_general_confirmations_ids_e_SL_WFX_SECURELINK_EXCHANGE_PUB_KEYS_CNF_ID:
    sl_wfx_general_confirmations_ids_e = 40;
#[doc = "< \\b SECURELINK_CONFIGURE confirmation Id returns body sl_wfx_securelink_configure_cnf_body_t"]
pub const sl_wfx_general_confirmations_ids_e_SL_WFX_SECURELINK_CONFIGURE_CNF_ID:
    sl_wfx_general_confirmations_ids_e = 41;
#[doc = "< \\b PREVENT_ROLLBACK confirmation Id use body sl_wfx_prevent_rollback_cnf_body_t"]
pub const sl_wfx_general_confirmations_ids_e_SL_WFX_PREVENT_ROLLBACK_CNF_ID:
    sl_wfx_general_confirmations_ids_e = 42;
#[doc = "< \\b PTA_SETTINGS confirmation Id returns sl_wfx_pta_settings_cnf_body_t"]
pub const sl_wfx_general_confirmations_ids_e_SL_WFX_PTA_SETTINGS_CNF_ID:
    sl_wfx_general_confirmations_ids_e = 43;
#[doc = "< \\b PTA_PRIORITY confirmation Id returns sl_wfx_pta_priority_cnf_body_t"]
pub const sl_wfx_general_confirmations_ids_e_SL_WFX_PTA_PRIORITY_CNF_ID:
    sl_wfx_general_confirmations_ids_e = 44;
#[doc = "< \\b PTA_STATE confirmation Id returns sl_wfx_pta_state_cnf_body_t"]
pub const sl_wfx_general_confirmations_ids_e_SL_WFX_PTA_STATE_CNF_ID:
    sl_wfx_general_confirmations_ids_e = 45;
#[doc = "< \\b SET_CCA_CONFIG confirmation Id returns body sl_wfx_set_cca_config_cnf_body_t"]
pub const sl_wfx_general_confirmations_ids_e_SL_WFX_SET_CCA_CONFIG_CNF_ID:
    sl_wfx_general_confirmations_ids_e = 46;
#[doc = " @brief General confirmation message IDs\n\n API general confirmation message IDs returned by requests described in sl_wfx_general_requests_ids.\n These are messages from the WLAN towards the host."]
pub type sl_wfx_general_confirmations_ids_e = c_types::c_uint;
#[doc = " @brief General confirmation message IDs\n\n API general confirmation message IDs returned by requests described in sl_wfx_general_requests_ids.\n These are messages from the WLAN towards the host."]
pub use self::sl_wfx_general_confirmations_ids_e as sl_wfx_general_confirmations_ids_t;
#[doc = "< \\b EXCEPTION indication Id content is sl_wfx_exception_ind_body_t"]
pub const sl_wfx_general_indications_ids_e_SL_WFX_EXCEPTION_IND_ID:
    sl_wfx_general_indications_ids_e = 224;
#[doc = "< \\b STARTUP indication Id content is sl_wfx_startup_ind_body_t"]
pub const sl_wfx_general_indications_ids_e_SL_WFX_STARTUP_IND_ID: sl_wfx_general_indications_ids_e =
    225;
#[doc = "< \\b WAKE UP indication Id has no content"]
pub const sl_wfx_general_indications_ids_e_SL_WFX_WAKEUP_IND_ID: sl_wfx_general_indications_ids_e =
    226;
#[doc = "< \\b GENERIC indication Id content is sl_wfx_generic_ind_body_t"]
pub const sl_wfx_general_indications_ids_e_SL_WFX_GENERIC_IND_ID: sl_wfx_general_indications_ids_e =
    227;
#[doc = "< \\b ERROR indication Id content is sl_wfx_error_ind_body_t"]
pub const sl_wfx_general_indications_ids_e_SL_WFX_ERROR_IND_ID: sl_wfx_general_indications_ids_e =
    228;
#[doc = "< \\b SECURELINK_EXCHANGE_PUB_KEYS indication Id content is sl_wfx_securelink_exchange_pub_keys_ind_body_t"]
pub const sl_wfx_general_indications_ids_e_SL_WFX_SECURELINK_EXCHANGE_PUB_KEYS_IND_ID:
    sl_wfx_general_indications_ids_e = 229;
#[doc = " @brief General indications message IDs\n\n API general indication message IDs available in both split and full MAC.\n These are messages from the WLAN towards the host."]
pub type sl_wfx_general_indications_ids_e = c_types::c_uint;
#[doc = " @brief General indications message IDs\n\n API general indication message IDs available in both split and full MAC.\n These are messages from the WLAN towards the host."]
pub use self::sl_wfx_general_indications_ids_e as sl_wfx_general_indications_ids_t;
#[doc = " @brief General command message IDs\n\n All general API message IDs."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sl_wfx_general_commands_ids_u {
    #[doc = "< Request from the host to the WLAN device"]
    pub request: sl_wfx_generic_requests_ids_t,
    #[doc = "< Confirmation of a request from the WLAN device to the host"]
    pub confirmation: sl_wfx_general_confirmations_ids_t,
    #[doc = "< Indication from the WLAN device to the host"]
    pub indication: sl_wfx_general_indications_ids_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_general_commands_ids_u() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_general_commands_ids_u> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_general_commands_ids_u>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_general_commands_ids_u))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_general_commands_ids_u>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_general_commands_ids_u))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).request) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_general_commands_ids_u),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).confirmation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_general_commands_ids_u),
            "::",
            stringify!(confirmation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).indication) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_general_commands_ids_u),
            "::",
            stringify!(indication)
        )
    );
}
#[doc = " @brief General command message IDs\n\n All general API message IDs."]
pub type sl_wfx_general_commands_ids_t = sl_wfx_general_commands_ids_u;
#[doc = "<The firmware has successfully completed the request."]
pub const sl_wfx_status_e_SL_WFX_STATUS_SUCCESS: sl_wfx_status_e = 0;
#[doc = "<This is a generic failure code : other error codes do not apply."]
pub const sl_wfx_status_e_SL_WFX_STATUS_FAILURE: sl_wfx_status_e = 1;
#[doc = "<The request contains one or more invalid parameters."]
pub const sl_wfx_status_e_SL_WFX_INVALID_PARAMETER: sl_wfx_status_e = 2;
#[doc = "<Warning : the GPIO CMD is successful but the read value is not as expected (likely a drive conflict on the line)"]
pub const sl_wfx_status_e_SL_WFX_STATUS_GPIO_WARNING: sl_wfx_status_e = 3;
#[doc = "<Unknown request ID or wrong interface ID used"]
pub const sl_wfx_status_e_SL_WFX_ERROR_UNSUPPORTED_MSG_ID: sl_wfx_status_e = 4;
#[doc = "<Key has been correctly written"]
pub const sl_wfx_status_e_SL_WFX_MAC_KEY_STATUS_SUCCESS: sl_wfx_status_e = 90;
#[doc = "<Key already exists in OTP"]
pub const sl_wfx_status_e_SL_WFX_MAC_KEY_STATUS_FAILED_KEY_ALREADY_BURNED: sl_wfx_status_e = 107;
#[doc = "<RAM mode is not allowed"]
pub const sl_wfx_status_e_SL_WFX_MAC_KEY_STATUS_FAILED_RAM_MODE_NOT_ALLOWED: sl_wfx_status_e = 124;
#[doc = "<Unknown mode (should be RAM or OTP)"]
pub const sl_wfx_status_e_SL_WFX_MAC_KEY_STATUS_FAILED_UNKNOWN_MODE: sl_wfx_status_e = 141;
#[doc = "<Host Public Key authenticated"]
pub const sl_wfx_status_e_SL_WFX_PUB_KEY_EXCHANGE_STATUS_SUCCESS: sl_wfx_status_e = 158;
#[doc = "<Host Public Key authentication failed"]
pub const sl_wfx_status_e_SL_WFX_PUB_KEY_EXCHANGE_STATUS_FAILED: sl_wfx_status_e = 175;
#[doc = "<OTP rollback value has been successfully updated"]
pub const sl_wfx_status_e_SL_WFX_PREVENT_ROLLBACK_CNF_SUCCESS: sl_wfx_status_e = 4660;
#[doc = "<Wrong magic word detected"]
pub const sl_wfx_status_e_SL_WFX_PREVENT_ROLLBACK_CNF_WRONG_MAGIC_WORD: sl_wfx_status_e = 4694;
#[doc = " @brief General confirmation possible values for returned 'status' field\n WLAN\n All general confirmation messages have a field 'status' just after the message header.@n\n A value of zero indicates the request is completed successfully.\n"]
pub type sl_wfx_status_e = c_types::c_uint;
#[doc = " @brief General confirmation possible values for returned 'status' field\n WLAN\n All general confirmation messages have a field 'status' just after the message header.@n\n A value of zero indicates the request is completed successfully.\n"]
pub use self::sl_wfx_status_e as sl_wfx_status_t;
#[doc = "<Test Firmware"]
pub const sl_wfx_type_e_SL_WFX_FW_TYPE_ETF: sl_wfx_type_e = 0;
#[doc = "<WLAN Full MAC (WFM)"]
pub const sl_wfx_type_e_SL_WFX_FW_TYPE_WFM: sl_wfx_type_e = 1;
#[doc = "<WLAN Split MAC (WSM)"]
pub const sl_wfx_type_e_SL_WFX_FW_TYPE_WSM: sl_wfx_type_e = 2;
#[doc = " @addtogroup General_Configuration\n @brief General configuration commands\n\n\n @{"]
pub type sl_wfx_type_e = c_types::c_uint;
#[doc = " @addtogroup General_Configuration\n @brief General configuration commands\n\n\n @{"]
pub use self::sl_wfx_type_e as sl_wfx_fw_type_t;
#[doc = " @brief Capabilities offered by the WLAN used in command sl_wfx_startup_ind_body_t"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_capabilities_s {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "<Bit 8-15 : Reserved"]
    pub reserved2: u8,
    #[doc = "<Bit 16-23 : Reserved"]
    pub reserved3: u8,
    #[doc = "<Bit 24-31 : Reserved"]
    pub reserved4: u8,
}
#[test]
fn bindgen_test_layout_sl_wfx_capabilities_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_capabilities_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_capabilities_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_capabilities_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_capabilities_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_capabilities_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_capabilities_s),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_capabilities_s),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved4) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_capabilities_s),
            "::",
            stringify!(reserved4)
        )
    );
}
impl sl_wfx_capabilities_s {
    #[inline]
    pub fn linkmode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_linkmode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(linkmode: u8, reserved1: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let linkmode: u8 = unsafe { ::core::mem::transmute(linkmode) };
            linkmode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let reserved1: u8 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief Capabilities offered by the WLAN used in command sl_wfx_startup_ind_body_t"]
pub type sl_wfx_capabilities_t = sl_wfx_capabilities_s;
#[doc = " @brief REGUL_SEL_MODE OTP field reported in command sl_wfx_startup_ind_body_t"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_otp_regul_sel_mode_info_s {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_sl_wfx_otp_regul_sel_mode_info_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_otp_regul_sel_mode_info_s>(),
        1usize,
        concat!("Size of: ", stringify!(sl_wfx_otp_regul_sel_mode_info_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_otp_regul_sel_mode_info_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_otp_regul_sel_mode_info_s)
        )
    );
}
impl sl_wfx_otp_regul_sel_mode_info_s {
    #[inline]
    pub fn region_sel_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_region_sel_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        region_sel_mode: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let region_sel_mode: u8 = unsafe { ::core::mem::transmute(region_sel_mode) };
            region_sel_mode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief REGUL_SEL_MODE OTP field reported in command sl_wfx_startup_ind_body_t"]
pub type sl_wfx_otp_regul_sel_mode_info_t = sl_wfx_otp_regul_sel_mode_info_s;
#[doc = " @brief OTP_PHY_INFO OTP field reported in command sl_wfx_startup_ind_body_t"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_otp_phy_info_s {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_sl_wfx_otp_phy_info_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_otp_phy_info_s>(),
        1usize,
        concat!("Size of: ", stringify!(sl_wfx_otp_phy_info_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_otp_phy_info_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_otp_phy_info_s))
    );
}
impl sl_wfx_otp_phy_info_s {
    #[inline]
    pub fn phy1_region(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_phy1_region(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn phy0_region(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_phy0_region(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn otp_phy_ver(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_otp_phy_ver(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        phy1_region: u8,
        phy0_region: u8,
        otp_phy_ver: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let phy1_region: u8 = unsafe { ::core::mem::transmute(phy1_region) };
            phy1_region as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let phy0_region: u8 = unsafe { ::core::mem::transmute(phy0_region) };
            phy0_region as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let otp_phy_ver: u8 = unsafe { ::core::mem::transmute(otp_phy_ver) };
            otp_phy_ver as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief OTP_PHY_INFO OTP field reported in command sl_wfx_startup_ind_body_t"]
pub type sl_wfx_otp_phy_info_t = sl_wfx_otp_phy_info_s;
#[doc = " @brief Startup Indication message.\n This is the first message sent to the host to confirm boot success.\n It gives detailed information on the HW and FW versions and capabilities"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_startup_ind_body_s {
    #[doc = "<Initialization status. A value of zero indicates the boot is completed successfully  (see enum sl_wfx_status_t)"]
    pub status: u32,
    #[doc = "<=RO misc_read_reg7 register value"]
    pub hardware_id: u16,
    #[doc = "<=OTP part_OPN"]
    pub opn: [u8; 14usize],
    #[doc = "<=OTP UID"]
    pub uid: [u8; 8usize],
    #[doc = "<Number of buffers available for request messages."]
    pub num_inp_ch_bufs: u16,
    #[doc = "<TX Buffer size in bytes=request message max size."]
    pub size_inp_ch_buf: u16,
    #[doc = "<number of STA that are supported in AP mode"]
    pub num_links_aP: u8,
    #[doc = "<number of interfaces (WIFI link : STA or AP) that can be created by the user"]
    pub num_interfaces: u8,
    #[doc = "<MAC addresses derived from OTP"]
    pub mac_addr: [[u8; 6usize]; 2usize],
    pub api_version_minor: u8,
    pub api_version_major: u8,
    #[doc = "<List some FW options"]
    pub capabilities: sl_wfx_capabilities_t,
    pub firmware_build: u8,
    pub firmware_minor: u8,
    pub firmware_major: u8,
    #[doc = "<See enum sl_wfx_fw_type_t"]
    pub firmware_type: u8,
    #[doc = "<=OTP Disabled channel list info"]
    pub disabled_channel_list: [u8; 2usize],
    #[doc = "<OTP region selection mode info"]
    pub regul_sel_mode_info: sl_wfx_otp_regul_sel_mode_info_t,
    #[doc = "<info on OTP backoff tables used to enforce the different DFS regulations."]
    pub otp_phy_info: sl_wfx_otp_phy_info_t,
    #[doc = "<A bit mask that indicates which rates are supported by the Physical layer. See enum api_rate_index."]
    pub supported_rate_mask: u32,
    #[doc = "<Null terminated text string describing the loaded FW."]
    pub firmware_label: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_startup_ind_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_startup_ind_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_startup_ind_body_s>(),
        192usize,
        concat!("Size of: ", stringify!(sl_wfx_startup_ind_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_startup_ind_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_startup_ind_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hardware_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(hardware_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opn) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(opn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_inp_ch_bufs) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(num_inp_ch_bufs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size_inp_ch_buf) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(size_inp_ch_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_links_aP) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(num_links_aP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_interfaces) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(num_interfaces)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).api_version_minor) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(api_version_minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).api_version_major) as usize - ptr as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(api_version_major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).capabilities) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).firmware_build) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(firmware_build)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).firmware_minor) as usize - ptr as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(firmware_minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).firmware_major) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(firmware_major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).firmware_type) as usize - ptr as usize },
        55usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(firmware_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disabled_channel_list) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(disabled_channel_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).regul_sel_mode_info) as usize - ptr as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(regul_sel_mode_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).otp_phy_info) as usize - ptr as usize },
        59usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(otp_phy_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supported_rate_mask) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(supported_rate_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).firmware_label) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(firmware_label)
        )
    );
}
#[doc = " @brief Startup Indication message.\n This is the first message sent to the host to confirm boot success.\n It gives detailed information on the HW and FW versions and capabilities"]
pub type sl_wfx_startup_ind_body_t = sl_wfx_startup_ind_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_startup_ind_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_startup_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_startup_ind_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_startup_ind_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_startup_ind_s>(),
        196usize,
        concat!("Size of: ", stringify!(sl_wfx_startup_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_startup_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_startup_ind_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_startup_ind_t = sl_wfx_startup_ind_s;
#[doc = " @brief General Message header structure\n"]
pub type sl_wfx_wakeup_ind_t = sl_wfx_header_t;
#[doc = " @brief Configure the device.\n It sends a PDS compressed file that configures the device regarding board dependent parameters.\n The PDS compressed file must fit in a command buffer and have less than 256 elements.\n\n @todo Need to create a specific doc to explain PDS"]
#[repr(C, packed)]
pub struct sl_wfx_configuration_req_body_s {
    #[doc = "<pds_data length in bytes"]
    pub length: u16,
    #[doc = "<variable size PDS data byte array"]
    pub pds_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_configuration_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_configuration_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_configuration_req_body_s>(),
        2usize,
        concat!("Size of: ", stringify!(sl_wfx_configuration_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_configuration_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_configuration_req_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_configuration_req_body_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pds_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_configuration_req_body_s),
            "::",
            stringify!(pds_data)
        )
    );
}
#[doc = " @brief Configure the device.\n It sends a PDS compressed file that configures the device regarding board dependent parameters.\n The PDS compressed file must fit in a command buffer and have less than 256 elements.\n\n @todo Need to create a specific doc to explain PDS"]
pub type sl_wfx_configuration_req_body_t = sl_wfx_configuration_req_body_s;
#[repr(C, packed)]
pub struct sl_wfx_configuration_req_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_configuration_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_configuration_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_configuration_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_configuration_req_s>(),
        6usize,
        concat!("Size of: ", stringify!(sl_wfx_configuration_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_configuration_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_configuration_req_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_configuration_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_configuration_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_configuration_req_t = sl_wfx_configuration_req_s;
#[doc = " @brief Confirmation message of CONFIGURATION command sl_wfx_configuration_req_body_t"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_configuration_cnf_body_s {
    #[doc = "<Configuration status. A value of zero indicates the boot is completed successfully (see enum sl_wfx_status_t)"]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_configuration_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_configuration_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_configuration_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_configuration_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_configuration_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_configuration_cnf_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_configuration_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message of CONFIGURATION command sl_wfx_configuration_req_body_t"]
pub type sl_wfx_configuration_cnf_body_t = sl_wfx_configuration_cnf_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_configuration_cnf_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_configuration_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_configuration_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_configuration_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_configuration_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_configuration_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_configuration_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_configuration_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_configuration_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_configuration_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_configuration_cnf_t = sl_wfx_configuration_cnf_s;
#[doc = "< Configure the GPIO to drive 0"]
pub const sl_wfx_gpio_mode_e_SL_WFX_GPIO_MODE_D0: sl_wfx_gpio_mode_e = 0;
#[doc = "< Configure the GPIO to drive 1"]
pub const sl_wfx_gpio_mode_e_SL_WFX_GPIO_MODE_D1: sl_wfx_gpio_mode_e = 1;
#[doc = "< Configure the GPIO to open drain with pull_down to 0"]
pub const sl_wfx_gpio_mode_e_SL_WFX_GPIO_MODE_OD0: sl_wfx_gpio_mode_e = 2;
#[doc = "< Configure the GPIO to open drain with pull_up to 1"]
pub const sl_wfx_gpio_mode_e_SL_WFX_GPIO_MODE_OD1: sl_wfx_gpio_mode_e = 3;
#[doc = "< Configure the GPIO to tristate"]
pub const sl_wfx_gpio_mode_e_SL_WFX_GPIO_MODE_TRISTATE: sl_wfx_gpio_mode_e = 4;
#[doc = "< Toggle the GPIO output value : switches between D0 and D1 or between OD0 and OD1"]
pub const sl_wfx_gpio_mode_e_SL_WFX_GPIO_MODE_TOGGLE: sl_wfx_gpio_mode_e = 5;
#[doc = "< Read the level at the GPIO pin"]
pub const sl_wfx_gpio_mode_e_SL_WFX_GPIO_MODE_READ: sl_wfx_gpio_mode_e = 6;
#[doc = " @brief Configure GPIO mode. Used in sl_wfx_control_gpio_req_body_t"]
pub type sl_wfx_gpio_mode_e = c_types::c_uint;
#[doc = " @brief Configure GPIO mode. Used in sl_wfx_control_gpio_req_body_t"]
pub use self::sl_wfx_gpio_mode_e as sl_wfx_gpio_mode_t;
#[doc = " @brief Send a request to read or write a GPIO identified by its label (that is defined in the PDS)\n\n After a write it also read back the value to check there is no drive conflict"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_control_gpio_req_body_s {
    #[doc = "<Identify the GPIO by its label (defined in the PDS)"]
    pub gpio_label: u8,
    #[doc = "<define how to set or read the GPIO (see enum sl_wfx_gpio_mode_t)"]
    pub gpio_mode: u8,
}
#[test]
fn bindgen_test_layout_sl_wfx_control_gpio_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_control_gpio_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_control_gpio_req_body_s>(),
        2usize,
        concat!("Size of: ", stringify!(sl_wfx_control_gpio_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_control_gpio_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_control_gpio_req_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gpio_label) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_control_gpio_req_body_s),
            "::",
            stringify!(gpio_label)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gpio_mode) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_control_gpio_req_body_s),
            "::",
            stringify!(gpio_mode)
        )
    );
}
#[doc = " @brief Send a request to read or write a GPIO identified by its label (that is defined in the PDS)\n\n After a write it also read back the value to check there is no drive conflict"]
pub type sl_wfx_control_gpio_req_body_t = sl_wfx_control_gpio_req_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_control_gpio_req_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_control_gpio_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_control_gpio_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_control_gpio_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_control_gpio_req_s>(),
        6usize,
        concat!("Size of: ", stringify!(sl_wfx_control_gpio_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_control_gpio_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_control_gpio_req_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_control_gpio_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_control_gpio_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_control_gpio_req_t = sl_wfx_control_gpio_req_s;
#[doc = "< Undefined GPIO_ID"]
pub const sl_wfx_gpio_error_e_SL_WFX_GPIO_ERROR_0: sl_wfx_gpio_error_e = 0;
#[doc = "< GPIO_ID not configured in GPIO mode (gpio_enabled =0)"]
pub const sl_wfx_gpio_error_e_SL_WFX_GPIO_ERROR_1: sl_wfx_gpio_error_e = 1;
#[doc = "< Toggle not possible while in tristate"]
pub const sl_wfx_gpio_error_e_SL_WFX_GPIO_ERROR_2: sl_wfx_gpio_error_e = 2;
#[doc = " @brief detailed error cause returned by CONTROL_GPIO confirmation message sl_wfx_control_gpio_cnf_body_t"]
pub type sl_wfx_gpio_error_e = c_types::c_uint;
#[doc = " @brief detailed error cause returned by CONTROL_GPIO confirmation message sl_wfx_control_gpio_cnf_body_t"]
pub use self::sl_wfx_gpio_error_e as sl_wfx_gpio_error_t;
#[doc = " @brief Confirmation from request to read and write a GPIO"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_control_gpio_cnf_body_s {
    #[doc = "<enum sl_wfx_status_t : a value of zero indicates the request is completed successfully."]
    pub status: u32,
    #[doc = "<the error detail (see enum sl_wfx_gpio_error_t) when ::sl_wfx_control_gpio_cnf_body_t::status reports an error else the gpio read value."]
    pub value: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_control_gpio_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_control_gpio_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_control_gpio_cnf_body_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_control_gpio_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_control_gpio_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_control_gpio_cnf_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_control_gpio_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_control_gpio_cnf_body_s),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " @brief Confirmation from request to read and write a GPIO"]
pub type sl_wfx_control_gpio_cnf_body_t = sl_wfx_control_gpio_cnf_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_control_gpio_cnf_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_control_gpio_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_control_gpio_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_control_gpio_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_control_gpio_cnf_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_control_gpio_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_control_gpio_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_control_gpio_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_control_gpio_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_control_gpio_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_control_gpio_cnf_t = sl_wfx_control_gpio_cnf_s;
#[doc = " @brief General Message header structure\n"]
pub type sl_wfx_shut_down_req_t = sl_wfx_header_t;
#[doc = "<Byte stream type, currently not used"]
pub const sl_wfx_generic_indication_type_e_SL_WFX_GENERIC_INDICATION_TYPE_RAW:
    sl_wfx_generic_indication_type_e = 0;
#[doc = "<NULL terminating String"]
pub const sl_wfx_generic_indication_type_e_SL_WFX_GENERIC_INDICATION_TYPE_STRING:
    sl_wfx_generic_indication_type_e = 1;
#[doc = "<Rx statistics structure"]
pub const sl_wfx_generic_indication_type_e_SL_WFX_GENERIC_INDICATION_TYPE_RX_STATS:
    sl_wfx_generic_indication_type_e = 2;
#[doc = "<Tx power loop info structure"]
pub const sl_wfx_generic_indication_type_e_SL_WFX_GENERIC_INDICATION_TYPE_TX_PWR_LOOP_INFO:
    sl_wfx_generic_indication_type_e = 3;
#[doc = " @brief specifies the type of data reported by the indication message sl_wfx_generic_ind_body_t\n"]
pub type sl_wfx_generic_indication_type_e = c_types::c_uint;
#[doc = " @brief specifies the type of data reported by the indication message sl_wfx_generic_ind_body_t\n"]
pub use self::sl_wfx_generic_indication_type_e as sl_wfx_generic_indication_type_t;
#[doc = " @brief RX stats from the GENERIC indication message sl_wfx_generic_ind_body_t"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_rx_stats_s {
    #[doc = "<Total number of frame received"]
    pub nb_rx_frame: u32,
    #[doc = "<Number of frame received with bad CRC"]
    pub nb_crc_frame: u32,
    #[doc = "<PER on the total number of frame"]
    pub per_total: u32,
    #[doc = "<Throughput calculated on correct frames received"]
    pub throughput: u32,
    #[doc = "<Number of frame received by rate"]
    pub nb_rx_by_rate: [u32; 22usize],
    #[doc = "<PER*10000 by frame rate"]
    pub per: [u16; 22usize],
    #[doc = "<SNR in Db*100 by frame rate"]
    pub snr: [i16; 22usize],
    #[doc = "<RSSI in Dbm*100 by frame rate"]
    pub rssi: [i16; 22usize],
    #[doc = "<CFO in k_hz by frame rate"]
    pub cfo: [i16; 22usize],
    #[doc = "<This message transmission date in firmware timebase (microsecond)"]
    pub date: u32,
    #[doc = "<Frequency of the low power clock in Hz"]
    pub pwr_clk_freq: u32,
    #[doc = "<Indicate if the low power clock is external"]
    pub is_ext_pwr_clk: u8,
    #[doc = "<Current die temperature in Celsius"]
    pub current_temp: i8,
}
#[test]
fn bindgen_test_layout_sl_wfx_rx_stats_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_rx_stats_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_rx_stats_s>(),
        290usize,
        concat!("Size of: ", stringify!(sl_wfx_rx_stats_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_rx_stats_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_rx_stats_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nb_rx_frame) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(nb_rx_frame)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nb_crc_frame) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(nb_crc_frame)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).per_total) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(per_total)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).throughput) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(throughput)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nb_rx_by_rate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(nb_rx_by_rate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).per) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(per)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).snr) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(snr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rssi) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(rssi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cfo) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(cfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).date) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(date)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pwr_clk_freq) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(pwr_clk_freq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_ext_pwr_clk) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(is_ext_pwr_clk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current_temp) as usize - ptr as usize },
        289usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(current_temp)
        )
    );
}
#[doc = " @brief RX stats from the GENERIC indication message sl_wfx_generic_ind_body_t"]
pub type sl_wfx_rx_stats_t = sl_wfx_rx_stats_s;
#[doc = " @brief TX power loop info from the GENERIC indication message sl_wfx_generic_ind_body_t"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_tx_pwr_loop_info_s {
    #[doc = "<Used Tx digital gain"]
    pub dig_gain: u16,
    #[doc = "<Used Tx PA gain"]
    pub ppa_gain: u16,
    #[doc = "<Power target in qdBm"]
    pub target_pout: i16,
    #[doc = "<FEM output power in qdBm"]
    pub pestimation: i16,
    #[doc = "<Measured Vpdet in mV"]
    pub vpdet: u16,
    #[doc = "<Vpdet measurement index"]
    pub meas_index: u8,
    #[doc = "<Reserved"]
    pub reserved: u8,
}
#[test]
fn bindgen_test_layout_sl_wfx_tx_pwr_loop_info_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_tx_pwr_loop_info_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_tx_pwr_loop_info_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_tx_pwr_loop_info_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_tx_pwr_loop_info_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_tx_pwr_loop_info_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dig_gain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_tx_pwr_loop_info_s),
            "::",
            stringify!(dig_gain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ppa_gain) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_tx_pwr_loop_info_s),
            "::",
            stringify!(ppa_gain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).target_pout) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_tx_pwr_loop_info_s),
            "::",
            stringify!(target_pout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pestimation) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_tx_pwr_loop_info_s),
            "::",
            stringify!(pestimation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vpdet) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_tx_pwr_loop_info_s),
            "::",
            stringify!(vpdet)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).meas_index) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_tx_pwr_loop_info_s),
            "::",
            stringify!(meas_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_tx_pwr_loop_info_s),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief TX power loop info from the GENERIC indication message sl_wfx_generic_ind_body_t"]
pub type sl_wfx_tx_pwr_loop_info_t = sl_wfx_tx_pwr_loop_info_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sl_wfx_indication_data_u {
    pub rx_stats: sl_wfx_rx_stats_t,
    pub tx_pwr_loop_info: sl_wfx_tx_pwr_loop_info_t,
    pub raw_data: [u8; 376usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_indication_data_u() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_indication_data_u> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_indication_data_u>(),
        376usize,
        concat!("Size of: ", stringify!(sl_wfx_indication_data_u))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_indication_data_u>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_indication_data_u))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_stats) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_indication_data_u),
            "::",
            stringify!(rx_stats)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_pwr_loop_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_indication_data_u),
            "::",
            stringify!(tx_pwr_loop_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_indication_data_u),
            "::",
            stringify!(raw_data)
        )
    );
}
pub type sl_wfx_indication_data_t = sl_wfx_indication_data_u;
#[doc = " @brief the Generic indication message.\n\n It reports different type of information that can be printed by the driver."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_generic_ind_body_s {
    #[doc = "<Identify the indication data (see enum type sl_wfx_generic_indication_type_t)"]
    pub indication_type: u32,
    #[doc = "<Indication data."]
    pub indication_data: sl_wfx_indication_data_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_generic_ind_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_generic_ind_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_generic_ind_body_s>(),
        380usize,
        concat!("Size of: ", stringify!(sl_wfx_generic_ind_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_generic_ind_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_generic_ind_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).indication_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_generic_ind_body_s),
            "::",
            stringify!(indication_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).indication_data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_generic_ind_body_s),
            "::",
            stringify!(indication_data)
        )
    );
}
#[doc = " @brief the Generic indication message.\n\n It reports different type of information that can be printed by the driver."]
pub type sl_wfx_generic_ind_body_t = sl_wfx_generic_ind_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_generic_ind_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_generic_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_generic_ind_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_generic_ind_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_generic_ind_s>(),
        384usize,
        concat!("Size of: ", stringify!(sl_wfx_generic_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_generic_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_generic_ind_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_generic_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_generic_ind_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_generic_ind_t = sl_wfx_generic_ind_s;
#[doc = " @brief Exception indication message\n\n It reports unexpected errors. A reboot is needed after this message."]
#[repr(C, packed)]
pub struct sl_wfx_exception_ind_body_s {
    #[doc = "<Reason of the exception"]
    pub reason: u32,
    #[doc = "<Raw data array"]
    pub data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_exception_ind_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_exception_ind_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_exception_ind_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_exception_ind_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_exception_ind_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_exception_ind_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reason) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_exception_ind_body_s),
            "::",
            stringify!(reason)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_exception_ind_body_s),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " @brief Exception indication message\n\n It reports unexpected errors. A reboot is needed after this message."]
pub type sl_wfx_exception_ind_body_t = sl_wfx_exception_ind_body_s;
#[repr(C, packed)]
pub struct sl_wfx_exception_ind_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_exception_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_exception_ind_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_exception_ind_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_exception_ind_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_exception_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_exception_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_exception_ind_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_exception_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_exception_ind_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_exception_ind_t = sl_wfx_exception_ind_s;
#[doc = " @brief Error indication message.\n\n It reports user configuration errors.\n A reboot is needed after this message."]
#[repr(C, packed)]
pub struct sl_wfx_error_ind_body_s {
    #[doc = "<error type, see enum sl_wfx_error_t"]
    pub type_: u32,
    #[doc = "<Generic data buffer - contents depends on the error type."]
    pub data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_error_ind_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_error_ind_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_error_ind_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_error_ind_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_error_ind_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_error_ind_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_error_ind_body_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_error_ind_body_s),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " @brief Error indication message.\n\n It reports user configuration errors.\n A reboot is needed after this message."]
pub type sl_wfx_error_ind_body_t = sl_wfx_error_ind_body_s;
#[repr(C, packed)]
pub struct sl_wfx_error_ind_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_error_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_error_ind_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_error_ind_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_error_ind_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_error_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_error_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_error_ind_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_error_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_error_ind_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_error_ind_t = sl_wfx_error_ind_s;
#[doc = "<Reserved"]
pub const sl_wfx_secure_link_state_e_SECURE_LINK_NA_MODE: sl_wfx_secure_link_state_e = 0;
#[doc = "<Untrusted mode - SecureLink not available"]
pub const sl_wfx_secure_link_state_e_SECURE_LINK_UNTRUSTED_MODE: sl_wfx_secure_link_state_e = 1;
#[doc = "<Trusted (Evaluation) mode"]
pub const sl_wfx_secure_link_state_e_SECURE_LINK_TRUSTED_MODE: sl_wfx_secure_link_state_e = 2;
#[doc = "<Trusted (Enforced) mode"]
pub const sl_wfx_secure_link_state_e_SECURE_LINK_TRUSTED_ACTIVE_ENFORCED:
    sl_wfx_secure_link_state_e = 3;
#[doc = " @brief *Secure Link' device state"]
pub type sl_wfx_secure_link_state_e = c_types::c_uint;
#[doc = " @brief *Secure Link' device state"]
pub use self::sl_wfx_secure_link_state_e as sl_wfx_secure_link_state_t;
#[doc = "<Key will be stored in OTP"]
pub const sl_wfx_securelink_mac_key_dest_e_SECURE_LINK_MAC_KEY_DEST_OTP:
    sl_wfx_securelink_mac_key_dest_e = 120;
#[doc = "<Key will be stored in RAM"]
pub const sl_wfx_securelink_mac_key_dest_e_SECURE_LINK_MAC_KEY_DEST_RAM:
    sl_wfx_securelink_mac_key_dest_e = 135;
#[doc = " @brief destination of the *Secure Link MAC key*, used by request message sl_wfx_set_securelink_mac_key_req_body_t"]
pub type sl_wfx_securelink_mac_key_dest_e = c_types::c_uint;
#[doc = " @brief destination of the *Secure Link MAC key*, used by request message sl_wfx_set_securelink_mac_key_req_body_t"]
pub use self::sl_wfx_securelink_mac_key_dest_e as sl_wfx_securelink_mac_key_dest_t;
#[doc = " @brief Set the Secure Link MAC key\n\n This API can be used for *Trusted Eval* devices in two contexts:\n - to set a temporary *SecureLink MAC key* in RAM.\n - to permanently burn the *SecureLink MAC key* in OTP memory. In that case, the OTP *SecureLink mode* will\n switch to *Trusted Enforced* mode"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_securemink_mac_key_req_body_s {
    #[doc = "<Key destination - OTP or RAM (see enum sl_wfx_securelink_mac_key_dest_t)"]
    pub otp_or_ram: u8,
    #[doc = "<Secure Link MAC Key value"]
    pub key_value: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_set_securemink_mac_key_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_securemink_mac_key_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_securemink_mac_key_req_body_s>(),
        33usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_securemink_mac_key_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_securemink_mac_key_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_securemink_mac_key_req_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).otp_or_ram) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_securemink_mac_key_req_body_s),
            "::",
            stringify!(otp_or_ram)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_value) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_securemink_mac_key_req_body_s),
            "::",
            stringify!(key_value)
        )
    );
}
#[doc = " @brief Set the Secure Link MAC key\n\n This API can be used for *Trusted Eval* devices in two contexts:\n - to set a temporary *SecureLink MAC key* in RAM.\n - to permanently burn the *SecureLink MAC key* in OTP memory. In that case, the OTP *SecureLink mode* will\n switch to *Trusted Enforced* mode"]
pub type sl_wfx_set_securelink_mac_key_req_body_t = sl_wfx_set_securemink_mac_key_req_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_securelink_mac_key_req_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_set_securelink_mac_key_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_securelink_mac_key_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_securelink_mac_key_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_securelink_mac_key_req_s>(),
        37usize,
        concat!("Size of: ", stringify!(sl_wfx_set_securelink_mac_key_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_securelink_mac_key_req_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_securelink_mac_key_req_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_securelink_mac_key_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_securelink_mac_key_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_securelink_mac_key_req_t = sl_wfx_set_securelink_mac_key_req_s;
#[doc = " @brief Confirmation for the Secure Link MAC key setting"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_securelink_mac_key_cnf_body_s {
    #[doc = "<Key upload status (see enum sl_wfx_status_t)"]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_securelink_mac_key_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_securelink_mac_key_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_securelink_mac_key_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_securelink_mac_key_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_securelink_mac_key_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_securelink_mac_key_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_securelink_mac_key_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation for the Secure Link MAC key setting"]
pub type sl_wfx_set_securelink_mac_key_cnf_body_t = sl_wfx_set_securelink_mac_key_cnf_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_securelink_mac_key_cnf_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_set_securelink_mac_key_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_securelink_mac_key_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_securelink_mac_key_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_securelink_mac_key_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_securelink_mac_key_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_securelink_mac_key_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_securelink_mac_key_cnf_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_securelink_mac_key_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_securelink_mac_key_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_securelink_mac_key_cnf_t = sl_wfx_set_securelink_mac_key_cnf_s;
#[doc = "< Session key is computed using curve25519 algorithm"]
pub const sl_wfx_secure_link_session_key_alg_e_SECURE_LINK_CURVE25519:
    sl_wfx_secure_link_session_key_alg_e = 1;
#[doc = "< Session key is computed using KDF algorithm (not available yet)"]
pub const sl_wfx_secure_link_session_key_alg_e_SECURE_LINK_KDF:
    sl_wfx_secure_link_session_key_alg_e = 2;
#[doc = " @brief Session Key computation algorithms\n"]
pub type sl_wfx_secure_link_session_key_alg_e = c_types::c_uint;
#[doc = " @brief Session Key computation algorithms\n"]
pub use self::sl_wfx_secure_link_session_key_alg_e as sl_wfx_secure_link_session_key_alg_t;
#[doc = " @brief Exchange Secure Link Public Keys\n\n This API is used by the Host to send its *curve25519* public key to Device, and get back Device public key in the confirmation message.\n Once keys are exchanged and authenticated (using their respective MAC), each peer computes the Secure Link *session key* that will be used\n to encrypt/decrypt future Host<->Device messages."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_securelink_exchange_pub_keys_req_body_s {
    #[doc = "<Choice of the cryptographic algorithm used in the session key computation (see enum sl_wfx_secure_link_session_key_alg_t)"]
    pub algorithm: u32,
    #[doc = "<Host Public Key"]
    pub host_pub_key: [u8; 32usize],
    #[doc = "<Host Public Key MAC"]
    pub host_pub_key_mac: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_securelink_exchange_pub_keys_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_securelink_exchange_pub_keys_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_securelink_exchange_pub_keys_req_body_s>(),
        100usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_securelink_exchange_pub_keys_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_req_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).algorithm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_req_body_s),
            "::",
            stringify!(algorithm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host_pub_key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_req_body_s),
            "::",
            stringify!(host_pub_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host_pub_key_mac) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_req_body_s),
            "::",
            stringify!(host_pub_key_mac)
        )
    );
}
#[doc = " @brief Exchange Secure Link Public Keys\n\n This API is used by the Host to send its *curve25519* public key to Device, and get back Device public key in the confirmation message.\n Once keys are exchanged and authenticated (using their respective MAC), each peer computes the Secure Link *session key* that will be used\n to encrypt/decrypt future Host<->Device messages."]
pub type sl_wfx_securelink_exchange_pub_keys_req_body_t =
    sl_wfx_securelink_exchange_pub_keys_req_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_securelink_exchange_pub_keys_req_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_securelink_exchange_pub_keys_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_securelink_exchange_pub_keys_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_securelink_exchange_pub_keys_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_securelink_exchange_pub_keys_req_s>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_req_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_securelink_exchange_pub_keys_req_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_req_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_securelink_exchange_pub_keys_req_t = sl_wfx_securelink_exchange_pub_keys_req_s;
#[doc = " @brief Confirmation for exchange of Secure Link Public Keys"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_securelink_exchange_pub_keys_cnf_body_s {
    #[doc = "<Request status (see enum sl_wfx_status_t)"]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_securelink_exchange_pub_keys_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_securelink_exchange_pub_keys_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_securelink_exchange_pub_keys_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_securelink_exchange_pub_keys_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation for exchange of Secure Link Public Keys"]
pub type sl_wfx_securelink_exchange_pub_keys_cnf_body_t =
    sl_wfx_securelink_exchange_pub_keys_cnf_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_securelink_exchange_pub_keys_cnf_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_securelink_exchange_pub_keys_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_securelink_exchange_pub_keys_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_securelink_exchange_pub_keys_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_securelink_exchange_pub_keys_cnf_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_cnf_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_securelink_exchange_pub_keys_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_cnf_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_securelink_exchange_pub_keys_cnf_t = sl_wfx_securelink_exchange_pub_keys_cnf_s;
#[doc = " @brief Indication for exchange of Secure Link Public Keys"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_securelink_exchange_pub_keys_ind_body_s {
    #[doc = "<Request status (see enum sl_wfx_status_t)"]
    pub status: u32,
    #[doc = "<Device Public Key"]
    pub ncp_pub_key: [u8; 32usize],
    #[doc = "<Device Public Key MAC"]
    pub ncp_pub_key_mac: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_securelink_exchange_pub_keys_ind_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_securelink_exchange_pub_keys_ind_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_securelink_exchange_pub_keys_ind_body_s>(),
        100usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_ind_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_securelink_exchange_pub_keys_ind_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_ind_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_ind_body_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ncp_pub_key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_ind_body_s),
            "::",
            stringify!(ncp_pub_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ncp_pub_key_mac) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_ind_body_s),
            "::",
            stringify!(ncp_pub_key_mac)
        )
    );
}
#[doc = " @brief Indication for exchange of Secure Link Public Keys"]
pub type sl_wfx_securelink_exchange_pub_keys_ind_body_t =
    sl_wfx_securelink_exchange_pub_keys_ind_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_securelink_exchange_pub_keys_ind_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_securelink_exchange_pub_keys_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_securelink_exchange_pub_keys_ind_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_securelink_exchange_pub_keys_ind_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_securelink_exchange_pub_keys_ind_s>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_ind_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_securelink_exchange_pub_keys_ind_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_ind_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_ind_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_securelink_exchange_pub_keys_ind_t = sl_wfx_securelink_exchange_pub_keys_ind_s;
#[doc = " @brief Configure Secure Link Layer\n\n This API can be used to:\n - Set/update the Secure Link *encryption bitmap*\n - Disable Session Key Protection\n\n About the Session Key protection:\n SecureLink underlying encryption algorithm is AES CCM. This algorithm is using an internal Nonce counter incremented each time a message is\n encrypted/decrypted. This counter is not supposed to go beyond a given limit to guarantee AES CCM security properties.\n This is why Host Driver is responsible for renegotiating the session key once the message counter is approaching the limit.\n Disabling the Session Key protection will disable the check performed by the firmware that the Nonce counter is crossing the limit,\n allowing Host Driver to use the same session key during the same power cycle, even during a very long time.\n This behavior is not recommended.\n\n To disable the protection, a given magic word (SL_WFX_SESSION_KEY_PROTECTION_DISABLE_MAGIC) must be provided as _DisableSessionKeyProtection_ parameter value. Any other value will let the protection set.\n\n @note When SecureLink is activated, _SL Configure_ API must be called right after the key exchange. Issuing another command instead will result in an error.\n @note It is not recommended to call this API a second time during the same power cycle."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_securelink_configure_req_body_s {
    #[doc = "<Encryption bitmap"]
    pub encr_bmp: [u8; 32usize],
    #[doc = "<Force the firmware to authorize the use of the same session key during a complete power cycle, even very long. NOT RECOMMENDED"]
    pub disable_session_key_protection: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_securelink_configure_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_securelink_configure_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_securelink_configure_req_body_s>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_securelink_configure_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_securelink_configure_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_securelink_configure_req_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encr_bmp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_configure_req_body_s),
            "::",
            stringify!(encr_bmp)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).disable_session_key_protection) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_configure_req_body_s),
            "::",
            stringify!(disable_session_key_protection)
        )
    );
}
#[doc = " @brief Configure Secure Link Layer\n\n This API can be used to:\n - Set/update the Secure Link *encryption bitmap*\n - Disable Session Key Protection\n\n About the Session Key protection:\n SecureLink underlying encryption algorithm is AES CCM. This algorithm is using an internal Nonce counter incremented each time a message is\n encrypted/decrypted. This counter is not supposed to go beyond a given limit to guarantee AES CCM security properties.\n This is why Host Driver is responsible for renegotiating the session key once the message counter is approaching the limit.\n Disabling the Session Key protection will disable the check performed by the firmware that the Nonce counter is crossing the limit,\n allowing Host Driver to use the same session key during the same power cycle, even during a very long time.\n This behavior is not recommended.\n\n To disable the protection, a given magic word (SL_WFX_SESSION_KEY_PROTECTION_DISABLE_MAGIC) must be provided as _DisableSessionKeyProtection_ parameter value. Any other value will let the protection set.\n\n @note When SecureLink is activated, _SL Configure_ API must be called right after the key exchange. Issuing another command instead will result in an error.\n @note It is not recommended to call this API a second time during the same power cycle."]
pub type sl_wfx_securelink_configure_req_body_t = sl_wfx_securelink_configure_req_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_securelink_configure_req_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_securelink_configure_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_securelink_configure_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_securelink_configure_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_securelink_configure_req_s>(),
        40usize,
        concat!("Size of: ", stringify!(sl_wfx_securelink_configure_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_securelink_configure_req_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_securelink_configure_req_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_configure_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_configure_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_securelink_configure_req_t = sl_wfx_securelink_configure_req_s;
#[doc = " @brief Confirmation of Secure Link Layer configuration sl_wfx_securelink_configure_req_body_t\n\n @return HI_STATUS_SUCCESS\n\n @note The host driver should wait for this confirmation to update its local bitmap with the returned value"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_securelink_configure_cnf_body_s {
    #[doc = "<Request status (see enum sl_wfx_status_t)"]
    pub status: u32,
    #[doc = "<Encryption bitmap"]
    pub encr_bmp: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_securelink_configure_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_securelink_configure_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_securelink_configure_cnf_body_s>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_securelink_configure_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_securelink_configure_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_securelink_configure_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_configure_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encr_bmp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_configure_cnf_body_s),
            "::",
            stringify!(encr_bmp)
        )
    );
}
#[doc = " @brief Confirmation of Secure Link Layer configuration sl_wfx_securelink_configure_req_body_t\n\n @return HI_STATUS_SUCCESS\n\n @note The host driver should wait for this confirmation to update its local bitmap with the returned value"]
pub type sl_wfx_securelink_configure_cnf_body_t = sl_wfx_securelink_configure_cnf_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_securelink_configure_cnf_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_securelink_configure_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_securelink_configure_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_securelink_configure_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_securelink_configure_cnf_s>(),
        40usize,
        concat!("Size of: ", stringify!(sl_wfx_securelink_configure_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_securelink_configure_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_securelink_configure_cnf_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_configure_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_configure_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_securelink_configure_cnf_t = sl_wfx_securelink_configure_cnf_s;
#[doc = "@brief Prevent Rollback request\n\n *Prevent Rollback* asks WLAN firmware to burn a new *Firmware Rollback* value in a dedicated OTP section.\n\n The new value is encoded in the firmware itself. After it is burned, this value will prevent from starting\n  all firmwares whose internal rollback value is lower than the OTP value.\n\n *Magic Word* is used to prevent mistakenly sent requests from burning the OTP.\n"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_prevent_rollback_req_body_s {
    #[doc = "<Magic Word - should be 0x5C8912F3"]
    pub magic_word: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_prevent_rollback_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_prevent_rollback_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_prevent_rollback_req_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_prevent_rollback_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_prevent_rollback_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_prevent_rollback_req_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).magic_word) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_prevent_rollback_req_body_s),
            "::",
            stringify!(magic_word)
        )
    );
}
#[doc = "@brief Prevent Rollback request\n\n *Prevent Rollback* asks WLAN firmware to burn a new *Firmware Rollback* value in a dedicated OTP section.\n\n The new value is encoded in the firmware itself. After it is burned, this value will prevent from starting\n  all firmwares whose internal rollback value is lower than the OTP value.\n\n *Magic Word* is used to prevent mistakenly sent requests from burning the OTP.\n"]
pub type sl_wfx_prevent_rollback_req_body_t = sl_wfx_prevent_rollback_req_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_prevent_rollback_req_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_prevent_rollback_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_prevent_rollback_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_prevent_rollback_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_prevent_rollback_req_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_prevent_rollback_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_prevent_rollback_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_prevent_rollback_req_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_prevent_rollback_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_prevent_rollback_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_prevent_rollback_req_t = sl_wfx_prevent_rollback_req_s;
#[doc = " @brief Confirmation of the *Prevent Rollback* request\n\n The request might have failed for the following reasons:\n - Wrong *magic word* value\n"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_prevent_rollback_cnf_body_s {
    #[doc = "<Confirmation status, see enum sl_wfx_status_t"]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_prevent_rollback_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_prevent_rollback_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_prevent_rollback_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_prevent_rollback_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_prevent_rollback_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_prevent_rollback_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_prevent_rollback_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation of the *Prevent Rollback* request\n\n The request might have failed for the following reasons:\n - Wrong *magic word* value\n"]
pub type sl_wfx_prevent_rollback_cnf_body_t = sl_wfx_prevent_rollback_cnf_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_prevent_rollback_cnf_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_prevent_rollback_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_prevent_rollback_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_prevent_rollback_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_prevent_rollback_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_prevent_rollback_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_prevent_rollback_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_prevent_rollback_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_prevent_rollback_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_prevent_rollback_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_prevent_rollback_cnf_t = sl_wfx_prevent_rollback_cnf_s;
#[doc = "< PTA 1-wire interface with WLAN master on PTA_TX_CONF pin (GRANT signal),"]
pub const sl_wfx_pta_mode_e_SL_WFX_PTA_1W_WLAN_MASTER: sl_wfx_pta_mode_e = 0;
#[doc = "< PTA 1-wire interface with COEX master on PTA_RF_ACT pin (REQUEST signal),"]
pub const sl_wfx_pta_mode_e_SL_WFX_PTA_1W_COEX_MASTER: sl_wfx_pta_mode_e = 1;
#[doc = "< PTA 2-wire interface on PTA_RF_ACT and PTA_TX_CONF pins (respectively REQUEST and GRANT signals),"]
pub const sl_wfx_pta_mode_e_SL_WFX_PTA_2W: sl_wfx_pta_mode_e = 2;
#[doc = "< PTA 3-wire interface on same pins as SL_WFX_PTA_2W, plus PTA_STATUS pin (PRIORITY signal)"]
pub const sl_wfx_pta_mode_e_SL_WFX_PTA_3W: sl_wfx_pta_mode_e = 3;
#[doc = "< PTA 4-wire interface on same pins as SL_WFX_PTA_3W, plus PTA_FREQ pin (FREQ signal)."]
pub const sl_wfx_pta_mode_e_SL_WFX_PTA_4W: sl_wfx_pta_mode_e = 4;
#[doc = " @brief PTA modes."]
pub type sl_wfx_pta_mode_e = c_types::c_uint;
#[doc = " @brief PTA modes."]
pub use self::sl_wfx_pta_mode_e as sl_wfx_pta_mode_t;
#[doc = "< Signal level is low"]
pub const sl_wfx_signal_level_e_SL_WFX_SIGNAL_LOW: sl_wfx_signal_level_e = 0;
#[doc = "< Signal level is high"]
pub const sl_wfx_signal_level_e_SL_WFX_SIGNAL_HIGH: sl_wfx_signal_level_e = 1;
#[doc = " @brief Signal levels."]
pub type sl_wfx_signal_level_e = c_types::c_uint;
#[doc = " @brief Signal levels."]
pub use self::sl_wfx_signal_level_e as sl_wfx_signal_level_t;
#[doc = "< IEEE 802.15.4 standards ZigBee SDK, Thread SDK, and so on."]
pub const sl_wfx_coex_type_e_SL_WFX_COEX_TYPE_GENERIC: sl_wfx_coex_type_e = 0;
#[doc = "< Bluetooth Low-Energy Stack"]
pub const sl_wfx_coex_type_e_SL_WFX_COEX_TYPE_BLE: sl_wfx_coex_type_e = 1;
#[doc = " @brief Coexistence types supported by PTA."]
pub type sl_wfx_coex_type_e = c_types::c_uint;
#[doc = " @brief Coexistence types supported by PTA."]
pub use self::sl_wfx_coex_type_e as sl_wfx_coex_type_t;
#[doc = "< WLAN has the RF, Coex is not allowed to transmit"]
pub const sl_wfx_grant_state_e_SL_WFX_NO_GRANT: sl_wfx_grant_state_e = 0;
#[doc = "< Coex is granted"]
pub const sl_wfx_grant_state_e_SL_WFX_GRANT: sl_wfx_grant_state_e = 1;
#[doc = " @brief Grant states."]
pub type sl_wfx_grant_state_e = c_types::c_uint;
#[doc = " @brief Grant states."]
pub use self::sl_wfx_grant_state_e as sl_wfx_grant_state_t;
#[doc = " @brief Request sent by the host to set the PTA mode, the active levels on signals, the Coex type,\n to define the timings, quotas, combined mode and default grant state.\n\n Depending on specified PTA mode, every setting is not necessarily used and can then be set to '0'.<br/>\n The following table indicates the PTA mode for which the setting is significant.<br/>\n Combined mode is activated during concurrent RX (WLAN and Coex) requests and if SimultaneousRxAccesses is set to '1'.\n\n | Settings                 | 1-wire WLAN Master | 1-wire Coex Master | 2-wire | 3-wire | 3-wire (combined) | 4-wire | 4-wire (combined) |\n |--------------------------|:------------------:|:------------------:|:------:|:------:|:-----------------:|:------:|:-----------------:|\n | PrioritySamplingTime     |                    |                    |        |    x   |          x        |    x   |          x        |\n | TxRxSamplingTime         |                    |                    |        |        |          x        |        |          x        |\n | FreqSamplingTime         |                    |                    |        |        |                   |    x   |          x        |\n | GrantValidTime           |                    |                    |        |    x   |          x        |    x   |          x        |\n | FemControlTime           |                    |                    |        |    x   |          x        |    x   |          x        |\n | FirstSlotTime            |                    |                    |        |        |          x        |        |          x        |\n | PeriodicTxRxSamplingTime |                    |                    |        |        |          x        |        |          x        |\n | CoexQuota                |         x          |                    |    x   |        |                   |        |                   |\n | WlanQuota                |         x          |                    |    x   |        |                   |        |                   |\n\n <br/>\n @image html 3w-timings-sequence.svg \"Sequence diagram with 3-wire PTA mode\"\n <br/>\n @image html 4w-timings-sequence.svg \"Sequence diagram with 4-wire PTA mode\"\n\n @note Request will fail if PTA is started.\n\n @warning\n The following assertions must be respected:\n - priority_sampling_time < tx_rx_sampling_time < grant_valid_time <= first_slot_time\n - freq_sampling_time < grant_valid_time < fem_control_time"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_settings_req_body_s {
    #[doc = "< The PTA mode, see enum ::sl_wfx_pta_mode_t"]
    pub pta_mode: u8,
    #[doc = "< Active level on REQUEST signal (PTA_RF_ACT pin), provided by Coex to request the RF, see enum ::sl_wfx_signal_level_t"]
    pub request_signal_active_level: u8,
    #[doc = "< Active level on PRIORITY signal (PTA_STATUS pin), provided by Coex to set the priority of the request, see enum ::sl_wfx_signal_level_t"]
    pub priority_signal_active_level: u8,
    #[doc = "< Active level on FREQ signal (PTA_FREQ pin), provided by Coex in 4-wire mode when Coex and WLAN share the same band, see enum ::sl_wfx_signal_level_t"]
    pub freq_signal_active_level: u8,
    #[doc = "< Active level on GRANT signal (PTA_TX_CONF pin), generated by PTA to grant the RF to Coex, see enum ::sl_wfx_signal_level_t"]
    pub grant_signal_active_level: u8,
    #[doc = "< The Coex type, see enum ::sl_wfx_coex_type_t"]
    pub coex_type: u8,
    #[doc = "< The state of the GRANT signal before arbitration at grant_valid_time, see enum ::sl_wfx_grant_state_t"]
    pub default_grant_state: u8,
    #[doc = "< Boolean to allow both Coex and WLAN to receive concurrently, also named combined mode"]
    pub simultaneous_rx_access: u8,
    #[doc = "< The time (in microseconds) from the Coex request to the sampling of the priority on PRIORITY signal (1 to 31)"]
    pub priority_sampling_time: u8,
    #[doc = "< The time (in microseconds) from the Coex request to the sampling of the directionality on PRIORITY signal (priority_sampling_time to 63)"]
    pub tx_rx_sampling_time: u8,
    #[doc = "< The time (in microseconds) from the Coex request to the sampling of freq-match information on FREQ signal (1 to 127)"]
    pub freq_sampling_time: u8,
    #[doc = "< The time (in microseconds) from Coex request to the GRANT signal assertion (MAX(tx_rx_sampling_time, freq_sampling_time) to 255)"]
    pub grant_valid_time: u8,
    #[doc = "< The time (in microseconds) from Coex request to the control of FEM (grant_valid_time to 255)"]
    pub fem_control_time: u8,
    #[doc = "< The time (in microseconds) from the Coex request to the beginning of reception or transmission (grant_valid_time to 255)"]
    pub first_slot_time: u8,
    #[doc = "< The period (in microseconds) from first_slot_time of following samplings of the directionality on PRIORITY signal (1 to 1023)"]
    pub periodic_tx_rx_sampling_time: u16,
    #[doc = "< The duration (in microseconds) for which RF is granted to Coex before it is moved to WLAN"]
    pub coex_quota: u16,
    #[doc = "< The duration (in microseconds) for which RF is granted to WLAN before it is moved to Coex"]
    pub wlan_quota: u16,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_settings_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_pta_settings_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_settings_req_body_s>(),
        20usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_settings_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_settings_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_settings_req_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pta_mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(pta_mode)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).request_signal_active_level) as usize - ptr as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(request_signal_active_level)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).priority_signal_active_level) as usize - ptr as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(priority_signal_active_level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).freq_signal_active_level) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(freq_signal_active_level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).grant_signal_active_level) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(grant_signal_active_level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).coex_type) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(coex_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).default_grant_state) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(default_grant_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).simultaneous_rx_access) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(simultaneous_rx_access)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).priority_sampling_time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(priority_sampling_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_rx_sampling_time) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(tx_rx_sampling_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).freq_sampling_time) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(freq_sampling_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).grant_valid_time) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(grant_valid_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fem_control_time) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(fem_control_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).first_slot_time) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(first_slot_time)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).periodic_tx_rx_sampling_time) as usize - ptr as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(periodic_tx_rx_sampling_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).coex_quota) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(coex_quota)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wlan_quota) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(wlan_quota)
        )
    );
}
#[doc = " @brief Request sent by the host to set the PTA mode, the active levels on signals, the Coex type,\n to define the timings, quotas, combined mode and default grant state.\n\n Depending on specified PTA mode, every setting is not necessarily used and can then be set to '0'.<br/>\n The following table indicates the PTA mode for which the setting is significant.<br/>\n Combined mode is activated during concurrent RX (WLAN and Coex) requests and if SimultaneousRxAccesses is set to '1'.\n\n | Settings                 | 1-wire WLAN Master | 1-wire Coex Master | 2-wire | 3-wire | 3-wire (combined) | 4-wire | 4-wire (combined) |\n |--------------------------|:------------------:|:------------------:|:------:|:------:|:-----------------:|:------:|:-----------------:|\n | PrioritySamplingTime     |                    |                    |        |    x   |          x        |    x   |          x        |\n | TxRxSamplingTime         |                    |                    |        |        |          x        |        |          x        |\n | FreqSamplingTime         |                    |                    |        |        |                   |    x   |          x        |\n | GrantValidTime           |                    |                    |        |    x   |          x        |    x   |          x        |\n | FemControlTime           |                    |                    |        |    x   |          x        |    x   |          x        |\n | FirstSlotTime            |                    |                    |        |        |          x        |        |          x        |\n | PeriodicTxRxSamplingTime |                    |                    |        |        |          x        |        |          x        |\n | CoexQuota                |         x          |                    |    x   |        |                   |        |                   |\n | WlanQuota                |         x          |                    |    x   |        |                   |        |                   |\n\n <br/>\n @image html 3w-timings-sequence.svg \"Sequence diagram with 3-wire PTA mode\"\n <br/>\n @image html 4w-timings-sequence.svg \"Sequence diagram with 4-wire PTA mode\"\n\n @note Request will fail if PTA is started.\n\n @warning\n The following assertions must be respected:\n - priority_sampling_time < tx_rx_sampling_time < grant_valid_time <= first_slot_time\n - freq_sampling_time < grant_valid_time < fem_control_time"]
pub type sl_wfx_pta_settings_req_body_t = sl_wfx_pta_settings_req_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_settings_req_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_pta_settings_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_settings_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_pta_settings_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_settings_req_s>(),
        24usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_settings_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_settings_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_settings_req_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_pta_settings_req_t = sl_wfx_pta_settings_req_s;
#[doc = " @brief Confirmation sent by WLAN firmware after a ::SL_WFX_PTA_SETTINGS_REQ_ID request."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_settings_cnf_body_s {
    #[doc = "< Confirmation status, see enum ::sl_wfx_status_t"]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_settings_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_pta_settings_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_settings_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_settings_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_settings_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_settings_cnf_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation sent by WLAN firmware after a ::SL_WFX_PTA_SETTINGS_REQ_ID request."]
pub type sl_wfx_pta_settings_cnf_body_t = sl_wfx_pta_settings_cnf_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_settings_cnf_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_pta_settings_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_settings_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_pta_settings_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_settings_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_settings_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_settings_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_settings_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_pta_settings_cnf_t = sl_wfx_pta_settings_cnf_s;
#[doc = "< Maximizes priority to COEX"]
pub const sl_wfx_pta_priority_e_SL_WFX_PTA_PRIORITY_COEX_MAXIMIZED: sl_wfx_pta_priority_e = 1378;
#[doc = "< High priority to COEX, targets low-latency to COEX"]
pub const sl_wfx_pta_priority_e_SL_WFX_PTA_PRIORITY_COEX_HIGH: sl_wfx_pta_priority_e = 1122;
#[doc = "< Balanced PTA arbitration"]
pub const sl_wfx_pta_priority_e_SL_WFX_PTA_PRIORITY_BALANCED: sl_wfx_pta_priority_e = 5217;
#[doc = "< High priority to WLAN, protects WLAN transmissions"]
pub const sl_wfx_pta_priority_e_SL_WFX_PTA_PRIORITY_WLAN_HIGH: sl_wfx_pta_priority_e = 6225;
#[doc = "< Maximizes priority to WLAN"]
pub const sl_wfx_pta_priority_e_SL_WFX_PTA_PRIORITY_WLAN_MAXIMIZED: sl_wfx_pta_priority_e = 6737;
#[doc = " @brief Priority levels used by PTA for concurrent (Coex and WLAN) request arbitration."]
pub type sl_wfx_pta_priority_e = c_types::c_uint;
#[doc = " @brief Priority levels used by PTA for concurrent (Coex and WLAN) request arbitration."]
pub use self::sl_wfx_pta_priority_e as sl_wfx_pta_priority_t;
#[doc = " @brief Request sent by the host to define the level of priority used to arbitrate concurrent Coex and WLAN requests.\n\n Priority can be one value from enum ::sl_wfx_pta_priority_t but can also be an integer value whom definition is the following bitfield:\n\n @code{.c}\n struct sl_wfx_pta_priority_s\n {\n   uint32_t coex_prio_low:3;    // Priority given to Coex for low-priority requests\n   uint32_t reserved_1:1;       // Reserved for future use\n   uint32_t coex_prio_high:3;   // Priority given to Coex for high-priority requests\n   uint32_t reserved_2:1;       // Reserved for future use\n   uint32_t grant_coex:1;       // Allows Coex to override WLAN\n   uint32_t grant_wlan:1;       // Allows WLAN to override Coex whenever WLAN is not idle\n   uint32_t protect_coex:1;     // WLAN grant is delayed until Coex has finished its present granted transaction\n   uint32_t protect_wlan_tx:1;  // Prevents Coex from being granted when WLAN is transmitting (the protection is also extended to the response)\n   uint32_t protect_wlan_rx:1;  // Prevents Coex from being granted when WLAN is receiving or waiting for a response to an already transmitted frame\n   uint32_t reserved_3:19;      // Reserved for future use\n }\n @endcode\n\n @note Request will fail if PTA is started."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_priority_req_body_s {
    #[doc = "< The priority level, see enum ::sl_wfx_pta_priority_t"]
    pub priority: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_priority_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_pta_priority_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_priority_req_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_priority_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_priority_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_priority_req_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_priority_req_body_s),
            "::",
            stringify!(priority)
        )
    );
}
#[doc = " @brief Request sent by the host to define the level of priority used to arbitrate concurrent Coex and WLAN requests.\n\n Priority can be one value from enum ::sl_wfx_pta_priority_t but can also be an integer value whom definition is the following bitfield:\n\n @code{.c}\n struct sl_wfx_pta_priority_s\n {\n   uint32_t coex_prio_low:3;    // Priority given to Coex for low-priority requests\n   uint32_t reserved_1:1;       // Reserved for future use\n   uint32_t coex_prio_high:3;   // Priority given to Coex for high-priority requests\n   uint32_t reserved_2:1;       // Reserved for future use\n   uint32_t grant_coex:1;       // Allows Coex to override WLAN\n   uint32_t grant_wlan:1;       // Allows WLAN to override Coex whenever WLAN is not idle\n   uint32_t protect_coex:1;     // WLAN grant is delayed until Coex has finished its present granted transaction\n   uint32_t protect_wlan_tx:1;  // Prevents Coex from being granted when WLAN is transmitting (the protection is also extended to the response)\n   uint32_t protect_wlan_rx:1;  // Prevents Coex from being granted when WLAN is receiving or waiting for a response to an already transmitted frame\n   uint32_t reserved_3:19;      // Reserved for future use\n }\n @endcode\n\n @note Request will fail if PTA is started."]
pub type sl_wfx_pta_priority_req_body_t = sl_wfx_pta_priority_req_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_priority_req_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_pta_priority_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_priority_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_pta_priority_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_priority_req_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_priority_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_priority_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_priority_req_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_priority_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_priority_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_pta_priority_req_t = sl_wfx_pta_priority_req_s;
#[doc = " @brief Confirmation sent by WLAN firmware after a ::SL_WFX_PTA_PRIORITY_REQ_ID request."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_priority_cnf_body_s {
    #[doc = "< Confirmation status, see enum ::sl_wfx_status_t"]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_priority_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_pta_priority_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_priority_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_priority_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_priority_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_priority_cnf_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_priority_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation sent by WLAN firmware after a ::SL_WFX_PTA_PRIORITY_REQ_ID request."]
pub type sl_wfx_pta_priority_cnf_body_t = sl_wfx_pta_priority_cnf_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_priority_cnf_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_pta_priority_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_priority_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_pta_priority_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_priority_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_priority_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_priority_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_priority_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_priority_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_priority_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_pta_priority_cnf_t = sl_wfx_pta_priority_cnf_s;
#[doc = "< PTA is off"]
pub const sl_wfx_pta_state_e_SL_WFX_PTA_OFF: sl_wfx_pta_state_e = 0;
#[doc = "< PTA is on"]
pub const sl_wfx_pta_state_e_SL_WFX_PTA_ON: sl_wfx_pta_state_e = 1;
#[doc = " @brief PTA states."]
pub type sl_wfx_pta_state_e = c_types::c_uint;
#[doc = " @brief PTA states."]
pub use self::sl_wfx_pta_state_e as sl_wfx_pta_state_t;
#[doc = " @brief Request sent by host to start or stop the PTA.\n @note Starting PTA will fail if not first configured with ::sl_wfx_pta_settings_req_body_t request."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_state_req_body_s {
    #[doc = "< Requested PTA state, see enum ::sl_wfx_pta_state_t"]
    pub pta_state: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_state_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_pta_state_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_state_req_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_state_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_state_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_state_req_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pta_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_state_req_body_s),
            "::",
            stringify!(pta_state)
        )
    );
}
#[doc = " @brief Request sent by host to start or stop the PTA.\n @note Starting PTA will fail if not first configured with ::sl_wfx_pta_settings_req_body_t request."]
pub type sl_wfx_pta_state_req_body_t = sl_wfx_pta_state_req_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_state_req_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_pta_state_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_state_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_pta_state_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_state_req_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_state_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_state_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_state_req_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_state_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_state_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_pta_state_req_t = sl_wfx_pta_state_req_s;
#[doc = " @brief Confirmation sent by WLAN firmware after a ::SL_WFX_PTA_STATE_REQ_ID request."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_state_cnf_body_s {
    #[doc = "< Confirmation status, see enum ::sl_wfx_status_t"]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_state_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_pta_state_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_state_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_state_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_state_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_state_cnf_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_state_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation sent by WLAN firmware after a ::SL_WFX_PTA_STATE_REQ_ID request."]
pub type sl_wfx_pta_state_cnf_body_t = sl_wfx_pta_state_cnf_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_state_cnf_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_pta_state_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_state_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_pta_state_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_state_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_state_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_state_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_state_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_state_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_state_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_pta_state_cnf_t = sl_wfx_pta_state_cnf_s;
#[doc = "< Use CCA defer threshold relative to channel noise"]
pub const sl_wfx_cc_thr_mode_e_SL_WFX_CCA_THR_MODE_RELATIVE: sl_wfx_cc_thr_mode_e = 0;
#[doc = "< Use absolute CCA defer threshold"]
pub const sl_wfx_cc_thr_mode_e_SL_WFX_CCA_THR_MODE_ABSOLUTE: sl_wfx_cc_thr_mode_e = 1;
#[doc = " @brief CCA Mode definition"]
pub type sl_wfx_cc_thr_mode_e = c_types::c_uint;
#[doc = " @brief CCA Mode definition"]
pub use self::sl_wfx_cc_thr_mode_e as sl_wfx_cc_thr_mode_t;
#[doc = " @brief Request sent by host to set the Clear Channel Assessment configuration\n Set the CCA mode and the defer threshold"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_cca_config_req_body_s {
    #[doc = "< CCA threshold mode. See enum ::sl_wfx_cc_thr_mode_t."]
    pub cca_thr_mode: u8,
    #[doc = "< reserved for future use, set to 0"]
    pub reserved: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_set_cca_config_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_cca_config_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_cca_config_req_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_set_cca_config_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_cca_config_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_cca_config_req_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cca_thr_mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_cca_config_req_body_s),
            "::",
            stringify!(cca_thr_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_cca_config_req_body_s),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Request sent by host to set the Clear Channel Assessment configuration\n Set the CCA mode and the defer threshold"]
pub type sl_wfx_set_cca_config_req_body_t = sl_wfx_set_cca_config_req_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_cca_config_req_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_set_cca_config_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_cca_config_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_cca_config_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_cca_config_req_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_cca_config_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_cca_config_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_cca_config_req_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_cca_config_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_cca_config_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_cca_config_req_t = sl_wfx_set_cca_config_req_s;
#[doc = " @brief Confirmation sent by Wlan firmware after a ::SL_WFX_SET_CCA_CONFIG_REQ_ID request."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_cca_config_cnf_body_s {
    #[doc = "< Confirmation status, see enum ::sl_wfx_status_t"]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_cca_config_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_cca_config_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_cca_config_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_set_cca_config_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_cca_config_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_cca_config_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_cca_config_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation sent by Wlan firmware after a ::SL_WFX_SET_CCA_CONFIG_REQ_ID request."]
pub type sl_wfx_set_cca_config_cnf_body_t = sl_wfx_set_cca_config_cnf_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_cca_config_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_set_cca_config_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_cca_config_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_cca_config_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_cca_config_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_cca_config_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_cca_config_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_cca_config_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_cca_config_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_cca_config_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_cca_config_t = sl_wfx_set_cca_config_s;
#[doc = "< \\b SET_MAC_ADDRESS request ID uses body SL_WFX_SET_MAC_ADDRESS_REQ_BODY and returns SL_WFX_SET_MAC_ADDRESS_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_MAC_ADDRESS_REQ_ID: sl_wfx_requests_ids_e = 66;
#[doc = "< \\b CONNECT request ID uses body SL_WFX_CONNECT_REQ_BODY and returns SL_WFX_CONNECT_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_CONNECT_REQ_ID: sl_wfx_requests_ids_e = 67;
#[doc = "< \\b DISCONNECT request ID uses body SL_WFX_DISCONNECT_REQ_BODY and returns SL_WFX_DISCONNECT_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_DISCONNECT_REQ_ID: sl_wfx_requests_ids_e = 68;
#[doc = "< \\b START_AP request ID uses body SL_WFX_START_AP_REQ_BODY and returns SL_WFX_START_AP_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_START_AP_REQ_ID: sl_wfx_requests_ids_e = 69;
#[doc = "< \\b UPDATE_AP request ID uses body SL_WFX_UPDATE_AP_REQ_BODY and returns SL_WFX_UPDATE_AP_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_UPDATE_AP_REQ_ID: sl_wfx_requests_ids_e = 70;
#[doc = "< \\b STOP_AP request ID uses body SL_WFX_STOP_AP_REQ_BODY and returns SL_WFX_STOP_AP_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_STOP_AP_REQ_ID: sl_wfx_requests_ids_e = 71;
#[doc = "< \\b SEND_FRAME request ID uses body SL_WFX_SEND_FRAME_REQ_BODY and returns SL_WFX_SEND_FRAME_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SEND_FRAME_REQ_ID: sl_wfx_requests_ids_e = 74;
#[doc = "< \\b START_SCAN request ID uses body SL_WFX_START_SCAN_REQ_BODY and returns SL_WFX_START_SCAN_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_START_SCAN_REQ_ID: sl_wfx_requests_ids_e = 75;
#[doc = "< \\b STOP_SCAN request ID uses body SL_WFX_STOP_SCAN_REQ_BODY and returns SL_WFX_STOP_SCAN_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_STOP_SCAN_REQ_ID: sl_wfx_requests_ids_e = 76;
#[doc = "< \\b GET_SIGNAL_STRENGTH request ID uses body SL_WFX_GET_SIGNAL_STRENGTH_REQ_BODY and returns SL_WFX_GET_SIGNAL_STRENGTH_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_GET_SIGNAL_STRENGTH_REQ_ID: sl_wfx_requests_ids_e = 78;
#[doc = "< \\b DISCONNECT_AP_CLIENT request ID uses body SL_WFX_DISCONNECT_AP_CLIENT_REQ_BODY and returns SL_WFX_DISCONNECT_AP_CLIENT_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_DISCONNECT_AP_CLIENT_REQ_ID: sl_wfx_requests_ids_e = 79;
#[doc = "< \\b SET_PM_MODE request ID uses body SL_WFX_SET_PM_MODE_REQ_BODY and returns SL_WFX_SET_PM_MODE_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_PM_MODE_REQ_ID: sl_wfx_requests_ids_e = 82;
#[doc = "< \\b ADD_MULTICAST_ADDR request ID uses body SL_WFX_ADD_MULTICAST_ADDR_REQ_BODY and returns SL_WFX_ADD_MULTICAST_ADDR_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_ADD_MULTICAST_ADDR_REQ_ID: sl_wfx_requests_ids_e = 83;
#[doc = "< \\b REMOVE_MULTICAST_ADDR request ID uses body SL_WFX_REMOVE_MULTICAST_ADDR_REQ_BODY and returns SL_WFX_REMOVE_MULTICAST_ADDR_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_REMOVE_MULTICAST_ADDR_REQ_ID: sl_wfx_requests_ids_e = 84;
#[doc = "< \\b SET_MAX_AP_CLIENT_COUNT request ID uses body SL_WFX_SET_MAX_AP_CLIENT_COUNT_REQ_BODY and returns SL_WFX_SET_MAX_AP_CLIENT_COUNT_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_MAX_AP_CLIENT_COUNT_REQ_ID: sl_wfx_requests_ids_e = 85;
#[doc = "< \\b SET_MAX_AP_CLIENT_INACTIVITY request ID uses body SL_WFX_SET_MAX_AP_CLIENT_INACTIVITY_REQ_BODY and returns SL_WFX_SET_MAX_AP_CLIENT_INACTIVITY_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_MAX_AP_CLIENT_INACTIVITY_REQ_ID: sl_wfx_requests_ids_e =
    86;
#[doc = "< \\b SET_ROAM_PARAMETERS request ID uses body SL_WFX_SET_ROAM_PARAMETERS_REQ_BODY and returns SL_WFX_SET_ROAM_PARAMETERS_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_ROAM_PARAMETERS_REQ_ID: sl_wfx_requests_ids_e = 87;
#[doc = "< \\b SET_TX_RATE_PARAMETERS request ID uses body SL_WFX_SET_TX_RATE_PARAMETERS_REQ_BODY and returns SL_WFX_SET_TX_RATE_PARAMETERS_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_TX_RATE_PARAMETERS_REQ_ID: sl_wfx_requests_ids_e = 88;
#[doc = "< \\b SET_ARP_IP_ADDRESS request ID uses body SL_WFX_SET_ARP_IP_ADDRESS_REQ_BODY and returns SL_WFX_SET_ARP_IP_ADDRESS_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_ARP_IP_ADDRESS_REQ_ID: sl_wfx_requests_ids_e = 89;
#[doc = "< \\b SET_NS_IP_ADDRESS request ID uses body SL_WFX_SET_NS_IP_ADDRESS_REQ_BODY and returns SL_WFX_SET_NS_IP_ADDRESS_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_NS_IP_ADDRESS_REQ_ID: sl_wfx_requests_ids_e = 90;
#[doc = "< \\b SET_BROADCAST_FILTER request ID uses body SL_WFX_SET_BROADCAST_FILTER_REQ_BODY and returns SL_WFX_SET_BROADCAST_FILTER_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_BROADCAST_FILTER_REQ_ID: sl_wfx_requests_ids_e = 91;
#[doc = "< \\b SET_SCAN_PARAMETERS request ID uses body SL_WFX_SET_SCAN_PARAMETERS_REQ_BODY and returns SL_WFX_SET_SCAN_PARAMETERS_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_SCAN_PARAMETERS_REQ_ID: sl_wfx_requests_ids_e = 92;
#[doc = "< \\b SET_UNICAST_FILTER request ID uses body SL_WFX_SET_UNICAST_FILTER_REQ_BODY and returns SL_WFX_SET_UNICAST_FILTER_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_UNICAST_FILTER_REQ_ID: sl_wfx_requests_ids_e = 93;
#[doc = "< \\b ADD_WHITELIST_ADDR request ID uses body SL_WFX_ADD_WHITELIST_ADDR_REQ_BODY and returns SL_WFX_ADD_WHITELIST_ADDR_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_ADD_WHITELIST_ADDR_REQ_ID: sl_wfx_requests_ids_e = 94;
#[doc = "< \\b ADD_BLACKLIST_ADDR request ID uses body SL_WFX_ADD_BLACKLIST_ADDR_REQ_BODY and returns SL_WFX_ADD_BLACKLIST_ADDR_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_ADD_BLACKLIST_ADDR_REQ_ID: sl_wfx_requests_ids_e = 95;
#[doc = "< \\b SET_MAX_TX_POWER request ID uses body SL_WFX_SET_MAX_TX_POWER_REQ_BODY and returns SL_WFX_SET_MAX_TX_POWER_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_MAX_TX_POWER_REQ_ID: sl_wfx_requests_ids_e = 96;
#[doc = "< \\b GET_MAX_TX_POWER request ID uses body SL_WFX_GET_MAX_TX_POWER_REQ_BODY and returns SL_WFX_GET_MAX_TX_POWER_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_GET_MAX_TX_POWER_REQ_ID: sl_wfx_requests_ids_e = 97;
#[doc = "< \\b GET_PMK request ID uses body SL_WFX_GET_PMK_REQ_BODY and returns SL_WFX_GET_PMK_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_GET_PMK_REQ_ID: sl_wfx_requests_ids_e = 98;
#[doc = "< \\b GET_AP_CLIENT_SIGNAL_STRENGTH request ID uses body SL_WFX_GET_AP_CLIENT_SIGNAL_STRENGTH_BODY and returns SL_WFX_GET_AP_CLIENT_SIGNAL_STRENGTH_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_GET_AP_CLIENT_SIGNAL_STRENGTH_REQ_ID: sl_wfx_requests_ids_e =
    99;
#[doc = "< \\b EXT_AUTH request ID uses body SL_WFX_EXT_AUTH_BODY and returns SL_WFX_EXT_AUTH_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_EXT_AUTH_REQ_ID: sl_wfx_requests_ids_e = 100;
#[doc = "< \\b AP_SCAN_REQUEST request ID uses body SL_WFX_AP_SCAN_REQUEST_BODY and returns SL_WFX_AP_SCAN_REQUEST_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_AP_SCAN_REQUEST_FILTER_REQ_ID: sl_wfx_requests_ids_e = 101;
#[doc = "< \\b GET_STATISTICS request ID uses body SL_WFX_GET_STATISTICS_REQ_BODY and returns SL_WFX_GET_STATISTICS_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_GET_STATISTICS_REQ_ID: sl_wfx_requests_ids_e = 102;
#[doc = " @brief WFM API request message IDs."]
pub type sl_wfx_requests_ids_e = c_types::c_uint;
#[doc = " @brief WFM API request message IDs."]
pub use self::sl_wfx_requests_ids_e as sl_wfx_requests_ids_t;
#[doc = "< \\b SET_MAC_ADDRESS confirmation Id. Returns body SL_WFX_SET_MAC_ADDRESS_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_MAC_ADDRESS_CNF_ID: sl_wfx_confirmations_ids_e = 66;
#[doc = "< \\b CONNECT confirmation Id. Returns body SL_WFX_CONNECT_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_CONNECT_CNF_ID: sl_wfx_confirmations_ids_e = 67;
#[doc = "< \\b DISCONNECT confirmation Id. Returns body SL_WFX_DISCONNECT_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_DISCONNECT_CNF_ID: sl_wfx_confirmations_ids_e = 68;
#[doc = "< \\b START_AP confirmation Id. Returns body SL_WFX_START_AP_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_START_AP_CNF_ID: sl_wfx_confirmations_ids_e = 69;
#[doc = "< \\b UPDATE_AP confirmation Id. Returns body SL_WFX_UPDATE_AP_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_UPDATE_AP_CNF_ID: sl_wfx_confirmations_ids_e = 70;
#[doc = "< \\b STOP_AP confirmation Id. Returns body SL_WFX_STOP_AP_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_STOP_AP_CNF_ID: sl_wfx_confirmations_ids_e = 71;
#[doc = "< \\b SEND_FRAME confirmation Id. Returns body SL_WFX_SEND_FRAME_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SEND_FRAME_CNF_ID: sl_wfx_confirmations_ids_e = 74;
#[doc = "< \\b START_SCAN confirmation Id. Returns body SL_WFX_START_SCAN_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_START_SCAN_CNF_ID: sl_wfx_confirmations_ids_e = 75;
#[doc = "< \\b STOP_SCAN confirmation Id. Returns body SL_WFX_STOP_SCAN_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_STOP_SCAN_CNF_ID: sl_wfx_confirmations_ids_e = 76;
#[doc = "< \\b GET_SIGNAL_STRENGTH confirmation Id. Returns body SL_WFX_GET_SIGNAL_STRENGTH_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_GET_SIGNAL_STRENGTH_CNF_ID: sl_wfx_confirmations_ids_e =
    78;
#[doc = "< \\b DISCONNECT_AP_CLIENT confirmation Id. Returns body SL_WFX_DISCONNECT_AP_CLIENT_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_DISCONNECT_AP_CLIENT_CNF_ID:
    sl_wfx_confirmations_ids_e = 79;
#[doc = "< \\b SET_PM_MODE confirmation Id. Returns body SL_WFX_SET_PM_MODE_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_PM_MODE_CNF_ID: sl_wfx_confirmations_ids_e = 82;
#[doc = "< \\b ADD_MULTICAST_ADDR confirmation Id. Returns body SL_WFX_ADD_MULTICAST_ADDR_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_ADD_MULTICAST_ADDR_CNF_ID: sl_wfx_confirmations_ids_e =
    83;
#[doc = "< \\b REMOVE_MULTICAST_ADDR confirmation Id. Returns body SL_WFX_REMOVE_MULTICAST_ADDR_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_REMOVE_MULTICAST_ADDR_CNF_ID:
    sl_wfx_confirmations_ids_e = 84;
#[doc = "< \\b SET_MAX_AP_CLIENT_COUNT confirmation Id. Returns body SL_WFX_SET_MAX_AP_CLIENT_COUNT_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_MAX_AP_CLIENT_COUNT_CNF_ID:
    sl_wfx_confirmations_ids_e = 85;
#[doc = "< \\b SET_MAX_AP_CLIENT_INACTIVITY confirmation Id. Returns body SL_WFX_SET_MAX_AP_CLIENT_INACTIVITY_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_MAX_AP_CLIENT_INACTIVITY_CNF_ID:
    sl_wfx_confirmations_ids_e = 86;
#[doc = "< \\b SET_ROAM_PARAMETERS confirmation Id. Returns body SL_WFX_SET_ROAM_PARAMETERS_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_ROAM_PARAMETERS_CNF_ID: sl_wfx_confirmations_ids_e =
    87;
#[doc = "< \\b SET_TX_RATE_PARAMETERS confirmation Id. Returns body SL_WFX_SET_TX_RATE_PARAMETERS_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_TX_RATE_PARAMETERS_CNF_ID:
    sl_wfx_confirmations_ids_e = 88;
#[doc = "< \\b SET_ARP_IP_ADDRESS confirmation Id. Returns body SL_WFX_SET_ARP_IP_ADDRESS_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_ARP_IP_ADDRESS_CNF_ID: sl_wfx_confirmations_ids_e =
    89;
#[doc = "< \\b SET_NS_IP_ADDRESS confirmation Id. Returns body SL_WFX_SET_NS_IP_ADDRESS_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_NS_IP_ADDRESS_CNF_ID: sl_wfx_confirmations_ids_e =
    90;
#[doc = "< \\b SET_BROADCAST_FILTER confirmation Id. Returns body SL_WFX_SET_BROADCAST_FILTER_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_BROADCAST_FILTER_CNF_ID:
    sl_wfx_confirmations_ids_e = 91;
#[doc = "< \\b SET_SCAN_PARAMETERS confirmation Id. Returns body SL_WFX_SET_SCAN_PARAMETERS_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_SCAN_PARAMETERS_CNF_ID: sl_wfx_confirmations_ids_e =
    92;
#[doc = "< \\b SET_UNICAST_FILTER confirmation Id. Returns body SL_WFX_SET_UNICAST_FILTER_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_UNICAST_FILTER_CNF_ID: sl_wfx_confirmations_ids_e =
    93;
#[doc = "< \\b ADD_WHITELIST_ADDR confirmation Id. Returns body SL_WFX_ADD_WHITELIST_ADDR_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_ADD_WHITELIST_ADDR_CNF_ID: sl_wfx_confirmations_ids_e =
    94;
#[doc = "< \\b ADD_BLACKLIST_ADDR confirmation Id. Returns body SL_WFX_ADD_BLACKLIST_ADDR_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_ADD_BLACKLIST_ADDR_CNF_ID: sl_wfx_confirmations_ids_e =
    95;
#[doc = "< \\b SET_MAX_TX_POWER confirmation Id. Returns body SL_WFX_SET_MAX_TX_POWER_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_MAX_TX_POWER_CNF_ID: sl_wfx_confirmations_ids_e =
    96;
#[doc = "< \\b GET_MAX_TX_POWER confirmation Id. Returns body SL_WFX_GET_MAX_TX_POWER_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_GET_MAX_TX_POWER_CNF_ID: sl_wfx_confirmations_ids_e =
    97;
#[doc = "< \\b GET_PMK confirmation Id. Returns body SL_WFX_GET_PMK_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_GET_PMK_CNF_ID: sl_wfx_confirmations_ids_e = 98;
#[doc = "< \\b GET_AP_CLIENT_SIGNAL_STRENGTH confirmation Id. Returns body SL_WFX_GET_AP_CLIENT_SIGNAL_STRENGTH_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_GET_AP_CLIENT_SIGNAL_STRENGTH_CNF_ID:
    sl_wfx_confirmations_ids_e = 99;
#[doc = "< \\b EXT_AUTH confirmation Id. Returns body SL_WFX_EXT_AUTH_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_EXT_AUTH_CNF_ID: sl_wfx_confirmations_ids_e = 100;
#[doc = "< \\b AP_SCAN_REQUEST confirmation Id. Returns body SL_WFX_AP_SCAN_REQUEST_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_AP_SCAN_REQUEST_FILTER_CNF_ID:
    sl_wfx_confirmations_ids_e = 101;
#[doc = "< \\b GET_STATISTICS confirmation Id. Returns body SL_WFX_GET_STATISTICS_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_GET_STATISTICS_CNF_ID: sl_wfx_confirmations_ids_e = 102;
#[doc = " @brief WFM API confirmation message IDs."]
pub type sl_wfx_confirmations_ids_e = c_types::c_uint;
#[doc = " @brief WFM API confirmation message IDs."]
pub use self::sl_wfx_confirmations_ids_e as sl_wfx_confirmations_ids_t;
#[doc = "< \\b CONNECT indication id. Content is SL_WFX_CONNECT_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_CONNECT_IND_ID: sl_wfx_indications_ids_e = 195;
#[doc = "< \\b DISCONNECT indication id. Content is SL_WFX_DISCONNECT_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_DISCONNECT_IND_ID: sl_wfx_indications_ids_e = 196;
#[doc = "< \\b START_AP indication id. Content is SL_WFX_START_AP_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_START_AP_IND_ID: sl_wfx_indications_ids_e = 197;
#[doc = "< \\b STOP_AP indication id. Content is SL_WFX_STOP_AP_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_STOP_AP_IND_ID: sl_wfx_indications_ids_e = 199;
#[doc = "< \\b RECEIVED indication id. Content is SL_WFX_RECEIVED_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_RECEIVED_IND_ID: sl_wfx_indications_ids_e = 202;
#[doc = "< \\b SCAN_RESULT indication id. Content is SL_WFX_SCAN_RESULT_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_SCAN_RESULT_IND_ID: sl_wfx_indications_ids_e = 203;
#[doc = "< \\b SCAN_COMPLETE indication id. Content is SL_WFX_SCAN_COMPLETE_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_SCAN_COMPLETE_IND_ID: sl_wfx_indications_ids_e = 204;
#[doc = "< \\b AP_CLIENT_CONNECTED indication id. Content is SL_WFX_AP_CLIENT_CONNECTED_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_AP_CLIENT_CONNECTED_IND_ID: sl_wfx_indications_ids_e =
    205;
#[doc = "< \\b AP_CLIENT_REJECTED indication id. Content is SL_WFX_AP_CLIENT_REJECTED_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_AP_CLIENT_REJECTED_IND_ID: sl_wfx_indications_ids_e = 206;
#[doc = "< \\b AP_CLIENT_DISCONNECTED indication id. Content is SL_WFX_AP_CLIENT_DISCONNECTED_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_AP_CLIENT_DISCONNECTED_IND_ID: sl_wfx_indications_ids_e =
    207;
#[doc = "< \\b EXT_AUTH indication Id. Content is SL_WFX_EXT_AUTH_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_EXT_AUTH_IND_ID: sl_wfx_indications_ids_e = 210;
#[doc = "< \\b PS_MODE_ERROR indication Id. Content is SL_WFX_PS_MODE_ERROR_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_PS_MODE_ERROR_IND_ID: sl_wfx_indications_ids_e = 211;
#[doc = "< \\b AP_SCAN_REQUEST indication Id. Content is SL_WFX_AP_SCAN_REQUEST_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_AP_SCAN_REQUEST_IND_ID: sl_wfx_indications_ids_e = 212;
#[doc = " @brief WFM API indication message IDs."]
pub type sl_wfx_indications_ids_e = c_types::c_uint;
#[doc = " @brief WFM API indication message IDs."]
pub use self::sl_wfx_indications_ids_e as sl_wfx_indications_ids_t;
#[doc = " @brief WFM API message IDs."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union wfm_message_ids_u {
    #[doc = " Request messages sent from the host to the device."]
    pub requests: sl_wfx_requests_ids_t,
    #[doc = " Confirmation messages sent from the device to the host."]
    pub confirmations: sl_wfx_confirmations_ids_t,
    #[doc = " Indication messages sent from the device to the host."]
    pub indications: sl_wfx_indications_ids_t,
}
#[test]
fn bindgen_test_layout_wfm_message_ids_u() {
    const UNINIT: ::core::mem::MaybeUninit<wfm_message_ids_u> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<wfm_message_ids_u>(),
        4usize,
        concat!("Size of: ", stringify!(wfm_message_ids_u))
    );
    assert_eq!(
        ::core::mem::align_of::<wfm_message_ids_u>(),
        1usize,
        concat!("Alignment of ", stringify!(wfm_message_ids_u))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).requests) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wfm_message_ids_u),
            "::",
            stringify!(requests)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).confirmations) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wfm_message_ids_u),
            "::",
            stringify!(confirmations)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).indications) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wfm_message_ids_u),
            "::",
            stringify!(indications)
        )
    );
}
#[doc = " @brief WFM API message IDs."]
pub type sl_wfx_message_ids_t = wfm_message_ids_u;
#[doc = "< Client isolation disabled"]
pub const sl_wfx_client_isolation_e_WFM_CLIENT_ISOLATION_DISABLED: sl_wfx_client_isolation_e = 0;
#[doc = "< Client isolation enabled"]
pub const sl_wfx_client_isolation_e_WFM_CLIENT_ISOLATION_ENABLED: sl_wfx_client_isolation_e = 1;
#[doc = " @brief Client Isolation toggling."]
pub type sl_wfx_client_isolation_e = c_types::c_uint;
#[doc = " @brief Client Isolation toggling."]
pub use self::sl_wfx_client_isolation_e as sl_wfx_client_isolation_t;
#[doc = "< Management Frame"]
pub const sl_wfx_frame_type_e_WFM_FRAME_TYPE_MGMT: sl_wfx_frame_type_e = 0;
#[doc = "< Action Frame"]
pub const sl_wfx_frame_type_e_WFM_FRAME_TYPE_ACTION: sl_wfx_frame_type_e = 4;
#[doc = "< Data Frame"]
pub const sl_wfx_frame_type_e_WFM_FRAME_TYPE_DATA: sl_wfx_frame_type_e = 8;
#[doc = " @brief Type of frame to be sent.\n\n Value unused, all frames are considered to be Data by default.@n\n Support for the other types will be added later."]
pub type sl_wfx_frame_type_e = c_types::c_uint;
#[doc = " @brief Type of frame to be sent.\n\n Value unused, all frames are considered to be Data by default.@n\n Support for the other types will be added later."]
pub use self::sl_wfx_frame_type_e as sl_wfx_frame_type_t;
#[doc = "< SSID not hidden"]
pub const sl_wfx_hidden_ssid_e_WFM_HIDDEN_SSID_FALSE: sl_wfx_hidden_ssid_e = 0;
#[doc = "< SSID hidden"]
pub const sl_wfx_hidden_ssid_e_WFM_HIDDEN_SSID_TRUE: sl_wfx_hidden_ssid_e = 1;
#[doc = " @brief Hidden SSID toggling."]
pub type sl_wfx_hidden_ssid_e = c_types::c_uint;
#[doc = " @brief Hidden SSID toggling."]
pub use self::sl_wfx_hidden_ssid_e as sl_wfx_hidden_ssid_t;
#[doc = "< PMF disabled"]
pub const sl_wfx_mgmt_frame_protection_e_WFM_MGMT_FRAME_PROTECTION_DISABLED:
    sl_wfx_mgmt_frame_protection_e = 0;
#[doc = "< PMF optional"]
pub const sl_wfx_mgmt_frame_protection_e_WFM_MGMT_FRAME_PROTECTION_OPTIONAL:
    sl_wfx_mgmt_frame_protection_e = 1;
#[doc = "< PMF mandatory"]
pub const sl_wfx_mgmt_frame_protection_e_WFM_MGMT_FRAME_PROTECTION_MANDATORY:
    sl_wfx_mgmt_frame_protection_e = 2;
#[doc = " @brief Device Protected Management Frame mode."]
pub type sl_wfx_mgmt_frame_protection_e = c_types::c_uint;
#[doc = " @brief Device Protected Management Frame mode."]
pub use self::sl_wfx_mgmt_frame_protection_e as sl_wfx_mgmt_frame_protection_t;
#[doc = "< Always on"]
pub const sl_wfx_pm_mode_e_WFM_PM_MODE_ACTIVE: sl_wfx_pm_mode_e = 0;
#[doc = "< Use power_save and wake up on beacons"]
pub const sl_wfx_pm_mode_e_WFM_PM_MODE_PS: sl_wfx_pm_mode_e = 1;
#[doc = "< Use power_save and wake up on DTIM"]
pub const sl_wfx_pm_mode_e_WFM_PM_MODE_DTIM: sl_wfx_pm_mode_e = 2;
#[doc = " @brief Device power management mode."]
pub type sl_wfx_pm_mode_e = c_types::c_uint;
#[doc = " @brief Device power management mode."]
pub use self::sl_wfx_pm_mode_e as sl_wfx_pm_mode_t;
#[doc = "< Use U-APSD"]
pub const sl_wfx_pm_poll_e_WFM_PM_POLL_UAPSD: sl_wfx_pm_poll_e = 0;
#[doc = "< Use Fast PS"]
pub const sl_wfx_pm_poll_e_WFM_PM_POLL_FAST_PS: sl_wfx_pm_poll_e = 1;
#[doc = " @brief Device power save polling strategy."]
pub type sl_wfx_pm_poll_e = c_types::c_uint;
#[doc = " @brief Device power save polling strategy."]
pub use self::sl_wfx_pm_poll_e as sl_wfx_pm_poll_t;
#[doc = "< Best Effort"]
pub const sl_wfx_priority_e_WFM_PRIORITY_BE0: sl_wfx_priority_e = 0;
#[doc = "< Background"]
pub const sl_wfx_priority_e_WFM_PRIORITY_BK1: sl_wfx_priority_e = 1;
#[doc = "< Background"]
pub const sl_wfx_priority_e_WFM_PRIORITY_BK2: sl_wfx_priority_e = 2;
#[doc = "< Best Effort"]
pub const sl_wfx_priority_e_WFM_PRIORITY_BE3: sl_wfx_priority_e = 3;
#[doc = "< Video"]
pub const sl_wfx_priority_e_WFM_PRIORITY_VI4: sl_wfx_priority_e = 4;
#[doc = "< Video"]
pub const sl_wfx_priority_e_WFM_PRIORITY_VI5: sl_wfx_priority_e = 5;
#[doc = "< Voice"]
pub const sl_wfx_priority_e_WFM_PRIORITY_VO6: sl_wfx_priority_e = 6;
#[doc = "< Voice"]
pub const sl_wfx_priority_e_WFM_PRIORITY_VO7: sl_wfx_priority_e = 7;
#[doc = " @brief Data priority level per 802.1D."]
pub type sl_wfx_priority_e = c_types::c_uint;
#[doc = " @brief Data priority level per 802.1D."]
pub use self::sl_wfx_priority_e as sl_wfx_priority_t;
#[doc = "< Unspecified reason (unused)"]
pub const sl_wfx_reason_e_WFM_REASON_UNSPECIFIED: sl_wfx_reason_e = 0;
#[doc = "< Client timed out"]
pub const sl_wfx_reason_e_WFM_REASON_TIMEOUT: sl_wfx_reason_e = 1;
#[doc = "< Client left"]
pub const sl_wfx_reason_e_WFM_REASON_LEAVING_BSS: sl_wfx_reason_e = 2;
#[doc = "< Client not authenticated"]
pub const sl_wfx_reason_e_WFM_REASON_UNKNOWN_STA: sl_wfx_reason_e = 3;
#[doc = "< Too many clients already connected"]
pub const sl_wfx_reason_e_WFM_REASON_AP_FULL: sl_wfx_reason_e = 4;
#[doc = "< WPA authentication failed"]
pub const sl_wfx_reason_e_WFM_REASON_AUTHENTICATION_FAILURE: sl_wfx_reason_e = 5;
#[doc = " @brief Reasons for AP to reject or disconnect a client."]
pub type sl_wfx_reason_e = c_types::c_uint;
#[doc = " @brief Reasons for AP to reject or disconnect a client."]
pub use self::sl_wfx_reason_e as sl_wfx_reason_t;
#[doc = "< Unspecified reason"]
pub const sl_wfx_disconnected_reason_e_WFM_DISCONNECTED_REASON_UNSPECIFIED:
    sl_wfx_disconnected_reason_e = 0;
#[doc = "< AP timed out"]
pub const sl_wfx_disconnected_reason_e_WFM_DISCONNECTED_REASON_AP_LOST:
    sl_wfx_disconnected_reason_e = 1;
#[doc = "< Disconnected by AP"]
pub const sl_wfx_disconnected_reason_e_WFM_DISCONNECTED_REASON_REJECTED:
    sl_wfx_disconnected_reason_e = 2;
#[doc = "< Leaving intentionally"]
pub const sl_wfx_disconnected_reason_e_WFM_DISCONNECTED_REASON_LEAVING_BSS:
    sl_wfx_disconnected_reason_e = 3;
#[doc = "< WPA countermeasures triggered a disconnection"]
pub const sl_wfx_disconnected_reason_e_WFM_DISCONNECTED_REASON_WPA_COUNTERMEASURES:
    sl_wfx_disconnected_reason_e = 4;
#[doc = " @brief Reasons for STA disconnection"]
pub type sl_wfx_disconnected_reason_e = c_types::c_uint;
#[doc = " @brief Reasons for STA disconnection"]
pub use self::sl_wfx_disconnected_reason_e as sl_wfx_disconnected_reason_t;
#[doc = "< Passive scan: listen for beacons only"]
pub const sl_wfx_scan_mode_e_WFM_SCAN_MODE_PASSIVE: sl_wfx_scan_mode_e = 0;
#[doc = "< Active scan: send probe requests"]
pub const sl_wfx_scan_mode_e_WFM_SCAN_MODE_ACTIVE: sl_wfx_scan_mode_e = 1;
#[doc = " @brief Scan mode to be used."]
pub type sl_wfx_scan_mode_e = c_types::c_uint;
#[doc = " @brief Scan mode to be used."]
pub use self::sl_wfx_scan_mode_e as sl_wfx_scan_mode_t;
#[doc = "< No security"]
pub const sl_wfx_security_mode_e_WFM_SECURITY_MODE_OPEN: sl_wfx_security_mode_e = 0;
#[doc = "< Use WEP"]
pub const sl_wfx_security_mode_e_WFM_SECURITY_MODE_WEP: sl_wfx_security_mode_e = 1;
#[doc = "< Use WPA1 or WPA2"]
pub const sl_wfx_security_mode_e_WFM_SECURITY_MODE_WPA2_WPA1_PSK: sl_wfx_security_mode_e = 2;
#[doc = "< Use only WPA2"]
pub const sl_wfx_security_mode_e_WFM_SECURITY_MODE_WPA2_PSK: sl_wfx_security_mode_e = 4;
#[doc = "< Use WPA3 (STA mode only)"]
pub const sl_wfx_security_mode_e_WFM_SECURITY_MODE_WPA3_SAE: sl_wfx_security_mode_e = 6;
#[doc = " @brief Security mode of a network."]
pub type sl_wfx_security_mode_e = c_types::c_uint;
#[doc = " @brief Security mode of a network."]
pub use self::sl_wfx_security_mode_e as sl_wfx_security_mode_t;
#[doc = "<"]
pub const sl_wfx_ext_auth_data_type_e_WFM_EXT_AUTH_DATA_TYPE_SAE_START:
    sl_wfx_ext_auth_data_type_e = 0;
#[doc = "<"]
pub const sl_wfx_ext_auth_data_type_e_WFM_EXT_AUTH_DATA_TYPE_SAE_COMMIT:
    sl_wfx_ext_auth_data_type_e = 1;
#[doc = "<"]
pub const sl_wfx_ext_auth_data_type_e_WFM_EXT_AUTH_DATA_TYPE_SAE_CONFIRM:
    sl_wfx_ext_auth_data_type_e = 2;
#[doc = "<"]
pub const sl_wfx_ext_auth_data_type_e_WFM_EXT_AUTH_DATA_TYPE_MSK: sl_wfx_ext_auth_data_type_e = 3;
#[doc = " @brief Type of the authentication message."]
pub type sl_wfx_ext_auth_data_type_e = c_types::c_uint;
#[doc = " @brief Type of the authentication message."]
pub use self::sl_wfx_ext_auth_data_type_e as sl_wfx_ext_auth_data_type_t;
#[doc = "< The device has successfully completed a request."]
pub const sl_wfx_fmac_status_e_WFM_STATUS_SUCCESS: sl_wfx_fmac_status_e = 0;
#[doc = "< A request contains one or more invalid parameters."]
pub const sl_wfx_fmac_status_e_WFM_STATUS_INVALID_PARAMETER: sl_wfx_fmac_status_e = 1;
#[doc = "< The request cannot be performed because the device is in an inappropriate state."]
pub const sl_wfx_fmac_status_e_WFM_STATUS_WRONG_STATE: sl_wfx_fmac_status_e = 2;
#[doc = "< The request failed due to an error."]
pub const sl_wfx_fmac_status_e_WFM_STATUS_GENERAL_FAILURE: sl_wfx_fmac_status_e = 3;
#[doc = "< The request failed due to regulatory limitations."]
pub const sl_wfx_fmac_status_e_WFM_STATUS_CHANNEL_NOT_ALLOWED: sl_wfx_fmac_status_e = 4;
#[doc = "< The request is successful but some parameters have been ignored."]
pub const sl_wfx_fmac_status_e_WFM_STATUS_WARNING: sl_wfx_fmac_status_e = 5;
#[doc = "< The request failed because no suitable AP was found for the connection"]
pub const sl_wfx_fmac_status_e_WFM_STATUS_NO_MATCHING_AP: sl_wfx_fmac_status_e = 6;
#[doc = "< The request failed because the user issued a WFM_HI_DISCONNECT_REQ before completing the connection"]
pub const sl_wfx_fmac_status_e_WFM_STATUS_CONNECTION_ABORTED: sl_wfx_fmac_status_e = 7;
#[doc = "< The request failed because a timeout occurred during connection"]
pub const sl_wfx_fmac_status_e_WFM_STATUS_CONNECTION_TIMEOUT: sl_wfx_fmac_status_e = 8;
#[doc = "< The request failed because the AP rejected the connection"]
pub const sl_wfx_fmac_status_e_WFM_STATUS_CONNECTION_REJECTED_BY_AP: sl_wfx_fmac_status_e = 9;
#[doc = "< The request failed because the WPA handshake did not complete successfully"]
pub const sl_wfx_fmac_status_e_WFM_STATUS_CONNECTION_AUTH_FAILURE: sl_wfx_fmac_status_e = 10;
#[doc = "< The request failed because the retry limit was exceeded."]
pub const sl_wfx_fmac_status_e_WFM_STATUS_RETRY_EXCEEDED: sl_wfx_fmac_status_e = 19;
#[doc = "< The request failed because the MSDU life time was exceeded."]
pub const sl_wfx_fmac_status_e_WFM_STATUS_TX_LIFETIME_EXCEEDED: sl_wfx_fmac_status_e = 20;
#[doc = "< The request failed because TX is suspended (temperature too high)"]
pub const sl_wfx_fmac_status_e_WFM_STATUS_REQUEUE: sl_wfx_fmac_status_e = 21;
#[doc = " @brief Full MAC (UMAC) confirmation possible values for a returned 'status' field.\n\n All Full MAC (UMAC) confirmation messages have a field 'status' just after the message header.@n\n A value of zero indicates the request has completed successfully."]
pub type sl_wfx_fmac_status_e = c_types::c_uint;
#[doc = " @brief Full MAC (UMAC) confirmation possible values for a returned 'status' field.\n\n All Full MAC (UMAC) confirmation messages have a field 'status' just after the message header.@n\n A value of zero indicates the request has completed successfully."]
pub use self::sl_wfx_fmac_status_e as sl_wfx_fmac_status_t;
#[doc = " @brief Service Set Identifier (SSID) of a network.\n @details Note that the Ssid element must always contain SL_WFX_SSID_SIZE bytes.\n          Only the bytes up to SsidLength are considered to be valid, the rest should be set to zero."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_ssid_def_s {
    #[doc = " @brief Length of SSID data.\n @details <B>0 - 32</B>: The amount of bytes."]
    pub ssid_length: u32,
    #[doc = " SSID data."]
    pub ssid: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_ssid_def_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_ssid_def_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ssid_def_s>(),
        36usize,
        concat!("Size of: ", stringify!(sl_wfx_ssid_def_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ssid_def_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_ssid_def_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssid_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ssid_def_s),
            "::",
            stringify!(ssid_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ssid_def_s),
            "::",
            stringify!(ssid)
        )
    );
}
#[doc = " @brief Service Set Identifier (SSID) of a network.\n @details Note that the Ssid element must always contain SL_WFX_SSID_SIZE bytes.\n          Only the bytes up to SsidLength are considered to be valid, the rest should be set to zero."]
pub type sl_wfx_ssid_def_t = sl_wfx_ssid_def_s;
#[doc = " @brief Security mode bitmask for scan results. Empty if Open network."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_security_mode_bitmask_s {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_sl_wfx_security_mode_bitmask_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_security_mode_bitmask_s>(),
        1usize,
        concat!("Size of: ", stringify!(sl_wfx_security_mode_bitmask_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_security_mode_bitmask_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_security_mode_bitmask_s))
    );
}
impl sl_wfx_security_mode_bitmask_s {
    #[inline]
    pub fn wep(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wep(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wpa(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wpa(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wpa2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wpa2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wpa3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wpa3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pmf(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pmf(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn psk(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_psk(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn eap(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_eap(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wep: u8,
        wpa: u8,
        wpa2: u8,
        wpa3: u8,
        pmf: u8,
        unused: u8,
        psk: u8,
        eap: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wep: u8 = unsafe { ::core::mem::transmute(wep) };
            wep as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let wpa: u8 = unsafe { ::core::mem::transmute(wpa) };
            wpa as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let wpa2: u8 = unsafe { ::core::mem::transmute(wpa2) };
            wpa2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wpa3: u8 = unsafe { ::core::mem::transmute(wpa3) };
            wpa3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let pmf: u8 = unsafe { ::core::mem::transmute(pmf) };
            pmf as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let unused: u8 = unsafe { ::core::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let psk: u8 = unsafe { ::core::mem::transmute(psk) };
            psk as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let eap: u8 = unsafe { ::core::mem::transmute(eap) };
            eap as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief Security mode bitmask for scan results. Empty if Open network."]
pub type sl_wfx_security_mode_bitmask_t = sl_wfx_security_mode_bitmask_s;
#[doc = " @brief Device TX rate set bitmask used in sl_wfx_set_tx_rate_parameters_req_body_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_rate_set_bitmask_s {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    #[doc = "< Reserved, set to zero"]
    pub unused2: u8,
}
#[test]
fn bindgen_test_layout_sl_wfx_rate_set_bitmask_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_rate_set_bitmask_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_rate_set_bitmask_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_rate_set_bitmask_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_rate_set_bitmask_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_rate_set_bitmask_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unused2) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rate_set_bitmask_s),
            "::",
            stringify!(unused2)
        )
    );
}
impl sl_wfx_rate_set_bitmask_s {
    #[inline]
    pub fn b1Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_b1Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn b2Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_b2Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn b5P5Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_b5P5Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn b11Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_b11Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn g6Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_g6Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn g9Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_g9Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn g12Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_g12Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn g18Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_g18Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn g24Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_g24Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn g36Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_g36Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn g48Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_g48Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn g54Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_g54Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mcs0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mcs1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mcs2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mcs3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mcs4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mcs5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mcs6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mcs7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        b1Mbps: u8,
        b2Mbps: u8,
        b5P5Mbps: u8,
        b11Mbps: u8,
        unused: u8,
        g6Mbps: u8,
        g9Mbps: u8,
        g12Mbps: u8,
        g18Mbps: u8,
        g24Mbps: u8,
        g36Mbps: u8,
        g48Mbps: u8,
        g54Mbps: u8,
        mcs0: u8,
        mcs1: u8,
        mcs2: u8,
        mcs3: u8,
        mcs4: u8,
        mcs5: u8,
        mcs6: u8,
        mcs7: u8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let b1Mbps: u8 = unsafe { ::core::mem::transmute(b1Mbps) };
            b1Mbps as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let b2Mbps: u8 = unsafe { ::core::mem::transmute(b2Mbps) };
            b2Mbps as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let b5P5Mbps: u8 = unsafe { ::core::mem::transmute(b5P5Mbps) };
            b5P5Mbps as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let b11Mbps: u8 = unsafe { ::core::mem::transmute(b11Mbps) };
            b11Mbps as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let unused: u8 = unsafe { ::core::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let g6Mbps: u8 = unsafe { ::core::mem::transmute(g6Mbps) };
            g6Mbps as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let g9Mbps: u8 = unsafe { ::core::mem::transmute(g9Mbps) };
            g9Mbps as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let g12Mbps: u8 = unsafe { ::core::mem::transmute(g12Mbps) };
            g12Mbps as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let g18Mbps: u8 = unsafe { ::core::mem::transmute(g18Mbps) };
            g18Mbps as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let g24Mbps: u8 = unsafe { ::core::mem::transmute(g24Mbps) };
            g24Mbps as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let g36Mbps: u8 = unsafe { ::core::mem::transmute(g36Mbps) };
            g36Mbps as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let g48Mbps: u8 = unsafe { ::core::mem::transmute(g48Mbps) };
            g48Mbps as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let g54Mbps: u8 = unsafe { ::core::mem::transmute(g54Mbps) };
            g54Mbps as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let mcs0: u8 = unsafe { ::core::mem::transmute(mcs0) };
            mcs0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let mcs1: u8 = unsafe { ::core::mem::transmute(mcs1) };
            mcs1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let mcs2: u8 = unsafe { ::core::mem::transmute(mcs2) };
            mcs2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let mcs3: u8 = unsafe { ::core::mem::transmute(mcs3) };
            mcs3 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let mcs4: u8 = unsafe { ::core::mem::transmute(mcs4) };
            mcs4 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let mcs5: u8 = unsafe { ::core::mem::transmute(mcs5) };
            mcs5 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let mcs6: u8 = unsafe { ::core::mem::transmute(mcs6) };
            mcs6 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let mcs7: u8 = unsafe { ::core::mem::transmute(mcs7) };
            mcs7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief Device TX rate set bitmask used in sl_wfx_set_tx_rate_parameters_req_body_t."]
pub type sl_wfx_rate_set_bitmask_t = sl_wfx_rate_set_bitmask_s;
#[doc = " @brief NS IP address element.\n @details Note that the IP element must always contain SL_WFX_IPV6_ADDR_SIZE bytes.\n          Only the bytes up to SsidLength are considered to be valid, the rest should be set to zero."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_ns_ip_addr_s {
    #[doc = " NS IP address."]
    pub ipv6_addr: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_ns_ip_addr_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_ns_ip_addr_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ns_ip_addr_s>(),
        16usize,
        concat!("Size of: ", stringify!(sl_wfx_ns_ip_addr_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ns_ip_addr_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_ns_ip_addr_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipv6_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ns_ip_addr_s),
            "::",
            stringify!(ipv6_addr)
        )
    );
}
#[doc = " @brief NS IP address element.\n @details Note that the IP element must always contain SL_WFX_IPV6_ADDR_SIZE bytes.\n          Only the bytes up to SsidLength are considered to be valid, the rest should be set to zero."]
pub type sl_wfx_ns_ip_addr_t = sl_wfx_ns_ip_addr_s;
#[doc = " @brief Request message body for sl_wfx_set_mac_address_req_t.\n @details\n          | Field       | Default value    | Reset to default value |\n          |:------------|:-----------------|:-----------------------|\n          | MAC address | device dependent | when device reset      |\n          <BR>"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_mac_address_req_body_s {
    #[doc = " MAC address of the interface."]
    pub mac_addr: [u8; 6usize],
    #[doc = " Reserved, set to zero."]
    pub reserved: u16,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_mac_address_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_mac_address_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_mac_address_req_body_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_mac_address_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_mac_address_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_mac_address_req_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_mac_address_req_body_s),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_mac_address_req_body_s),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_set_mac_address_req_t.\n @details\n          | Field       | Default value    | Reset to default value |\n          |:------------|:-----------------|:-----------------------|\n          | MAC address | device dependent | when device reset      |\n          <BR>"]
pub type sl_wfx_set_mac_address_req_body_t = sl_wfx_set_mac_address_req_body_s;
#[doc = " @brief Request message to set MAC address of the interface.\n @details The host can use this request to set the MAC address of an interface.\n          If not set, the device will use a built-in MAC address. Note that\n          if multiple interfaces are used, the MAC address MUST be different\n          on each interface.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | Yes             |\n          | station        | No              |\n          | AP             | No              |\n          <BR>\n @ingroup WFM_GROUP_MODE_IDLE"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_mac_address_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_set_mac_address_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_mac_address_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_mac_address_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_mac_address_req_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_set_mac_address_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_mac_address_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_mac_address_req_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_mac_address_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_mac_address_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message to set MAC address of the interface.\n @details The host can use this request to set the MAC address of an interface.\n          If not set, the device will use a built-in MAC address. Note that\n          if multiple interfaces are used, the MAC address MUST be different\n          on each interface.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | Yes             |\n          | station        | No              |\n          | AP             | No              |\n          <BR>\n @ingroup WFM_GROUP_MODE_IDLE"]
pub type sl_wfx_set_mac_address_req_t = sl_wfx_set_mac_address_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_mac_address_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_mac_address_cnf_body_s {
    #[doc = " @brief Status of the set request.\n @details <B>WFM_STATUS_SUCCESS</B>: the set request was completed successfully.\n          <BR><B>any other value</B>: the set request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_mac_address_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_mac_address_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_mac_address_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_set_mac_address_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_mac_address_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_mac_address_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_mac_address_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_set_mac_address_cnf_t."]
pub type sl_wfx_set_mac_address_cnf_body_t = sl_wfx_set_mac_address_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_mac_address_req_t.\n @ingroup WFM_GROUP_MODE_IDLE"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_mac_address_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_set_mac_address_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_mac_address_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_mac_address_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_mac_address_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_mac_address_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_mac_address_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_mac_address_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_mac_address_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_mac_address_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_set_mac_address_req_t.\n @ingroup WFM_GROUP_MODE_IDLE"]
pub type sl_wfx_set_mac_address_cnf_t = sl_wfx_set_mac_address_cnf_s;
#[doc = " @brief Request message body for sl_wfx_connect_req_t."]
#[repr(C, packed)]
pub struct sl_wfx_connect_req_body_s {
    #[doc = " @brief Service Set Identifier (SSID) of the network."]
    pub ssid_def: sl_wfx_ssid_def_t,
    #[doc = " @brief Basic Service Set Identifier (BSSID) of the Access Point.\n @details <B>broadcast address</B>: The device will connect to any matching access point.\n          <BR><B>unicast address</B>: The device will only connect to the given Access Point.\n          <BR>See @ref WFM_CONCEPT_BSSID for further details."]
    pub bssid: [u8; 6usize],
    #[doc = " @brief Channel of the Access Point.\n @details <B>0</B>: The device will connect to a matching Access Point on any channel.\n          <BR><B>1 - 13</B>: The device will only connect to a matching Access Point on the given channel."]
    pub channel: u16,
    #[doc = " @brief Security mode of the network.\n @details <B>WFM_SECURITY_MODE_OPEN</B>: The device will only connect to an unsecured Access Point.\n          <BR><B>WFM_SECURITY_MODE_WEP</B>: The device will only connect to a WEP Access Point.\n          <BR><B>WFM_SECURITY_MODE_WPA2_WPA1_PSK</B>: The device will only connect to a WPA-Personal or a WPA2-Personal Access Point.\n          <BR><B>WFM_SECURITY_MODE_WPA2_PSK</B>: The device will only connect to a WPA2-Personal access point.\n          <BR><B>WFM_SECURITY_MODE_WPA3_SAE</B>: The device will only connect to a WPA3-SAE access point.\n          <BR>See wfm_security_mode for enumeration values."]
    pub security_mode: u8,
    #[doc = " @brief Boolean option to prevent roaming between access points.\n @details <B>0</B>: The device may roam to any matching access point within the same network.\n          <BR><B>1</B>: The device will not roam to any other access point."]
    pub prevent_roaming: u8,
    #[doc = " @brief Protected Management Frames (PMF) mode.\n @details <B>WFM_MGMT_FRAME_PROTECTION_DISABLED</B>: The device will not use PMF even if supported by the access point.\n          <BR><B>WFM_MGMT_FRAME_PROTECTION_OPTIONAL</B>: The device will use PMF if supported by the access point.\n          <BR><B>WFM_MGMT_FRAME_PROTECTION_MANDATORY</B>: The device will only connect to an access point supporting PMF.\n          <BR>See wfm_mgmt_frame_protection for enumeration values."]
    pub mgmt_frame_protection: u16,
    #[doc = " @brief Length of the network password.\n @details <B>0 - 64</B>: The amount of bytes."]
    pub password_length: u16,
    #[doc = " @brief Password of the network.\n @details <B>64-bit WEP key</B>: 5 bytes in ASCII format or 10 bytes in HEX format.\n          <BR><B>128-bit WEP key</B>: 13 bytes in ASCII format or 26 bytes in HEX format.\n          <BR><B>WPA pass phrase</B>: 8 - 63 bytes in ASCII format.\n          <BR><B>WPA PMK</B>: 64 bytes in HEX format.\n          <BR>See @ref WFM_CONCEPT_PASSWORD for further details."]
    pub password: [u8; 64usize],
    #[doc = " @brief Length of vendor-specific Information Element (IE) data.\n @details <B>0 - 255</B>: The amount of bytes."]
    pub ie_data_length: u16,
    #[doc = " @brief Vendor-specific IE data added to the 802.11 Association Request frames.\n @details The IE data must be in 802.11 Vendor-Specific Element format.\n          It may contain multiple concatenated IEs, up to the maximum length.\n          <BR>See @ref WFM_CONCEPT_VENDOR_IE for further details."]
    pub ie_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_connect_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_connect_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_connect_req_body_s>(),
        116usize,
        concat!("Size of: ", stringify!(sl_wfx_connect_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_connect_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_connect_req_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssid_def) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_req_body_s),
            "::",
            stringify!(ssid_def)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bssid) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_req_body_s),
            "::",
            stringify!(bssid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_req_body_s),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).security_mode) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_req_body_s),
            "::",
            stringify!(security_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prevent_roaming) as usize - ptr as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_req_body_s),
            "::",
            stringify!(prevent_roaming)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mgmt_frame_protection) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_req_body_s),
            "::",
            stringify!(mgmt_frame_protection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).password_length) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_req_body_s),
            "::",
            stringify!(password_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).password) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_req_body_s),
            "::",
            stringify!(password)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ie_data_length) as usize - ptr as usize },
        114usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_req_body_s),
            "::",
            stringify!(ie_data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ie_data) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_req_body_s),
            "::",
            stringify!(ie_data)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_connect_req_t."]
pub type sl_wfx_connect_req_body_t = sl_wfx_connect_req_body_s;
#[doc = " @brief Request message for connecting to a Wi-Fi network.\n @details The host can use this request to initiate a connection to a Wi-Fi network.\n          An ongoing connection attempt can be canceled by sending sl_wfx_disconnect_req_t\n          message. Completion of the connection request will be signaled by sl_wfx_connect_ind_t\n          message. It may take up to 10 seconds to receive the message.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | Yes             |\n          | station        | No              |\n          | AP             | No              |\n          <BR>\n @ingroup WFM_GROUP_MODE_IDLE"]
#[repr(C, packed)]
pub struct sl_wfx_connect_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_connect_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_connect_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_connect_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_connect_req_s>(),
        120usize,
        concat!("Size of: ", stringify!(sl_wfx_connect_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_connect_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_connect_req_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message for connecting to a Wi-Fi network.\n @details The host can use this request to initiate a connection to a Wi-Fi network.\n          An ongoing connection attempt can be canceled by sending sl_wfx_disconnect_req_t\n          message. Completion of the connection request will be signaled by sl_wfx_connect_ind_t\n          message. It may take up to 10 seconds to receive the message.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | Yes             |\n          | station        | No              |\n          | AP             | No              |\n          <BR>\n @ingroup WFM_GROUP_MODE_IDLE"]
pub type sl_wfx_connect_req_t = sl_wfx_connect_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_connect_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_connect_cnf_body_s {
    #[doc = " @brief Status of the connection request.\n @details <B>WFM_STATUS_SUCCESS</B>: the connection request was accepted. It will be completed by sl_wfx_connect_ind_t.\n          <BR><B>any other value</B>: the connection request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_connect_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_connect_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_connect_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_connect_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_connect_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_connect_cnf_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_connect_cnf_t."]
pub type sl_wfx_connect_cnf_body_t = sl_wfx_connect_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_connect_req_t.\n @ingroup WFM_GROUP_MODE_IDLE"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_connect_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_connect_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_connect_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_connect_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_connect_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_connect_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_connect_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_connect_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_connect_req_t.\n @ingroup WFM_GROUP_MODE_IDLE"]
pub type sl_wfx_connect_cnf_t = sl_wfx_connect_cnf_s;
#[doc = " @brief Indication message body for sl_wfx_connect_ind_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_connect_ind_body_s {
    #[doc = " @brief Status of the connection request.\n @details <B>WFM_STATUS_SUCCESS</B>: the connection request was completed successfully.\n          <BR><B>any other value</B>: the connection request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
    #[doc = " @brief MAC address of the connected access point."]
    pub mac: [u8; 6usize],
    #[doc = " @brief Channel of the connected access point.\n @details <B>1 - 13</B>: Channel number."]
    pub channel: u16,
    #[doc = " @brief Beacon Interval of the connected access point."]
    pub beacon_interval: u8,
    #[doc = " @brief DTIM period of the connected access point.\n @details <B>1 - 255</B>: DTIM period."]
    pub dtim_period: u8,
    #[doc = " @brief Maximum PHY data rate supported by the connection.\n @details See sl_wfx_rate_index_t for enumeration values."]
    pub max_phy_rate: u16,
}
#[test]
fn bindgen_test_layout_sl_wfx_connect_ind_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_connect_ind_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_connect_ind_body_s>(),
        16usize,
        concat!("Size of: ", stringify!(sl_wfx_connect_ind_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_connect_ind_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_connect_ind_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_ind_body_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_ind_body_s),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_ind_body_s),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beacon_interval) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_ind_body_s),
            "::",
            stringify!(beacon_interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dtim_period) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_ind_body_s),
            "::",
            stringify!(dtim_period)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_phy_rate) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_ind_body_s),
            "::",
            stringify!(max_phy_rate)
        )
    );
}
#[doc = " @brief Indication message body for sl_wfx_connect_ind_t."]
pub type sl_wfx_connect_ind_body_t = sl_wfx_connect_ind_body_s;
#[doc = " @brief Indication message used to signal the completion of a connection operation.\n @details The device will send this indication to signal the connection request initiated\n          with sl_wfx_connect_req_t has been completed. The indication is also sent when\n          the device autonomously roams to another access point.\n @ingroup WFM_GROUP_MODE_IDLE"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_connect_ind_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Indication message body."]
    pub body: sl_wfx_connect_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_connect_ind_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_connect_ind_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_connect_ind_s>(),
        20usize,
        concat!("Size of: ", stringify!(sl_wfx_connect_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_connect_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_connect_ind_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_ind_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Indication message used to signal the completion of a connection operation.\n @details The device will send this indication to signal the connection request initiated\n          with sl_wfx_connect_req_t has been completed. The indication is also sent when\n          the device autonomously roams to another access point.\n @ingroup WFM_GROUP_MODE_IDLE"]
pub type sl_wfx_connect_ind_t = sl_wfx_connect_ind_s;
#[doc = " @brief General Message header structure\n"]
pub type sl_wfx_disconnect_req_t = sl_wfx_header_t;
#[doc = " @brief Confirmation message body for sl_wfx_disconnect_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_disconnect_cnf_body_s {
    #[doc = " @brief Status of the disconnection request.\n @details <B>WFM_STATUS_SUCCESS</B>: the disconnection request was accepted. It will be completed by sl_wfx_disconnect_ind_t.\n          <BR><B>any other value</B>: the disconnection request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_disconnect_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_disconnect_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_disconnect_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_disconnect_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_disconnect_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_disconnect_cnf_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_disconnect_cnf_t."]
pub type sl_wfx_disconnect_cnf_body_t = sl_wfx_disconnect_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_disconnect_req_t.\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_disconnect_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_disconnect_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_disconnect_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_disconnect_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_disconnect_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_disconnect_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_disconnect_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_disconnect_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_disconnect_req_t.\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_disconnect_cnf_t = sl_wfx_disconnect_cnf_s;
#[doc = " @brief Indication message body for sl_wfx_disconnect_ind_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_disconnect_ind_body_s {
    #[doc = " @brief MAC address of the access point."]
    pub mac: [u8; 6usize],
    #[doc = " @brief Reason for disconnection.\n @details <B>WFM_DISCONNECTED_REASON_UNSPECIFIED</B>: The device disconnected because of an internal error.\n          <BR><B>WFM_DISCONNECTED_REASON_AP_LOST</B>: The device lost the AP beacons for too long.\n          <BR><B>WFM_DISCONNECTED_REASON_REJECTED</B>: The device was disconnected by the AP.\n          <BR><B>WFM_DISCONNECTED_REASON_LEAVING_BSS</B>: Disconnection was requested through the device API.\n          <BR><B>WFM_DISCONNECTED_REASON_WPA_COUNTERMEASURES</B>: WPA countermeasures triggered a disconnection\n          <BR>See sl_wfx_disconnected_reason_t for enumeration values."]
    pub reason: u16,
}
#[test]
fn bindgen_test_layout_sl_wfx_disconnect_ind_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_disconnect_ind_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_disconnect_ind_body_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_disconnect_ind_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_disconnect_ind_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_disconnect_ind_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_ind_body_s),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reason) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_ind_body_s),
            "::",
            stringify!(reason)
        )
    );
}
#[doc = " @brief Indication message body for sl_wfx_disconnect_ind_t."]
pub type sl_wfx_disconnect_ind_body_t = sl_wfx_disconnect_ind_body_s;
#[doc = " @brief Indication message used to signal the completion of a disconnection operation.\n @details The device will send this indication to signal the disconnection request initiated\n          with sl_wfx_disconnect_req_t has been completed. The indication is also sent when\n          the device has lost the connection to an access point and has been unable to regain it.\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_disconnect_ind_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Indication message body."]
    pub body: sl_wfx_disconnect_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_disconnect_ind_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_disconnect_ind_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_disconnect_ind_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_disconnect_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_disconnect_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_disconnect_ind_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_ind_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Indication message used to signal the completion of a disconnection operation.\n @details The device will send this indication to signal the disconnection request initiated\n          with sl_wfx_disconnect_req_t has been completed. The indication is also sent when\n          the device has lost the connection to an access point and has been unable to regain it.\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_disconnect_ind_t = sl_wfx_disconnect_ind_s;
#[doc = " @brief General Message header structure\n"]
pub type sl_wfx_get_signal_strength_req_t = sl_wfx_header_t;
#[doc = " @brief Confirmation message body for sl_wfx_get_signal_strength_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_get_signal_strength_cnf_body_s {
    #[doc = " @brief Status of the get request.\n @details <B>WFM_STATUS_SUCCESS</B>: the get request was completed.\n          <BR><B>any other value</B>: the get request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
    #[doc = " @brief Received Channel Power Indicator (RCPI) of the connection.\n @details See @ref WFM_CONCEPT_RCPI for further details."]
    pub rcpi: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_get_signal_strength_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_get_signal_strength_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_get_signal_strength_cnf_body_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_get_signal_strength_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_get_signal_strength_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_get_signal_strength_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_signal_strength_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcpi) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_signal_strength_cnf_body_s),
            "::",
            stringify!(rcpi)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_get_signal_strength_cnf_t."]
pub type sl_wfx_get_signal_strength_cnf_body_t = sl_wfx_get_signal_strength_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_get_signal_strength_req_t.\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_get_signal_strength_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_get_signal_strength_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_get_signal_strength_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_get_signal_strength_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_get_signal_strength_cnf_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_get_signal_strength_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_get_signal_strength_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_get_signal_strength_cnf_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_signal_strength_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_signal_strength_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_get_signal_strength_req_t.\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_get_signal_strength_cnf_t = sl_wfx_get_signal_strength_cnf_s;
#[doc = " @brief Request message body for sl_wfx_set_pm_mode_req_t.\n @details\n          | Field          | Default value      | Reset to default value |\n          |:---------------|:-------------------|:-----------------------|\n          | power_mode      | WFM_PM_MODE_ACTIVE | when interface stopped |\n          | listen_interval | 0                  | when interface stopped |\n          <BR>"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_pm_mode_req_body_s {
    #[doc = " @brief Power management mode.\n @details <B>WFM_PM_MODE_ACTIVE</B>: the device will not use Wi-Fi power management mechanisms.\n          <BR><B>WFM_PM_MODE_BEACON</B>: the device will wake-up on beacons.\n          <BR><B>WFM_PM_MODE_DTIM</B>: the device will wake-up on DTIMs.\n          <BR>See wfm_pm_mode for enumeration values."]
    pub power_mode: u8,
    #[doc = " @brief Power save polling strategy.\n @details <B>WFM_PM_POLL_UAPSD</B>: the device will use U-APSD (default).\n          <BR><B>WFM_PM_POLL_FAST_PS</B>: the device will use Fast Power Save.\n          <BR>See WFM_PM_POLL for enumeration values."]
    pub polling_strategy: u8,
    #[doc = " @brief Number of beacons/DTIMs to skip while sleeping.\n @details <B>0</B>: wake-up on every beacon/DTIM.\n          <BR><B>1 - 600</B>: the number of beacon/DTIMs to skip.\n          <BR>See @ref WFM_CONCEPT_PM for further details."]
    pub listen_interval: u16,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_pm_mode_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_pm_mode_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_pm_mode_req_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_set_pm_mode_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_pm_mode_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_pm_mode_req_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).power_mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_pm_mode_req_body_s),
            "::",
            stringify!(power_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).polling_strategy) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_pm_mode_req_body_s),
            "::",
            stringify!(polling_strategy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).listen_interval) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_pm_mode_req_body_s),
            "::",
            stringify!(listen_interval)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_set_pm_mode_req_t.\n @details\n          | Field          | Default value      | Reset to default value |\n          |:---------------|:-------------------|:-----------------------|\n          | power_mode      | WFM_PM_MODE_ACTIVE | when interface stopped |\n          | listen_interval | 0                  | when interface stopped |\n          <BR>"]
pub type sl_wfx_set_pm_mode_req_body_t = sl_wfx_set_pm_mode_req_body_s;
#[doc = " @brief Request message for setting the power management mode of the device.\n @details The host can use this request to enable or disable Wi-Fi power management mechanisms.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | Yes             |\n          | AP             | No              |\n          <BR>\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_pm_mode_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_set_pm_mode_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_pm_mode_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_pm_mode_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_pm_mode_req_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_pm_mode_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_pm_mode_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_pm_mode_req_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_pm_mode_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_pm_mode_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message for setting the power management mode of the device.\n @details The host can use this request to enable or disable Wi-Fi power management mechanisms.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | Yes             |\n          | AP             | No              |\n          <BR>\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_set_pm_mode_req_t = sl_wfx_set_pm_mode_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_pm_mode_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_pm_mode_cnf_body_s {
    #[doc = " @brief Status of the power management request.\n @details <B>WFM_STATUS_SUCCESS</B>: the power management request was completed.\n          <BR><B>any other value</B>: the power management request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_pm_mode_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_pm_mode_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_pm_mode_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_set_pm_mode_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_pm_mode_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_pm_mode_cnf_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_pm_mode_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_set_pm_mode_cnf_t."]
pub type sl_wfx_set_pm_mode_cnf_body_t = sl_wfx_set_pm_mode_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_pm_mode_req_t.\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_pm_mode_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_set_pm_mode_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_pm_mode_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_pm_mode_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_pm_mode_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_pm_mode_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_pm_mode_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_pm_mode_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_pm_mode_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_pm_mode_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_set_pm_mode_req_t.\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_set_pm_mode_cnf_t = sl_wfx_set_pm_mode_cnf_s;
#[doc = " @brief General Message header structure\n"]
pub type sl_wfx_ps_mode_error_ind_t = sl_wfx_header_t;
#[doc = " @brief Request message body for sl_wfx_start_ap_req_t."]
#[repr(C, packed)]
pub struct sl_wfx_start_ap_req_body_s {
    #[doc = " @brief Service Set Identifier (SSID) of the network."]
    pub ssid_def: sl_wfx_ssid_def_t,
    #[doc = " @brief Boolean option to hide the network.\n @details <B>0</B>: The device will advertise the SSID of the network to any near-by stations.\n          <BR><B>1</B>: The device will hide the SSID of the network and will only respond\n                        to stations that specify the SSID.\n          <BR>See @ref WFM_CONCEPT_HIDDEN for further details."]
    pub hidden_ssid: u8,
    #[doc = " @brief Boolean option to isolate connected clients from each other.\n @details <B>0</B>: The device will allow connected clients to communicate with each other.\n          <BR><B>1</B>: The device will prevent multiple connected clients from communicating.\n          <BR>Regardless of the value, the connected stations will always be able to communicate with the device.\n          <BR>See @ref WFM_CONCEPT_ISOLATION for further details."]
    pub client_isolation: u8,
    #[doc = " @brief Security mode of the Access Point.\n @details <B>WFM_SECURITY_MODE_OPEN</B>: The device will only allow unsecured connections.\n          <BR><B>WFM_SECURITY_MODE_WEP</B>: The device will only allow WEP connections.\n          <BR><B>WFM_SECURITY_MODE_WPA2_WPA1_PSK</B>: The device will only allow WPA-Personal and WPA2-Personal connections.\n          <BR><B>WFM_SECURITY_MODE_WPA2_PSK</B>: The device will only allow WPA2-Personal connections.\n          <BR><B>WFM_SECURITY_MODE_WPA3_SAE</B>: Unsupported in AP mode\n          <BR>See wfm_security_mode for enumeration values."]
    pub security_mode: u8,
    #[doc = " @brief Protected Management Frames (PMF) mode.\n @details <B>WFM_MGMT_FRAME_PROTECTION_DISABLED</B>: The device will not use PMF even if supported by the connecting station.\n          <BR><B>WFM_MGMT_FRAME_PROTECTION_OPTIONAL</B>: The device will use PMF if supported by the connecting station.\n          <BR><B>WFM_MGMT_FRAME_PROTECTION_MANDATORY</B>: The device will only allow connecting stations that support PMF.\n          <BR>See wfm_mgmt_frame_protection for enumeration values."]
    pub mgmt_frame_protection: u8,
    #[doc = " @brief Channel of the Access Point.\n @details <B>1 - 13</B>: The device will create the access point on the given channel."]
    pub channel: u16,
    #[doc = " @brief Length of the network password.\n @details <B>0 - 64</B>: The amount of bytes."]
    pub password_length: u16,
    #[doc = " @brief Password of the network.\n @details <B>64-bit WEP key</B>: 5 bytes in ASCII format or 10 bytes in HEX format.\n          <BR><B>128-bit WEP key</B>: 13 bytes in ASCII format or 26 bytes in HEX format.\n          <BR><B>WPA pass phrase</B>: 8 - 63 bytes in ASCII format.\n          <BR><B>WPA PMK</B>: 64 bytes in HEX format.\n          <BR>See @ref WFM_CONCEPT_PASSWORD for further details."]
    pub password: [u8; 64usize],
    #[doc = " @brief Length of vendor-specific Information Element (IE) data in 802.11 Beacon frames.\n @details <B>0 - 255</B>: The amount of bytes."]
    pub beacon_ie_data_length: u16,
    #[doc = " @brief Length of vendor-specific Information Element (IE) data in 802.11 Probe Response frames.\n @details <B>0 - 255</B>: The amount of bytes."]
    pub probe_resp_ie_data_length: u16,
    #[doc = " @brief Vendor-specific IE data added to the 802.11 Beacon frames and Probe Response frames.\n @details The IE data must be in 802.11 Vendor-Specific Element format. It may contain\n          multiple concatenated IEs, up to the maximum length. First part of the IE data,\n          up to the amount of bytes specified in BeaconIeDataLength, is added to the Beacon\n          frames. The remaining part whose length is defined in ProbeRespIeDataLength is added\n          to the Probe Response frames.\n          <BR>See @ref WFM_CONCEPT_VENDOR_IE for further details."]
    pub ie_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_start_ap_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_start_ap_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_start_ap_req_body_s>(),
        112usize,
        concat!("Size of: ", stringify!(sl_wfx_start_ap_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_start_ap_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_start_ap_req_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssid_def) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_req_body_s),
            "::",
            stringify!(ssid_def)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hidden_ssid) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_req_body_s),
            "::",
            stringify!(hidden_ssid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).client_isolation) as usize - ptr as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_req_body_s),
            "::",
            stringify!(client_isolation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).security_mode) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_req_body_s),
            "::",
            stringify!(security_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mgmt_frame_protection) as usize - ptr as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_req_body_s),
            "::",
            stringify!(mgmt_frame_protection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_req_body_s),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).password_length) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_req_body_s),
            "::",
            stringify!(password_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).password) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_req_body_s),
            "::",
            stringify!(password)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beacon_ie_data_length) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_req_body_s),
            "::",
            stringify!(beacon_ie_data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).probe_resp_ie_data_length) as usize - ptr as usize },
        110usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_req_body_s),
            "::",
            stringify!(probe_resp_ie_data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ie_data) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_req_body_s),
            "::",
            stringify!(ie_data)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_start_ap_req_t."]
pub type sl_wfx_start_ap_req_body_t = sl_wfx_start_ap_req_body_s;
#[doc = " @brief Request message for starting a Wi-Fi network.\n @details The host can use this request to initiate a Wi-Fi network.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | Yes             |\n          | station        | No              |\n          | AP             | No              |\n          <BR>\n @ingroup WFM_GROUP_MODE_IDLE"]
#[repr(C, packed)]
pub struct sl_wfx_start_ap_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_start_ap_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_start_ap_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_start_ap_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_start_ap_req_s>(),
        116usize,
        concat!("Size of: ", stringify!(sl_wfx_start_ap_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_start_ap_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_start_ap_req_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message for starting a Wi-Fi network.\n @details The host can use this request to initiate a Wi-Fi network.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | Yes             |\n          | station        | No              |\n          | AP             | No              |\n          <BR>\n @ingroup WFM_GROUP_MODE_IDLE"]
pub type sl_wfx_start_ap_req_t = sl_wfx_start_ap_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_start_ap_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_start_ap_cnf_body_s {
    #[doc = " @brief Status of the start request.\n @details <B>WFM_STATUS_SUCCESS</B>: the start request was accepted. It will be completed by sl_wfx_start_ap_ind_t.\n          <BR><B>any other value</B>: the start request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_start_ap_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_start_ap_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_start_ap_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_start_ap_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_start_ap_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_start_ap_cnf_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_start_ap_cnf_t."]
pub type sl_wfx_start_ap_cnf_body_t = sl_wfx_start_ap_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_start_ap_req_t.\n @ingroup WFM_GROUP_MODE_IDLE"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_start_ap_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_start_ap_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_start_ap_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_start_ap_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_start_ap_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_start_ap_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_start_ap_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_start_ap_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_start_ap_req_t.\n @ingroup WFM_GROUP_MODE_IDLE"]
pub type sl_wfx_start_ap_cnf_t = sl_wfx_start_ap_cnf_s;
#[doc = " @brief Indication message body for sl_wfx_start_ap_ind_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_start_ap_ind_body_s {
    #[doc = " @brief Status of the start request.\n @details <B>WFM_STATUS_SUCCESS</B>: the start request was completed successfully.\n          <BR><B>any other value</B>: the start request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_start_ap_ind_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_start_ap_ind_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_start_ap_ind_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_start_ap_ind_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_start_ap_ind_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_start_ap_ind_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_ind_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Indication message body for sl_wfx_start_ap_ind_t."]
pub type sl_wfx_start_ap_ind_body_t = sl_wfx_start_ap_ind_body_s;
#[doc = " @brief Indication message used to signal the completion of a start request.\n @details The device will send this indication to signal the start request initiated\n          with sl_wfx_start_ap_req_t has been completed.\n @ingroup WFM_GROUP_MODE_IDLE"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_start_ap_ind_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Indication message body."]
    pub body: sl_wfx_start_ap_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_start_ap_ind_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_start_ap_ind_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_start_ap_ind_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_start_ap_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_start_ap_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_start_ap_ind_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_ind_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Indication message used to signal the completion of a start request.\n @details The device will send this indication to signal the start request initiated\n          with sl_wfx_start_ap_req_t has been completed.\n @ingroup WFM_GROUP_MODE_IDLE"]
pub type sl_wfx_start_ap_ind_t = sl_wfx_start_ap_ind_s;
#[doc = " @brief Request message body for sl_wfx_update_ap_req_t."]
#[repr(C, packed)]
pub struct sl_wfx_update_ap_req_body_s {
    #[doc = " @brief Length of vendor-specific Information Element (IE) data in 802.11 Beacon frames.\n @details <B>0 - 255</B>: The amount of bytes."]
    pub beacon_ie_data_length: u16,
    #[doc = " @brief Length of vendor-specific Information Element (IE) data in 802.11 Probe Response frames.\n @details <B>0 - 255</B>: The amount of bytes."]
    pub probe_resp_ie_data_length: u16,
    #[doc = " @brief Vendor-specific IE data added to the 802.11 Beacon frames and Probe Response frames.\n @details The IE data must be in 802.11 Vendor-Specific Element format. It may contain\n          multiple concatenated IEs, up to the maximum length. First part of the IE data,\n          up to the amount of bytes specified in BeaconIeDataLength, is added to the Beacon\n          frames. The remaining part whose length is defined in ProbeRespIeDataLength is added\n          to the Probe Response frames.\n          <BR>See @ref WFM_CONCEPT_VENDOR_IE for further details."]
    pub ie_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_update_ap_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_update_ap_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_update_ap_req_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_update_ap_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_update_ap_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_update_ap_req_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beacon_ie_data_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_update_ap_req_body_s),
            "::",
            stringify!(beacon_ie_data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).probe_resp_ie_data_length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_update_ap_req_body_s),
            "::",
            stringify!(probe_resp_ie_data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ie_data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_update_ap_req_body_s),
            "::",
            stringify!(ie_data)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_update_ap_req_t."]
pub type sl_wfx_update_ap_req_body_t = sl_wfx_update_ap_req_body_s;
#[doc = " @brief Request message for updating parameters of the started Wi-Fi network.\n @details The host can use this request to update parameters of the started Wi-Fi network.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | No              |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
pub struct sl_wfx_update_ap_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_update_ap_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_update_ap_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_update_ap_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_update_ap_req_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_update_ap_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_update_ap_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_update_ap_req_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_update_ap_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_update_ap_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message for updating parameters of the started Wi-Fi network.\n @details The host can use this request to update parameters of the started Wi-Fi network.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | No              |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_update_ap_req_t = sl_wfx_update_ap_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_update_ap_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_update_ap_cnf_body_s {
    #[doc = " @brief Status of the update request.\n @details <B>WFM_STATUS_SUCCESS</B>: the update request was completed.\n          <BR><B>any other value</B>: the update request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_update_ap_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_update_ap_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_update_ap_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_update_ap_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_update_ap_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_update_ap_cnf_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_update_ap_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_update_ap_cnf_t."]
pub type sl_wfx_update_ap_cnf_body_t = sl_wfx_update_ap_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_update_ap_req_t.\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_update_ap_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_update_ap_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_update_ap_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_update_ap_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_update_ap_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_update_ap_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_update_ap_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_update_ap_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_update_ap_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_update_ap_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_update_ap_req_t.\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_update_ap_cnf_t = sl_wfx_update_ap_cnf_s;
#[doc = " @brief General Message header structure\n"]
pub type sl_wfx_stop_ap_req_t = sl_wfx_header_t;
#[doc = " @brief Confirmation message body for sl_wfx_stop_ap_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_stop_ap_cnf_body_s {
    #[doc = " @brief Status of the stop request.\n @details <B>WFM_STATUS_SUCCESS</B>: the stop request was accepted. It will be completed by sl_wfx_stop_ap_ind_t.\n          <BR><B>any other value</B>: the stop request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_stop_ap_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_stop_ap_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_stop_ap_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_stop_ap_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_stop_ap_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_stop_ap_cnf_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_stop_ap_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_stop_ap_cnf_t."]
pub type sl_wfx_stop_ap_cnf_body_t = sl_wfx_stop_ap_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_stop_ap_req_t.\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_stop_ap_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_stop_ap_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_stop_ap_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_stop_ap_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_stop_ap_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_stop_ap_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_stop_ap_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_stop_ap_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_stop_ap_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_stop_ap_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_stop_ap_req_t.\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_stop_ap_cnf_t = sl_wfx_stop_ap_cnf_s;
#[doc = " @brief General Message header structure\n"]
pub type sl_wfx_stop_ap_ind_t = sl_wfx_header_t;
#[doc = " @brief Indication message body for sl_wfx_ap_client_connected_ind_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_ap_client_connected_ind_body_s {
    #[doc = " @brief MAC address of the station."]
    pub mac: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_ap_client_connected_ind_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_ap_client_connected_ind_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ap_client_connected_ind_body_s>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_ap_client_connected_ind_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ap_client_connected_ind_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_ap_client_connected_ind_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_client_connected_ind_body_s),
            "::",
            stringify!(mac)
        )
    );
}
#[doc = " @brief Indication message body for sl_wfx_ap_client_connected_ind_t."]
pub type sl_wfx_ap_client_connected_ind_body_t = sl_wfx_ap_client_connected_ind_body_s;
#[doc = " @brief Indication message used to signal a connected station.\n @details The device will send this indication to signal a station has connected\n          to the started network.\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_ap_client_connected_ind_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Indication message body."]
    pub body: sl_wfx_ap_client_connected_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_ap_client_connected_ind_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_ap_client_connected_ind_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ap_client_connected_ind_s>(),
        10usize,
        concat!("Size of: ", stringify!(sl_wfx_ap_client_connected_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ap_client_connected_ind_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_ap_client_connected_ind_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_client_connected_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_client_connected_ind_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Indication message used to signal a connected station.\n @details The device will send this indication to signal a station has connected\n          to the started network.\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_ap_client_connected_ind_t = sl_wfx_ap_client_connected_ind_s;
#[doc = " @brief Indication message body for sl_wfx_ap_client_rejected_ind_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_ap_client_rejected_ind_body_s {
    #[doc = " @brief MAC address of the station."]
    pub mac: [u8; 6usize],
    #[doc = " @brief Reason for rejection.\n @details <B>WFM_REASON_TIMEOUT</B>: A timeout occurred during a station connection attempt.\n          <BR><B>WFM_REASON_LEAVING_BSS</B>: The device sent a deauth before completing the connection.\n          <BR><B>WFM_REASON_UNKNOWN_STA</B>: The device received data from a non-connected station.\n          <BR><B>WFM_REASON_AP_FULL</B>: The device was not able to accommodate any more stations.\n          <BR><B>WFM_REASON_AUTHENTICATION_FAILURE</B>: The device did not complete the WPA authentication successfully.\n          <BR>See wfm_reason for enumeration values."]
    pub reason: u16,
}
#[test]
fn bindgen_test_layout_sl_wfx_ap_client_rejected_ind_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_ap_client_rejected_ind_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ap_client_rejected_ind_body_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_ap_client_rejected_ind_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ap_client_rejected_ind_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_ap_client_rejected_ind_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_client_rejected_ind_body_s),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reason) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_client_rejected_ind_body_s),
            "::",
            stringify!(reason)
        )
    );
}
#[doc = " @brief Indication message body for sl_wfx_ap_client_rejected_ind_t."]
pub type sl_wfx_ap_client_rejected_ind_body_t = sl_wfx_ap_client_rejected_ind_body_s;
#[doc = " @brief Indication message used to signal a rejected connection attempt from a station.\n @details The device will send this indication to signal a station has attempted\n          connection to the started network and was rejected by the device.\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_ap_client_rejected_ind_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Indication message body."]
    pub body: sl_wfx_ap_client_rejected_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_ap_client_rejected_ind_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_ap_client_rejected_ind_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ap_client_rejected_ind_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_ap_client_rejected_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ap_client_rejected_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_ap_client_rejected_ind_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_client_rejected_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_client_rejected_ind_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Indication message used to signal a rejected connection attempt from a station.\n @details The device will send this indication to signal a station has attempted\n          connection to the started network and was rejected by the device.\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_ap_client_rejected_ind_t = sl_wfx_ap_client_rejected_ind_s;
#[doc = " @brief Request message body for sl_wfx_disconnect_ap_client_req_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_disconnect_ap_client_req_body_s {
    #[doc = " @brief MAC address of the station."]
    pub mac: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_disconnect_ap_client_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_disconnect_ap_client_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_disconnect_ap_client_req_body_s>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_disconnect_ap_client_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_disconnect_ap_client_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_disconnect_ap_client_req_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_ap_client_req_body_s),
            "::",
            stringify!(mac)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_disconnect_ap_client_req_t."]
pub type sl_wfx_disconnect_ap_client_req_body_t = sl_wfx_disconnect_ap_client_req_body_s;
#[doc = " @brief Request message for disconnecting a client from the started Wi-Fi network.\n @details The host can use this request to disconnect a client from the started Wi-Fi network.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | No              |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_disconnect_ap_client_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_disconnect_ap_client_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_disconnect_ap_client_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_disconnect_ap_client_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_disconnect_ap_client_req_s>(),
        10usize,
        concat!("Size of: ", stringify!(sl_wfx_disconnect_ap_client_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_disconnect_ap_client_req_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_disconnect_ap_client_req_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_ap_client_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_ap_client_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message for disconnecting a client from the started Wi-Fi network.\n @details The host can use this request to disconnect a client from the started Wi-Fi network.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | No              |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_disconnect_ap_client_req_t = sl_wfx_disconnect_ap_client_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_disconnect_ap_client_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_disconnect_ap_client_cnf_body_s {
    #[doc = " @brief Status of the disconnect request.\n @details <B>WFM_STATUS_SUCCESS</B>: the disconnect request was completed.\n          <BR><B>any other value</B>: the disconnect request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_disconnect_ap_client_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_disconnect_ap_client_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_disconnect_ap_client_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_disconnect_ap_client_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_disconnect_ap_client_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_disconnect_ap_client_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_ap_client_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_disconnect_ap_client_cnf_t."]
pub type sl_wfx_disconnect_ap_client_cnf_body_t = sl_wfx_disconnect_ap_client_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_disconnect_ap_client_req_t.\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_disconnect_ap_client_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_disconnect_ap_client_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_disconnect_ap_client_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_disconnect_ap_client_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_disconnect_ap_client_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_disconnect_ap_client_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_disconnect_ap_client_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_disconnect_ap_client_cnf_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_ap_client_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_ap_client_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_disconnect_ap_client_req_t.\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_disconnect_ap_client_cnf_t = sl_wfx_disconnect_ap_client_cnf_s;
#[doc = " @brief Indication message body for sl_wfx_ap_client_disconnected_ind_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_ap_client_disconnected_ind_body_s {
    #[doc = " @brief MAC address of the station."]
    pub mac: [u8; 6usize],
    #[doc = " @brief Reason for disconnection.\n @details <B>WFM_REASON_LEAVING_BSS</B>: The station was disconnected or it disconnected on its own.\n          <BR>See wfm_reason for enumeration values."]
    pub reason: u16,
}
#[test]
fn bindgen_test_layout_sl_wfx_ap_client_disconnected_ind_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_ap_client_disconnected_ind_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ap_client_disconnected_ind_body_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_ap_client_disconnected_ind_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ap_client_disconnected_ind_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_ap_client_disconnected_ind_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_client_disconnected_ind_body_s),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reason) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_client_disconnected_ind_body_s),
            "::",
            stringify!(reason)
        )
    );
}
#[doc = " @brief Indication message body for sl_wfx_ap_client_disconnected_ind_t."]
pub type sl_wfx_ap_client_disconnected_ind_body_t = sl_wfx_ap_client_disconnected_ind_body_s;
#[doc = " @brief Indication message used to signal a disconnected station.\n @details The device will send this indication to signal a station has left\n          the started network.\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_ap_client_disconnected_ind_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Indication message body."]
    pub body: sl_wfx_ap_client_disconnected_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_ap_client_disconnected_ind_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_ap_client_disconnected_ind_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ap_client_disconnected_ind_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_ap_client_disconnected_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ap_client_disconnected_ind_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_ap_client_disconnected_ind_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_client_disconnected_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_client_disconnected_ind_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Indication message used to signal a disconnected station.\n @details The device will send this indication to signal a station has left\n          the started network.\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_ap_client_disconnected_ind_t = sl_wfx_ap_client_disconnected_ind_s;
#[doc = " @brief Request message body for sl_wfx_send_frame_req_t."]
#[repr(C, packed)]
pub struct sl_wfx_send_frame_req_body_s {
    #[doc = " @brief Packet type.\n @details <B>0</B>: Data packet with Ethernet II frame header."]
    pub frame_type: u8,
    #[doc = " @brief User Priority level.\n @details <B>0 - 7</B>: 802.1D Priority field value."]
    pub priority: u8,
    #[doc = " @brief Packet ID number.\n @details <B>0 - 65535</B>: Host-assigned unique number for the packet.\n          <BR>The number is returned in the corresponding confirmation message."]
    pub packet_id: u16,
    #[doc = " @brief Length of packet data.\n @details <B>1 - 1604</B>: The amount of bytes."]
    pub packet_data_length: u32,
    #[doc = " @brief Data of the packet.\n @details See @ref WFM_CONCEPT_PACKET for further details."]
    pub packet_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_send_frame_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_send_frame_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_send_frame_req_body_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_send_frame_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_send_frame_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_send_frame_req_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_send_frame_req_body_s),
            "::",
            stringify!(frame_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_send_frame_req_body_s),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).packet_id) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_send_frame_req_body_s),
            "::",
            stringify!(packet_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).packet_data_length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_send_frame_req_body_s),
            "::",
            stringify!(packet_data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).packet_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_send_frame_req_body_s),
            "::",
            stringify!(packet_data)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_send_frame_req_t."]
pub type sl_wfx_send_frame_req_body_t = sl_wfx_send_frame_req_body_s;
#[doc = " @brief Request message for sending a packet to the network.\n @details The host can use this request to send a packet to the network.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | Yes             |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_STA\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
pub struct sl_wfx_send_frame_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_send_frame_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_send_frame_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_send_frame_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_send_frame_req_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_send_frame_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_send_frame_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_send_frame_req_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_send_frame_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_send_frame_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message for sending a packet to the network.\n @details The host can use this request to send a packet to the network.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | Yes             |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_STA\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_send_frame_req_t = sl_wfx_send_frame_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_send_frame_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_send_frame_cnf_body_s {
    #[doc = " @brief Status of the send request.\n @details <B>WFM_STATUS_SUCCESS</B>: the send request was completed.\n          <BR><B>any other value</B>: the send request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
    #[doc = " @brief Packet ID number from the corresponding request."]
    pub packet_id: u16,
    #[doc = " @brief Reserved."]
    pub reserved: u16,
}
#[test]
fn bindgen_test_layout_sl_wfx_send_frame_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_send_frame_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_send_frame_cnf_body_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_send_frame_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_send_frame_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_send_frame_cnf_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_send_frame_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).packet_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_send_frame_cnf_body_s),
            "::",
            stringify!(packet_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_send_frame_cnf_body_s),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_send_frame_cnf_t."]
pub type sl_wfx_send_frame_cnf_body_t = sl_wfx_send_frame_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_send_frame_req_t.\n @ingroup WFM_GROUP_MODE_STA\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_send_frame_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_send_frame_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_send_frame_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_send_frame_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_send_frame_cnf_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_send_frame_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_send_frame_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_send_frame_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_send_frame_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_send_frame_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_send_frame_req_t.\n @ingroup WFM_GROUP_MODE_STA\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_send_frame_cnf_t = sl_wfx_send_frame_cnf_s;
#[doc = " @brief Indication message body for sl_wfx_received_ind_t."]
#[repr(C, packed)]
pub struct sl_wfx_received_ind_body_s {
    #[doc = " @brief Packet type.\n @details <B>0</B>: Data packet with Ethernet II frame header."]
    pub frame_type: u8,
    #[doc = " @brief The amount of padding bytes before the packet data.\n @details <B>0 - 3</B>: The amount of bytes."]
    pub frame_padding: u8,
    #[doc = " @brief Length of packet data excluding the padding bytes.\n @details <B>1 - 2310</B>: The amount of bytes."]
    pub frame_length: u16,
    #[doc = " @brief Packet data, including the padding bytes before the packet data.\n @details See @ref WFM_CONCEPT_PACKET for further details."]
    pub frame: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_received_ind_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_received_ind_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_received_ind_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_received_ind_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_received_ind_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_received_ind_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_received_ind_body_s),
            "::",
            stringify!(frame_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_padding) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_received_ind_body_s),
            "::",
            stringify!(frame_padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_received_ind_body_s),
            "::",
            stringify!(frame_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_received_ind_body_s),
            "::",
            stringify!(frame)
        )
    );
}
#[doc = " @brief Indication message body for sl_wfx_received_ind_t."]
pub type sl_wfx_received_ind_body_t = sl_wfx_received_ind_body_s;
#[doc = " @brief Indication message used to signal a received packet.\n @details The device will send this indication to signal a packet\n          has been received.\n @ingroup WFM_GROUP_MODE_STA\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
pub struct sl_wfx_received_ind_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Indication message body."]
    pub body: sl_wfx_received_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_received_ind_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_received_ind_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_received_ind_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_received_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_received_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_received_ind_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_received_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_received_ind_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Indication message used to signal a received packet.\n @details The device will send this indication to signal a packet\n          has been received.\n @ingroup WFM_GROUP_MODE_STA\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_received_ind_t = sl_wfx_received_ind_s;
#[doc = " @brief Request message body for sl_wfx_start_scan_req_t."]
#[repr(C, packed)]
pub struct sl_wfx_start_scan_req_body_s {
    #[doc = " @brief Scan mode.\n @details <B>WFM_SCAN_MODE_PASSIVE</B>: The device will perform a passive scan.\n          <BR><B>WFM_SCAN_MODE_ACTIVE</B>: The device will perform an active scan.\n          <BR>See wfm_scan_mode for enumeration values.\n          <BR>See @ref WFM_CONCEPT_SCAN for further details."]
    pub scan_mode: u16,
    #[doc = " @brief The amount of specific channels to scan.\n @details <B>0</B>: The device will scan all channels\n          <BR><B>1 - 13</B>: The amount of specific channels to scan."]
    pub channel_list_count: u16,
    #[doc = " @brief The amount of specific SSIDs to scan.\n @details <B>0</B>: The device will perform a broadcast scan\n          <BR><B>1 - 2</B>: The amount of specific SSIDs to scan."]
    pub ssid_list_count: u16,
    #[doc = " @brief Length of vendor-specific Information Element (IE) data in 802.11 Probe Request frames.\n @details <B>0 - 255</B>: The amount of bytes."]
    pub ie_data_length: u16,
    #[doc = " @brief Data for the variable-length scan parameters.\n @details The variable-length scan parameters are concatenated together without any\n          padding between the different parameters.\n @par 1. List of specific channels to scan.\n @details <B>1 - 13</B>: The channel number to scan per byte.\n          <BR>Must contain the same number of channels as specified in ChannelListCount.\n          <BR>See @ref WFM_CONCEPT_SCAN for further details.\n @par 2. List of specific SSIDs to scan.\n @details Must contain the same number of WfmHiSsidDef_t elements as specified in SsidListCount.\n          <BR>This parameter is applicable only for an active scan. See @ref WFM_CONCEPT_SCAN for further details.\n @par 3. Vendor-specific IE data added to the 802.11 Probe Request frames.\n @details The IE data must be in 802.11 Vendor-Specific Element format.\n          It may contain multiple concatenated IEs, up to the maximum length.\n          <BR>This parameter is applicable only for an active scan. See @ref WFM_CONCEPT_VENDOR_IE for further details.\n @par 4. Basic Service Set Identifier (BSSID) to scan.\n @details <B>broadcast address</B>: The device will send Probe Request frames to all devices.\n          <BR><B>unicast address</B>: The device will send Probe Request frames to a specific device.\n          <BR>This parameter is applicable only for an active scan. If not specified, broadcast address is assumed.\n          <BR>Note that an SSID list must be specified when using the unicast address, otherwise the received\n          scan results may contain unexpected additional networks.\n          <BR>See @ref WFM_CONCEPT_BSSID for further details."]
    pub data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_start_scan_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_start_scan_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_start_scan_req_body_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_start_scan_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_start_scan_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_start_scan_req_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_scan_req_body_s),
            "::",
            stringify!(scan_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channel_list_count) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_scan_req_body_s),
            "::",
            stringify!(channel_list_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssid_list_count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_scan_req_body_s),
            "::",
            stringify!(ssid_list_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ie_data_length) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_scan_req_body_s),
            "::",
            stringify!(ie_data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_scan_req_body_s),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_start_scan_req_t."]
pub type sl_wfx_start_scan_req_body_t = sl_wfx_start_scan_req_body_s;
#[doc = " @brief Request message for starting a scan to detect near-by access points.\n @details The host can use this request to start a scan operation to detect near-by access points.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | Yes             |\n          | station        | Yes             |\n          | AP             | No              |\n          <BR>\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
pub struct sl_wfx_start_scan_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_start_scan_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_start_scan_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_start_scan_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_start_scan_req_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_start_scan_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_start_scan_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_start_scan_req_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_scan_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_scan_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message for starting a scan to detect near-by access points.\n @details The host can use this request to start a scan operation to detect near-by access points.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | Yes             |\n          | station        | Yes             |\n          | AP             | No              |\n          <BR>\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_start_scan_req_t = sl_wfx_start_scan_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_start_scan_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_start_scan_cnf_body_s {
    #[doc = " @brief Status of the scan request.\n @details <B>WFM_STATUS_SUCCESS</B>: the scan request was accepted. It will be completed by sl_wfx_scan_complete_ind_t.\n          <BR><B>any other value</B>: the scan request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_start_scan_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_start_scan_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_start_scan_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_start_scan_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_start_scan_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_start_scan_cnf_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_scan_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_start_scan_cnf_t."]
pub type sl_wfx_start_scan_cnf_body_t = sl_wfx_start_scan_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_start_scan_req_t.\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_start_scan_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_start_scan_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_start_scan_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_start_scan_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_start_scan_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_start_scan_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_start_scan_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_start_scan_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_scan_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_scan_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_start_scan_req_t.\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_start_scan_cnf_t = sl_wfx_start_scan_cnf_s;
#[doc = " @brief General Message header structure\n"]
pub type sl_wfx_stop_scan_req_t = sl_wfx_header_t;
#[doc = " @brief Confirmation message body for sl_wfx_stop_scan_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_stop_scan_cnf_body_s {
    #[doc = " @brief Status of the stop request.\n @details <B>WFM_STATUS_SUCCESS</B>: the stop request was accepted. It will be completed by WFM_HI_SCAN_COMPLETE_IND.\n          <BR><B>any other value</B>: the stop request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_stop_scan_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_stop_scan_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_stop_scan_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_stop_scan_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_stop_scan_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_stop_scan_cnf_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_stop_scan_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_stop_scan_cnf_t."]
pub type sl_wfx_stop_scan_cnf_body_t = sl_wfx_stop_scan_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_stop_scan_req_t.\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_stop_scan_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_stop_scan_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_stop_scan_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_stop_scan_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_stop_scan_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_stop_scan_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_stop_scan_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_stop_scan_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_stop_scan_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_stop_scan_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_stop_scan_req_t.\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_stop_scan_cnf_t = sl_wfx_stop_scan_cnf_s;
#[doc = " @brief Indication message body for sl_wfx_scan_result_ind_t."]
#[repr(C, packed)]
pub struct sl_wfx_scan_result_ind_body_s {
    #[doc = " @brief Service Set Identifier (SSID) of the network."]
    pub ssid_def: sl_wfx_ssid_def_t,
    #[doc = " @brief MAC address of the access point."]
    pub mac: [u8; 6usize],
    #[doc = " @brief Channel of the access point.\n @details <B>1 - 13</B>: Channel number."]
    pub channel: u16,
    #[doc = " @brief Security Capabilities of the network."]
    pub security_mode: sl_wfx_security_mode_bitmask_t,
    #[doc = " @brief Reserved."]
    pub reserved1: u8,
    #[doc = " @brief Reserved."]
    pub reserved2: u16,
    #[doc = " @brief Received Channel Power Indicator (RCPI) of the access point.\n @details See @ref WFM_CONCEPT_RCPI for further details."]
    pub rcpi: u16,
    #[doc = " @brief Length of access point Information Element (IE) data in bytes."]
    pub ie_data_length: u16,
    #[doc = " @brief Access point IE data from the 802.11 Beacon or Probe Response frame."]
    pub ie_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_scan_result_ind_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_scan_result_ind_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_scan_result_ind_body_s>(),
        52usize,
        concat!("Size of: ", stringify!(sl_wfx_scan_result_ind_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_scan_result_ind_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_scan_result_ind_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssid_def) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_scan_result_ind_body_s),
            "::",
            stringify!(ssid_def)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_scan_result_ind_body_s),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_scan_result_ind_body_s),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).security_mode) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_scan_result_ind_body_s),
            "::",
            stringify!(security_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_scan_result_ind_body_s),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_scan_result_ind_body_s),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcpi) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_scan_result_ind_body_s),
            "::",
            stringify!(rcpi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ie_data_length) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_scan_result_ind_body_s),
            "::",
            stringify!(ie_data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ie_data) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_scan_result_ind_body_s),
            "::",
            stringify!(ie_data)
        )
    );
}
#[doc = " @brief Indication message body for sl_wfx_scan_result_ind_t."]
pub type sl_wfx_scan_result_ind_body_t = sl_wfx_scan_result_ind_body_s;
#[doc = " @brief Indication message used to signal an access point has been detected.\n @details The device will send this indication to signal an access point has\n          has been detected during the scan operation.\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
pub struct sl_wfx_scan_result_ind_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Indication message body."]
    pub body: sl_wfx_scan_result_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_scan_result_ind_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_scan_result_ind_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_scan_result_ind_s>(),
        56usize,
        concat!("Size of: ", stringify!(sl_wfx_scan_result_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_scan_result_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_scan_result_ind_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_scan_result_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_scan_result_ind_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Indication message used to signal an access point has been detected.\n @details The device will send this indication to signal an access point has\n          has been detected during the scan operation.\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_scan_result_ind_t = sl_wfx_scan_result_ind_s;
#[doc = " @brief Indication message body for sl_wfx_scan_complete_ind_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_scan_complete_ind_body_s {
    #[doc = " @brief Status of the scan request.\n @details <B>WFM_STATUS_SUCCESS</B>: the scan request was completed.\n          <BR><B>any other value</B>: the scan request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_scan_complete_ind_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_scan_complete_ind_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_scan_complete_ind_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_scan_complete_ind_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_scan_complete_ind_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_scan_complete_ind_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_scan_complete_ind_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Indication message body for sl_wfx_scan_complete_ind_t."]
pub type sl_wfx_scan_complete_ind_body_t = sl_wfx_scan_complete_ind_body_s;
#[doc = " @brief Indication message used to signal a scan was completed.\n @details The device will send this indication to signal a scan operation\n          has been completed.\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_scan_complete_ind_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Indication message body."]
    pub body: sl_wfx_scan_complete_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_scan_complete_ind_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_scan_complete_ind_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_scan_complete_ind_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_scan_complete_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_scan_complete_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_scan_complete_ind_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_scan_complete_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_scan_complete_ind_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Indication message used to signal a scan was completed.\n @details The device will send this indication to signal a scan operation\n          has been completed.\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_scan_complete_ind_t = sl_wfx_scan_complete_ind_s;
#[doc = " @brief Request message body for sl_wfx_add_multicast_addr_req_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_multicast_addr_req_body_s {
    #[doc = " @brief MAC address to add.\n @details <B>broadcast address</B>: The device will empty the whitelist and allow all multicast addresses.\n          <BR><B>zero address</B>: The device will empty the whitelist and deny all multicast addresses.\n          <BR><B>multicast address</B>: The device will add the given address to the whitelist.\n          <BR>See @ref WFM_CONCEPT_BSSID for further details."]
    pub mac: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_add_multicast_addr_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_add_multicast_addr_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_multicast_addr_req_body_s>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_add_multicast_addr_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_multicast_addr_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_add_multicast_addr_req_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_multicast_addr_req_body_s),
            "::",
            stringify!(mac)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_add_multicast_addr_req_t."]
pub type sl_wfx_add_multicast_addr_req_body_t = sl_wfx_add_multicast_addr_req_body_s;
#[doc = " @brief Request message for adding a multicast address to the multicast filter whitelist.\n @details The host can use this request to add a multicast address to the multicast filter\n          whitelist. When the first address is added the whitelist, the device will discard\n          all multicast frames whose destination address does not match any of the addresses\n          on the list. The default state is to allow all multicast addresses. The whitelist\n          is reset to the default state when the interface is reset. Up to 8 multicast addresses\n          may be added.\n          <BR>See @ref WFM_CONCEPT_FILTERING for further details.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | Yes             |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_STA\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_multicast_addr_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_add_multicast_addr_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_add_multicast_addr_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_add_multicast_addr_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_multicast_addr_req_s>(),
        10usize,
        concat!("Size of: ", stringify!(sl_wfx_add_multicast_addr_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_multicast_addr_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_add_multicast_addr_req_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_multicast_addr_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_multicast_addr_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message for adding a multicast address to the multicast filter whitelist.\n @details The host can use this request to add a multicast address to the multicast filter\n          whitelist. When the first address is added the whitelist, the device will discard\n          all multicast frames whose destination address does not match any of the addresses\n          on the list. The default state is to allow all multicast addresses. The whitelist\n          is reset to the default state when the interface is reset. Up to 8 multicast addresses\n          may be added.\n          <BR>See @ref WFM_CONCEPT_FILTERING for further details.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | Yes             |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_STA\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_add_multicast_addr_req_t = sl_wfx_add_multicast_addr_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_add_multicast_addr_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_multicast_addr_cnf_body_s {
    #[doc = " @brief Status of the add request.\n @details <B>WFM_STATUS_SUCCESS</B>: the add request was completed successfully.\n          <BR><B>any other value</B>: the add request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_add_multicast_addr_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_add_multicast_addr_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_multicast_addr_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_add_multicast_addr_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_multicast_addr_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_add_multicast_addr_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_multicast_addr_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_add_multicast_addr_cnf_t."]
pub type sl_wfx_add_multicast_addr_cnf_body_t = sl_wfx_add_multicast_addr_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_add_multicast_addr_req_t.\n @ingroup WFM_GROUP_MODE_STA\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_multicast_addr_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_add_multicast_addr_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_add_multicast_addr_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_add_multicast_addr_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_multicast_addr_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_add_multicast_addr_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_multicast_addr_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_add_multicast_addr_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_multicast_addr_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_multicast_addr_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_add_multicast_addr_req_t.\n @ingroup WFM_GROUP_MODE_STA\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_add_multicast_addr_cnf_t = sl_wfx_add_multicast_addr_cnf_s;
#[doc = " @brief Request message body for sl_wfx_remove_multicast_addr_req_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_remove_multicast_addr_req_body_s {
    #[doc = " @brief MAC address to remove.\n @details <B>multicast address</B>: The device will remove the given address from the whitelist.\n          <BR>See @ref WFM_CONCEPT_BSSID for further details."]
    pub mac: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_remove_multicast_addr_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_remove_multicast_addr_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_remove_multicast_addr_req_body_s>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_remove_multicast_addr_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_remove_multicast_addr_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_remove_multicast_addr_req_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_remove_multicast_addr_req_body_s),
            "::",
            stringify!(mac)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_remove_multicast_addr_req_t."]
pub type sl_wfx_remove_multicast_addr_req_body_t = sl_wfx_remove_multicast_addr_req_body_s;
#[doc = " @brief Request message for removing a multicast address from the multicast filter whitelist.\n @details The host can use this request to remove a multicast address from the multicast filter\n          whitelist.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | Yes             |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_STA\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_remove_multicast_addr_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_remove_multicast_addr_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_remove_multicast_addr_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_remove_multicast_addr_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_remove_multicast_addr_req_s>(),
        10usize,
        concat!("Size of: ", stringify!(sl_wfx_remove_multicast_addr_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_remove_multicast_addr_req_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_remove_multicast_addr_req_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_remove_multicast_addr_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_remove_multicast_addr_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message for removing a multicast address from the multicast filter whitelist.\n @details The host can use this request to remove a multicast address from the multicast filter\n          whitelist.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | Yes             |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_STA\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_remove_multicast_addr_req_t = sl_wfx_remove_multicast_addr_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_remove_multicast_addr_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_remove_multicast_addr_cnf_body_s {
    #[doc = " @brief Status of the remove request.\n @details <B>WFM_STATUS_SUCCESS</B>: the remove request was completed successfully.\n          <BR><B>any other value</B>: the remove request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_remove_multicast_addr_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_remove_multicast_addr_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_remove_multicast_addr_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_remove_multicast_addr_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_remove_multicast_addr_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_remove_multicast_addr_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_remove_multicast_addr_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_remove_multicast_addr_cnf_t."]
pub type sl_wfx_remove_multicast_addr_cnf_body_t = sl_wfx_remove_multicast_addr_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_remove_multicast_addr_req_t.\n @ingroup WFM_GROUP_MODE_STA\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_remove_multicast_addr_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_remove_multicast_addr_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_remove_multicast_addr_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_remove_multicast_addr_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_remove_multicast_addr_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_remove_multicast_addr_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_remove_multicast_addr_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_remove_multicast_addr_cnf_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_remove_multicast_addr_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_remove_multicast_addr_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_remove_multicast_addr_req_t.\n @ingroup WFM_GROUP_MODE_STA\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_remove_multicast_addr_cnf_t = sl_wfx_remove_multicast_addr_cnf_s;
#[doc = " @brief Request message body for sl_wfx_set_max_ap_client_count_req_t.\n @details\n          | Field     | Default value | Reset to default value |\n          |:----------|:--------------|:-----------------------|\n          | Count     | 8             | when interface stopped |\n          <BR>"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_ap_client_count_req_body_s {
    #[doc = " @brief Maximum number of connected clients.\n @details <B>0</B>: The device will set the limit value to the device default.\n          <BR><B>1 - 8</B>: The maximum number of connected clients."]
    pub count: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_ap_client_count_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_max_ap_client_count_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_ap_client_count_req_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_max_ap_client_count_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_ap_client_count_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_max_ap_client_count_req_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_count_req_body_s),
            "::",
            stringify!(count)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_set_max_ap_client_count_req_t.\n @details\n          | Field     | Default value | Reset to default value |\n          |:----------|:--------------|:-----------------------|\n          | Count     | 8             | when interface stopped |\n          <BR>"]
pub type sl_wfx_set_max_ap_client_count_req_body_t = sl_wfx_set_max_ap_client_count_req_body_s;
#[doc = " @brief Request message for setting the maximum number of connected clients.\n @details The host can use this request to limit the number of stations that\n          can connect the started Wi-Fi network.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | No              |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_ap_client_count_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_set_max_ap_client_count_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_ap_client_count_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_max_ap_client_count_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_ap_client_count_req_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_max_ap_client_count_req_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_ap_client_count_req_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_max_ap_client_count_req_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_count_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_count_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message for setting the maximum number of connected clients.\n @details The host can use this request to limit the number of stations that\n          can connect the started Wi-Fi network.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | No              |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_set_max_ap_client_count_req_t = sl_wfx_set_max_ap_client_count_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_max_ap_client_count_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_ap_client_count_cnf_body_s {
    #[doc = " @brief Status of the set request.\n @details <B>WFM_STATUS_SUCCESS</B>: the set request was completed successfully.\n          <BR><B>any other value</B>: the set request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_ap_client_count_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_max_ap_client_count_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_ap_client_count_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_max_ap_client_count_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_ap_client_count_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_max_ap_client_count_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_count_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_set_max_ap_client_count_cnf_t."]
pub type sl_wfx_set_max_ap_client_count_cnf_body_t = sl_wfx_set_max_ap_client_count_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_max_ap_client_count_req_t.\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_ap_client_count_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_set_max_ap_client_count_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_ap_client_count_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_max_ap_client_count_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_ap_client_count_cnf_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_max_ap_client_count_cnf_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_ap_client_count_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_max_ap_client_count_cnf_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_count_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_count_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_set_max_ap_client_count_req_t.\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_set_max_ap_client_count_cnf_t = sl_wfx_set_max_ap_client_count_cnf_s;
#[doc = " @brief Request message body for sl_wfx_set_max_ap_client_inactivity_req_t.\n @details\n          | Field             | Default value | Reset to default value |\n          |:------------------|:--------------|:-----------------------|\n          | inactivity_timeout | 65            | when interface stopped |\n          <BR>"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_ap_client_inactivity_req_body_s {
    #[doc = " @brief Maximum amount of client idle time.\n @details <B>0</B>: The device will set the limit value to the device default.\n          <BR><B>1 - 240</B>: The maximum number of seconds."]
    pub inactivity_timeout: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_ap_client_inactivity_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_max_ap_client_inactivity_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_ap_client_inactivity_req_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_ap_client_inactivity_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_req_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inactivity_timeout) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_req_body_s),
            "::",
            stringify!(inactivity_timeout)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_set_max_ap_client_inactivity_req_t.\n @details\n          | Field             | Default value | Reset to default value |\n          |:------------------|:--------------|:-----------------------|\n          | inactivity_timeout | 65            | when interface stopped |\n          <BR>"]
pub type sl_wfx_set_max_ap_client_inactivity_req_body_t =
    sl_wfx_set_max_ap_client_inactivity_req_body_s;
#[doc = " @brief Request message for setting the maximum number of connected clients.\n @details The host can use this request to limit the number of stations that\n          can connect the started Wi-Fi network.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | No              |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_ap_client_inactivity_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_set_max_ap_client_inactivity_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_ap_client_inactivity_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_max_ap_client_inactivity_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_ap_client_inactivity_req_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_req_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_ap_client_inactivity_req_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_req_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message for setting the maximum number of connected clients.\n @details The host can use this request to limit the number of stations that\n          can connect the started Wi-Fi network.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | No              |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_set_max_ap_client_inactivity_req_t = sl_wfx_set_max_ap_client_inactivity_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_max_ap_client_count_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_ap_client_inactivity_cnf_body_s {
    #[doc = " @brief Status of the set request.\n @details <B>WFM_STATUS_SUCCESS</B>: the set request was completed successfully.\n          <BR><B>any other value</B>: the set request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_ap_client_inactivity_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_max_ap_client_inactivity_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_ap_client_inactivity_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_ap_client_inactivity_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_set_max_ap_client_count_cnf_t."]
pub type sl_wfx_set_max_ap_client_inactivity_cnf_body_t =
    sl_wfx_set_max_ap_client_inactivity_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_max_ap_client_inactivity_req_t.\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_ap_client_inactivity_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_set_max_ap_client_inactivity_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_ap_client_inactivity_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_max_ap_client_inactivity_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_ap_client_inactivity_cnf_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_cnf_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_ap_client_inactivity_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_cnf_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_set_max_ap_client_inactivity_req_t.\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_set_max_ap_client_inactivity_cnf_t = sl_wfx_set_max_ap_client_inactivity_cnf_s;
#[doc = " @brief Request message body for sl_wfx_set_roam_parameters_req_t.\n @details\n          | Field            | Default value    | Reset to default value |\n          |:-----------------|:-----------------|:-----------------------|\n          | rcpi_threshold    | 60               | when device reset      |\n          | rcpi_hysteresis   | 120              | when device reset      |\n          | beacon_lost_count  | 10               | when device reset      |\n          | channel_list_count | 13               | when device reset      |\n          | channel_number    | 1 to 13          | when device reset      |\n          <BR>"]
#[repr(C, packed)]
pub struct sl_wfx_set_roam_parameters_req_body_s {
    #[doc = " @brief Received Channel Power Indicator (RCPI) limit for a roaming attempt.\n @details <B>0</B>: The device will set the limit value to the device default.\n          <BR><B>1 - 220</B>: RCPI limit for a roaming attempt.\n          <BR>See @ref WFM_CONCEPT_RCPI for further details."]
    pub rcpi_threshold: u8,
    #[doc = " @brief Upper RCPI limit that must be attained before triggering roaming again.\n @details <B>0</B>: The device will set the limit value to the device default.\n          <BR><B>1 - 220</B>: RCPI limit to re-enable automatic roaming based on RCPI.\n          This value is used to prevent automatic roaming from triggering again and again\n          while the signal strength stays close to the rcpi_threshold value.\n          rcpi_hysteresis should be set to a value grater than rcpi_threshold.\n          <BR>See @ref WFM_CONCEPT_RCPI for further details."]
    pub rcpi_hysteresis: u8,
    #[doc = " @brief Beacon loss limit for a roaming attempt.\n @details <B>0</B>: The device will set the limit value to the device default.\n          <BR><B>1 - 255</B>: Beacon loss limit for a roaming attempt."]
    pub beacon_lost_count: u8,
    #[doc = " @brief The amount of specific channels to scan.\n @details <B>0</B>: The device will set the channel list to the device default.\n          <BR><B>1 - 13</B>: The amount of specific channels to scan."]
    pub channel_list_count: u8,
    #[doc = " @brief List of specific channels to scan.\n @details <B>1 - 13</B>: The channel number to scan per byte.\n          <BR>Must contain the same number of channels as specified in channel_list_count.\n          <BR>See @ref WFM_CONCEPT_SCAN for further details."]
    pub channel_number: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_roam_parameters_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_roam_parameters_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_roam_parameters_req_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_roam_parameters_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_roam_parameters_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_roam_parameters_req_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcpi_threshold) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_roam_parameters_req_body_s),
            "::",
            stringify!(rcpi_threshold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcpi_hysteresis) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_roam_parameters_req_body_s),
            "::",
            stringify!(rcpi_hysteresis)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beacon_lost_count) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_roam_parameters_req_body_s),
            "::",
            stringify!(beacon_lost_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channel_list_count) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_roam_parameters_req_body_s),
            "::",
            stringify!(channel_list_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channel_number) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_roam_parameters_req_body_s),
            "::",
            stringify!(channel_number)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_set_roam_parameters_req_t.\n @details\n          | Field            | Default value    | Reset to default value |\n          |:-----------------|:-----------------|:-----------------------|\n          | rcpi_threshold    | 60               | when device reset      |\n          | rcpi_hysteresis   | 120              | when device reset      |\n          | beacon_lost_count  | 10               | when device reset      |\n          | channel_list_count | 13               | when device reset      |\n          | channel_number    | 1 to 13          | when device reset      |\n          <BR>"]
pub type sl_wfx_set_roam_parameters_req_body_t = sl_wfx_set_roam_parameters_req_body_s;
#[doc = " @brief Request message for setting the roaming parameters.\n @details The host can use this request to configure the roaming parameters\n          used by the device.\n          <BR>See @ref WFM_CONCEPT_ROAM for further details.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | Yes             |\n          | station        | Yes             |\n          | AP             | No              |\n          <BR>\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
pub struct sl_wfx_set_roam_parameters_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_set_roam_parameters_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_roam_parameters_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_roam_parameters_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_roam_parameters_req_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_roam_parameters_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_roam_parameters_req_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_roam_parameters_req_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_roam_parameters_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_roam_parameters_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message for setting the roaming parameters.\n @details The host can use this request to configure the roaming parameters\n          used by the device.\n          <BR>See @ref WFM_CONCEPT_ROAM for further details.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | Yes             |\n          | station        | Yes             |\n          | AP             | No              |\n          <BR>\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_set_roam_parameters_req_t = sl_wfx_set_roam_parameters_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_roam_parameters_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_roam_parameters_cnf_body_s {
    #[doc = " @brief Status of the set request.\n @details <B>WFM_STATUS_SUCCESS</B>: the set request was completed successfully.\n          <BR><B>any other value</B>: the set request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_roam_parameters_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_roam_parameters_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_roam_parameters_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_roam_parameters_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_roam_parameters_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_roam_parameters_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_roam_parameters_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_set_roam_parameters_cnf_t."]
pub type sl_wfx_set_roam_parameters_cnf_body_t = sl_wfx_set_roam_parameters_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_roam_parameters_req_t.\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_roam_parameters_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_set_roam_parameters_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_roam_parameters_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_roam_parameters_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_roam_parameters_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_roam_parameters_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_roam_parameters_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_roam_parameters_cnf_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_roam_parameters_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_roam_parameters_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_set_roam_parameters_req_t.\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_set_roam_parameters_cnf_t = sl_wfx_set_roam_parameters_cnf_s;
#[doc = " @brief Request message body for sl_wfx_set_tx_rate_parameters_req_t.\n @details\n          | Field          | Default value                 | Reset to default value |\n          |:---------------|:------------------------------|:-----------------------|\n          | rate_set_bitmask | all 802.11bg rates, MCS 0 - 7 | when device reset      |\n          <BR>"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_tx_rate_parameters_req_body_s {
    #[doc = " @brief Reserved, set to zero."]
    pub reserved: u16,
    #[doc = " @brief Set to 1 to use Minstrel rate algorithm"]
    pub use_minstrel: u16,
    #[doc = " @brief TX rate set parameters."]
    pub rate_set_bitmask: sl_wfx_rate_set_bitmask_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_tx_rate_parameters_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_tx_rate_parameters_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_tx_rate_parameters_req_body_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_tx_rate_parameters_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_tx_rate_parameters_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_tx_rate_parameters_req_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_tx_rate_parameters_req_body_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).use_minstrel) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_tx_rate_parameters_req_body_s),
            "::",
            stringify!(use_minstrel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rate_set_bitmask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_tx_rate_parameters_req_body_s),
            "::",
            stringify!(rate_set_bitmask)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_set_tx_rate_parameters_req_t.\n @details\n          | Field          | Default value                 | Reset to default value |\n          |:---------------|:------------------------------|:-----------------------|\n          | rate_set_bitmask | all 802.11bg rates, MCS 0 - 7 | when device reset      |\n          <BR>"]
pub type sl_wfx_set_tx_rate_parameters_req_body_t = sl_wfx_set_tx_rate_parameters_req_body_s;
#[doc = " @brief Request message for setting the TX rate set parameters.\n @details The host can use this request to configure the TX rate\n          set parameters of the device. The rate set determines\n          what data rates will be used by the device to transmit data\n          frames.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | Yes             |\n          | station        | Yes             |\n          | AP             | No              |\n          <BR>\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_tx_rate_parameters_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_set_tx_rate_parameters_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_tx_rate_parameters_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_tx_rate_parameters_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_tx_rate_parameters_req_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_set_tx_rate_parameters_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_tx_rate_parameters_req_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_tx_rate_parameters_req_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_tx_rate_parameters_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_tx_rate_parameters_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message for setting the TX rate set parameters.\n @details The host can use this request to configure the TX rate\n          set parameters of the device. The rate set determines\n          what data rates will be used by the device to transmit data\n          frames.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | Yes             |\n          | station        | Yes             |\n          | AP             | No              |\n          <BR>\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_set_tx_rate_parameters_req_t = sl_wfx_set_tx_rate_parameters_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_tx_rate_parameters_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_tx_rate_parameters_cnf_body_s {
    #[doc = " @brief Status of the set request.\n @details <B>WFM_STATUS_SUCCESS</B>: the set request was completed successfully.\n          <BR><B>any other value</B>: the set request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_tx_rate_parameters_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_tx_rate_parameters_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_tx_rate_parameters_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_tx_rate_parameters_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_tx_rate_parameters_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_tx_rate_parameters_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_tx_rate_parameters_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_set_tx_rate_parameters_cnf_t."]
pub type sl_wfx_set_tx_rate_parameters_cnf_body_t = sl_wfx_set_tx_rate_parameters_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_tx_rate_parameters_req_t.\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_tx_rate_parameters_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_set_tx_rate_parameters_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_tx_rate_parameters_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_tx_rate_parameters_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_tx_rate_parameters_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_tx_rate_parameters_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_tx_rate_parameters_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_tx_rate_parameters_cnf_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_tx_rate_parameters_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_tx_rate_parameters_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_set_tx_rate_parameters_req_t.\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_set_tx_rate_parameters_cnf_t = sl_wfx_set_tx_rate_parameters_cnf_s;
#[doc = " @brief Request message body for sl_wfx_set_arp_ip_address_req_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_arp_ip_address_req_body_s {
    #[doc = " @brief List of offloaded ARP IP addresses.\n @details The device will automatically reply to an ARP request that matches\n          one the addresses on the list. Note that addresses not in use must\n          be set to zero. Offloading is disabled by setting all addresses to\n          zero.\n          <BR>See @ref WFM_CONCEPT_OFFLOADING for further details."]
    pub arp_ip_addr: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_set_arp_ip_address_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_arp_ip_address_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_arp_ip_address_req_body_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_arp_ip_address_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_arp_ip_address_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_arp_ip_address_req_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arp_ip_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_arp_ip_address_req_body_s),
            "::",
            stringify!(arp_ip_addr)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_set_arp_ip_address_req_t."]
pub type sl_wfx_set_arp_ip_address_req_body_t = sl_wfx_set_arp_ip_address_req_body_s;
#[doc = " @brief Request message for setting the Address Resolution Protocol (ARP) offloading state.\n @details The host can use this request to offload handling of ARP requests to the device.\n          When offloading is enabled, the device will automatically respond to ARP requests\n          with an ARP reply. By default offloading is disabled. Offloading is reset to\n          the default state when the interface is reset.\n          <BR>See @ref WFM_CONCEPT_OFFLOADING for further details.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | Yes             |\n          | AP             | No              |\n          <BR>\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_arp_ip_address_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_set_arp_ip_address_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_arp_ip_address_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_arp_ip_address_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_arp_ip_address_req_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_set_arp_ip_address_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_arp_ip_address_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_arp_ip_address_req_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_arp_ip_address_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_arp_ip_address_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message for setting the Address Resolution Protocol (ARP) offloading state.\n @details The host can use this request to offload handling of ARP requests to the device.\n          When offloading is enabled, the device will automatically respond to ARP requests\n          with an ARP reply. By default offloading is disabled. Offloading is reset to\n          the default state when the interface is reset.\n          <BR>See @ref WFM_CONCEPT_OFFLOADING for further details.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | Yes             |\n          | AP             | No              |\n          <BR>\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_set_arp_ip_address_req_t = sl_wfx_set_arp_ip_address_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_arp_ip_address_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_arp_ip_address_cnf_body_s {
    #[doc = " @brief Status of the set request.\n @details <B>WFM_STATUS_SUCCESS</B>: the set request was completed successfully.\n          <BR><B>any other value</B>: the set request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_arp_ip_address_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_arp_ip_address_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_arp_ip_address_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_arp_ip_address_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_arp_ip_address_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_arp_ip_address_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_arp_ip_address_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_set_arp_ip_address_cnf_t."]
pub type sl_wfx_set_arp_ip_address_cnf_body_t = sl_wfx_set_arp_ip_address_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_arp_ip_address_req_t.\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_arp_ip_address_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_set_arp_ip_address_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_arp_ip_address_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_arp_ip_address_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_arp_ip_address_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_arp_ip_address_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_arp_ip_address_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_arp_ip_address_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_arp_ip_address_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_arp_ip_address_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_set_arp_ip_address_req_t.\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_set_arp_ip_address_cnf_t = sl_wfx_set_arp_ip_address_cnf_s;
#[doc = " @brief Request message body for sl_wfx_set_ns_ip_address_req_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_ns_ip_address_req_body_s {
    #[doc = " @brief List of offloaded NS IP addresses.\n @details The device will automatically reply to a NS that matches one the\n          addresses on the list. Note that addresses not in use must be set\n          to zero. Offloading is disabled by setting all addresses to zero.\n          <BR>See @ref WFM_CONCEPT_OFFLOADING for further details."]
    pub ns_ip_addr: [sl_wfx_ns_ip_addr_t; 2usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_set_ns_ip_address_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_ns_ip_address_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_ns_ip_address_req_body_s>(),
        32usize,
        concat!("Size of: ", stringify!(sl_wfx_set_ns_ip_address_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_ns_ip_address_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_ns_ip_address_req_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ns_ip_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_ns_ip_address_req_body_s),
            "::",
            stringify!(ns_ip_addr)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_set_ns_ip_address_req_t."]
pub type sl_wfx_set_ns_ip_address_req_body_t = sl_wfx_set_ns_ip_address_req_body_s;
#[doc = " @brief Request message for setting the Neighbor Discovery Protocol (NDP) offloading state.\n @details The host can use this request to offload handling of IPv6 Neighbor Solicitations\n          to the device. When offloading is enabled, the device will automatically respond\n          to a solicitation with a Neighbor Advertisement.  By default offloading is disabled.\n          Offloading is reset to the default state when the interface is reset.\n          <BR>See @ref WFM_CONCEPT_OFFLOADING for further details.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | Yes             |\n          | AP             | No              |\n          <BR>\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_ns_ip_address_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_set_ns_ip_address_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_ns_ip_address_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_ns_ip_address_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_ns_ip_address_req_s>(),
        36usize,
        concat!("Size of: ", stringify!(sl_wfx_set_ns_ip_address_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_ns_ip_address_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_ns_ip_address_req_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_ns_ip_address_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_ns_ip_address_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message for setting the Neighbor Discovery Protocol (NDP) offloading state.\n @details The host can use this request to offload handling of IPv6 Neighbor Solicitations\n          to the device. When offloading is enabled, the device will automatically respond\n          to a solicitation with a Neighbor Advertisement.  By default offloading is disabled.\n          Offloading is reset to the default state when the interface is reset.\n          <BR>See @ref WFM_CONCEPT_OFFLOADING for further details.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | Yes             |\n          | AP             | No              |\n          <BR>\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_set_ns_ip_address_req_t = sl_wfx_set_ns_ip_address_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_ns_ip_address_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_ns_ip_address_cnf_body_s {
    #[doc = " @brief Status of the set request.\n @details <B>WFM_STATUS_SUCCESS</B>: the set request was completed successfully.\n          <BR><B>any other value</B>: the set request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_ns_ip_address_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_ns_ip_address_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_ns_ip_address_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_set_ns_ip_address_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_ns_ip_address_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_ns_ip_address_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_ns_ip_address_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_set_ns_ip_address_cnf_t."]
pub type sl_wfx_set_ns_ip_address_cnf_body_t = sl_wfx_set_ns_ip_address_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_ns_ip_address_req_t.\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_ns_ip_address_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_set_ns_ip_address_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_ns_ip_address_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_ns_ip_address_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_ns_ip_address_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_ns_ip_address_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_ns_ip_address_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_ns_ip_address_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_ns_ip_address_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_ns_ip_address_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_set_ns_ip_address_req_t.\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_set_ns_ip_address_cnf_t = sl_wfx_set_ns_ip_address_cnf_s;
#[doc = " @brief Request message body for sl_wfx_set_broadcast_filter_req_t.\n @details\n          | Field  | Default value | Reset to default value |\n          |:-------|:--------------|:-----------------------|\n          | Filter | 0             | when interface stopped |\n          <BR>"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_broadcast_filter_req_body_s {
    #[doc = " @brief Boolean option for broadcast filtering.\n @details <B>0</B>: The device will forward all received broadcast frames to the host.\n          <BR><B>1</B>: The device will only forward ARP and DHCP frames to the host,\n                        other broadcast frames are discarded.\n          <BR><B>2</B>: The device will discard all broadcast frames.\n          <BR>See @ref WFM_CONCEPT_FILTERING for further details."]
    pub filter: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_broadcast_filter_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_broadcast_filter_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_broadcast_filter_req_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_broadcast_filter_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_broadcast_filter_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_broadcast_filter_req_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_broadcast_filter_req_body_s),
            "::",
            stringify!(filter)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_set_broadcast_filter_req_t.\n @details\n          | Field  | Default value | Reset to default value |\n          |:-------|:--------------|:-----------------------|\n          | Filter | 0             | when interface stopped |\n          <BR>"]
pub type sl_wfx_set_broadcast_filter_req_body_t = sl_wfx_set_broadcast_filter_req_body_s;
#[doc = " @brief Request message for setting broadcast filter state.\n @details The host can use this request to configure the state of the broadcast filter.\n          When enabled, the device will only forward certain broadcast frames to the\n          host and automatically discard the rest.\n          <BR>See @ref WFM_CONCEPT_FILTERING for further details.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | Yes             |\n          | AP             | No              |\n          <BR>\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_broadcast_filter_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_set_broadcast_filter_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_broadcast_filter_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_broadcast_filter_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_broadcast_filter_req_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_broadcast_filter_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_broadcast_filter_req_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_broadcast_filter_req_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_broadcast_filter_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_broadcast_filter_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message for setting broadcast filter state.\n @details The host can use this request to configure the state of the broadcast filter.\n          When enabled, the device will only forward certain broadcast frames to the\n          host and automatically discard the rest.\n          <BR>See @ref WFM_CONCEPT_FILTERING for further details.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | Yes             |\n          | AP             | No              |\n          <BR>\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_set_broadcast_filter_req_t = sl_wfx_set_broadcast_filter_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_broadcast_filter_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_broadcast_filter_cnf_body_s {
    #[doc = " @brief Status of the set request.\n @details <B>WFM_STATUS_SUCCESS</B>: the set request was completed successfully.\n          <BR><B>any other value</B>: the set request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_broadcast_filter_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_broadcast_filter_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_broadcast_filter_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_broadcast_filter_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_broadcast_filter_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_broadcast_filter_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_broadcast_filter_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_set_broadcast_filter_cnf_t."]
pub type sl_wfx_set_broadcast_filter_cnf_body_t = sl_wfx_set_broadcast_filter_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_broadcast_filter_req_t.\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_broadcast_filter_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_set_broadcast_filter_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_broadcast_filter_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_broadcast_filter_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_broadcast_filter_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_broadcast_filter_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_broadcast_filter_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_broadcast_filter_cnf_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_broadcast_filter_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_broadcast_filter_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_set_broadcast_filter_req_t.\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_set_broadcast_filter_cnf_t = sl_wfx_set_broadcast_filter_cnf_s;
#[doc = " @brief Request message body for sl_wfx_set_scan_parameters_req_t.\n @details\n          | Field              | Default value    | Reset to default value |\n          |:-------------------|:-----------------|:-----------------------|\n          | active_channel_time  | 50               | when device reset      |\n          | passive_channel_time | 110              | when device reset      |\n          | num_of_probe_requests | 1                | when device reset      |\n          <BR>"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_scan_parameters_req_body_s {
    #[doc = " @brief Set to 0 for device default, 1 - 550 TUs"]
    pub active_channel_time: u16,
    #[doc = " @brief Set to 0 for device default, 1 - 550 TUs"]
    pub passive_channel_time: u16,
    #[doc = " @brief Set to 0 for device default, 1 - 2"]
    pub num_of_probe_requests: u16,
    #[doc = " @brief Reserved, set to zero."]
    pub reserved: u16,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_scan_parameters_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_scan_parameters_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_scan_parameters_req_body_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_scan_parameters_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_scan_parameters_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_scan_parameters_req_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).active_channel_time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_scan_parameters_req_body_s),
            "::",
            stringify!(active_channel_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).passive_channel_time) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_scan_parameters_req_body_s),
            "::",
            stringify!(passive_channel_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_of_probe_requests) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_scan_parameters_req_body_s),
            "::",
            stringify!(num_of_probe_requests)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_scan_parameters_req_body_s),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_set_scan_parameters_req_t.\n @details\n          | Field              | Default value    | Reset to default value |\n          |:-------------------|:-----------------|:-----------------------|\n          | active_channel_time  | 50               | when device reset      |\n          | passive_channel_time | 110              | when device reset      |\n          | num_of_probe_requests | 1                | when device reset      |\n          <BR>"]
pub type sl_wfx_set_scan_parameters_req_body_t = sl_wfx_set_scan_parameters_req_body_s;
#[doc = " @brief Request message for setting scan parameters.\n @details The host can use this request to configure the scan parameters\n          used by the device.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | Yes             |\n          | station        | Yes             |\n          | AP             | No              |\n          <BR>\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_scan_parameters_req_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_set_scan_parameters_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_scan_parameters_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_scan_parameters_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_scan_parameters_req_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_set_scan_parameters_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_scan_parameters_req_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_scan_parameters_req_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_scan_parameters_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_scan_parameters_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message for setting scan parameters.\n @details The host can use this request to configure the scan parameters\n          used by the device.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | Yes             |\n          | station        | Yes             |\n          | AP             | No              |\n          <BR>\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_set_scan_parameters_req_t = sl_wfx_set_scan_parameters_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_scan_parameters_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_scan_parameters_cnf_body_s {
    #[doc = " @brief Status of the set request.\n @details <B>WFM_STATUS_SUCCESS</B>: the set request was completed successfully.\n          <BR><B>any other value</B>: the set request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_scan_parameters_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_scan_parameters_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_scan_parameters_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_scan_parameters_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_scan_parameters_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_scan_parameters_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_scan_parameters_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_set_scan_parameters_cnf_t."]
pub type sl_wfx_set_scan_parameters_cnf_body_t = sl_wfx_set_scan_parameters_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_scan_parameters_req_t.\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_scan_parameters_cnf_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_set_scan_parameters_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_scan_parameters_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_scan_parameters_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_scan_parameters_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_scan_parameters_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_scan_parameters_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_scan_parameters_cnf_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_scan_parameters_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_scan_parameters_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_set_scan_parameters_req_t.\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_set_scan_parameters_cnf_t = sl_wfx_set_scan_parameters_cnf_s;
#[doc = " @brief Request message body for sl_wfx_set_unicast_filter_req_t.\n @details\n          | Field  | Default value | Reset to default value |\n          |:-------|:--------------|:-----------------------|\n          | Filter | 1             | when interface stopped |\n          <BR>"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_unicast_filter_req_body_s {
    #[doc = " @brief Boolean option for unicast filtering.\n @details <B>0</B>: The device will forward all received unicast frames to the host.\n          <BR><B>1</B>: The device will only forward unicast frames whose destination\n                        address matches the device MAC address.\n          <BR>See @ref WFM_CONCEPT_FILTERING for further details."]
    pub filter: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_unicast_filter_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_unicast_filter_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_unicast_filter_req_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_unicast_filter_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_unicast_filter_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_unicast_filter_req_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_unicast_filter_req_body_s),
            "::",
            stringify!(filter)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_set_unicast_filter_req_t.\n @details\n          | Field  | Default value | Reset to default value |\n          |:-------|:--------------|:-----------------------|\n          | Filter | 1             | when interface stopped |\n          <BR>"]
pub type sl_wfx_set_unicast_filter_req_body_t = sl_wfx_set_unicast_filter_req_body_s;
#[doc = " @brief Request message for setting unicast filter state.\n @details The host can use this request to configure the state of the unicast filter.\n          When enabled, the device will only forward certain unicast frames to the\n          host and automatically discard the rest.\n          <BR>See @ref WFM_CONCEPT_FILTERING for further details.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | No              |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_unicast_filter_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_set_unicast_filter_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_unicast_filter_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_unicast_filter_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_unicast_filter_req_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_unicast_filter_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_unicast_filter_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_unicast_filter_req_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_unicast_filter_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_unicast_filter_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message for setting unicast filter state.\n @details The host can use this request to configure the state of the unicast filter.\n          When enabled, the device will only forward certain unicast frames to the\n          host and automatically discard the rest.\n          <BR>See @ref WFM_CONCEPT_FILTERING for further details.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | No              |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_set_unicast_filter_req_t = sl_wfx_set_unicast_filter_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_unicast_filter_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_unicast_filter_cnf_body_s {
    #[doc = " @brief Status of the set request.\n @details <B>WFM_STATUS_SUCCESS</B>: the set request was completed successfully.\n          <BR><B>any other value</B>: the set request failed.\n          <BR>See ::sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_unicast_filter_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_unicast_filter_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_unicast_filter_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_unicast_filter_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_unicast_filter_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_unicast_filter_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_unicast_filter_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_set_unicast_filter_cnf_t."]
pub type sl_wfx_set_unicast_filter_cnf_body_t = sl_wfx_set_unicast_filter_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_unicast_filter_req_t.\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_unicast_filter_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_set_unicast_filter_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_unicast_filter_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_unicast_filter_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_unicast_filter_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_unicast_filter_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_unicast_filter_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_unicast_filter_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_unicast_filter_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_unicast_filter_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_set_unicast_filter_req_t.\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_set_unicast_filter_cnf_t = sl_wfx_set_unicast_filter_cnf_s;
#[doc = " @brief Request message body for sl_wfx_add_whitelist_addr_req_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_whitelist_addr_req_body_s {
    #[doc = " @brief MAC address to add.\n @details <B>broadcast address</B>: The device will allow all MAC addresses.\n          <BR><B>unicast address</B>: The device will add the given address to the whitelist."]
    pub mac: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_add_whitelist_addr_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_add_whitelist_addr_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_whitelist_addr_req_body_s>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_add_whitelist_addr_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_whitelist_addr_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_add_whitelist_addr_req_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_whitelist_addr_req_body_s),
            "::",
            stringify!(mac)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_add_whitelist_addr_req_t."]
pub type sl_wfx_add_whitelist_addr_req_body_t = sl_wfx_add_whitelist_addr_req_body_s;
#[doc = " @brief Request message for adding a MAC address to the device whitelist.\n @details The host can use this request to add a MAC address to the list of allowed MAC addresses.\n          When the first address is added the whitelist, the device will prevent communication with\n          any devices whose MAC address does not match any of the addresses on the list. Setting a\n          whitelist will clear all entries from the device blacklist. The default state is to allow\n          all MAC addresses. The whitelist is reset to the default state when the interface is reset.\n          Up to 8 MAC addresses may be added.\n          <BR>See @ref WFM_CONCEPT_FILTERING for further details.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | No              |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_whitelist_addr_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_add_whitelist_addr_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_add_whitelist_addr_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_add_whitelist_addr_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_whitelist_addr_req_s>(),
        10usize,
        concat!("Size of: ", stringify!(sl_wfx_add_whitelist_addr_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_whitelist_addr_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_add_whitelist_addr_req_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_whitelist_addr_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_whitelist_addr_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message for adding a MAC address to the device whitelist.\n @details The host can use this request to add a MAC address to the list of allowed MAC addresses.\n          When the first address is added the whitelist, the device will prevent communication with\n          any devices whose MAC address does not match any of the addresses on the list. Setting a\n          whitelist will clear all entries from the device blacklist. The default state is to allow\n          all MAC addresses. The whitelist is reset to the default state when the interface is reset.\n          Up to 8 MAC addresses may be added.\n          <BR>See @ref WFM_CONCEPT_FILTERING for further details.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | No              |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_add_whitelist_addr_req_t = sl_wfx_add_whitelist_addr_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_add_whitelist_addr_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_whitelist_addr_cnf_body_s {
    #[doc = " @brief Status of the add request.\n @details <B>WFM_STATUS_SUCCESS</B>: the add request was completed successfully.\n          <BR><B>any other value</B>: the add request failed.\n          <BR>See ::sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_add_whitelist_addr_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_add_whitelist_addr_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_whitelist_addr_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_add_whitelist_addr_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_whitelist_addr_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_add_whitelist_addr_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_whitelist_addr_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_add_whitelist_addr_cnf_t."]
pub type sl_wfx_add_whitelist_addr_cnf_body_t = sl_wfx_add_whitelist_addr_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_add_whitelist_addr_req_t.\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_whitelist_addr_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_add_whitelist_addr_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_add_whitelist_addr_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_add_whitelist_addr_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_whitelist_addr_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_add_whitelist_addr_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_whitelist_addr_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_add_whitelist_addr_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_whitelist_addr_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_whitelist_addr_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_add_whitelist_addr_req_t.\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_add_whitelist_addr_cnf_t = sl_wfx_add_whitelist_addr_cnf_s;
#[doc = " @brief Request message body for sl_wfx_add_blacklist_addr_req_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_blacklist_addr_req_body_s {
    #[doc = " @brief MAC address to add.\n @details <B>broadcast address</B>: The device will deny all MAC addresses.\n          <BR><B>unicast address</B>: The device will add the given address to the blacklist."]
    pub mac: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_add_blacklist_addr_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_add_blacklist_addr_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_blacklist_addr_req_body_s>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_add_blacklist_addr_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_blacklist_addr_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_add_blacklist_addr_req_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_blacklist_addr_req_body_s),
            "::",
            stringify!(mac)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_add_blacklist_addr_req_t."]
pub type sl_wfx_add_blacklist_addr_req_body_t = sl_wfx_add_blacklist_addr_req_body_s;
#[doc = " @brief Request message for adding a MAC address to the device blacklist.\n @details The host can use this request to add a MAC address to the list of denied MAC addresses.\n          When the first address is added the blacklist, the device will prevent communication with\n          any device whose MAC address matches any of the addresses on the list. Setting a blacklist\n          will clear all entries from the device whitelist. The default state is to allow all MAC\n          addresses. The blacklist is reset to the default state when the interface is reset.\n          Up to 8 MAC addresses may be added.\n          <BR>See @ref WFM_CONCEPT_FILTERING for further details.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | No              |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_blacklist_addr_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_add_blacklist_addr_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_add_blacklist_addr_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_add_blacklist_addr_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_blacklist_addr_req_s>(),
        10usize,
        concat!("Size of: ", stringify!(sl_wfx_add_blacklist_addr_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_blacklist_addr_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_add_blacklist_addr_req_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_blacklist_addr_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_blacklist_addr_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message for adding a MAC address to the device blacklist.\n @details The host can use this request to add a MAC address to the list of denied MAC addresses.\n          When the first address is added the blacklist, the device will prevent communication with\n          any device whose MAC address matches any of the addresses on the list. Setting a blacklist\n          will clear all entries from the device whitelist. The default state is to allow all MAC\n          addresses. The blacklist is reset to the default state when the interface is reset.\n          Up to 8 MAC addresses may be added.\n          <BR>See @ref WFM_CONCEPT_FILTERING for further details.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | No              |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_add_blacklist_addr_req_t = sl_wfx_add_blacklist_addr_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_add_blacklist_addr_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_blacklist_addr_cnf_body_s {
    #[doc = " @brief Status of the add request.\n @details <B>WFM_STATUS_SUCCESS</B>: the add request was completed successfully.\n          <BR><B>any other value</B>: the add request failed.\n          <BR>See ::sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_add_blacklist_addr_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_add_blacklist_addr_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_blacklist_addr_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_add_blacklist_addr_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_blacklist_addr_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_add_blacklist_addr_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_blacklist_addr_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_add_blacklist_addr_cnf_t."]
pub type sl_wfx_add_blacklist_addr_cnf_body_t = sl_wfx_add_blacklist_addr_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_add_blacklist_addr_req_t.\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_blacklist_addr_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_add_blacklist_addr_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_add_blacklist_addr_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_add_blacklist_addr_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_blacklist_addr_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_add_blacklist_addr_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_blacklist_addr_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_add_blacklist_addr_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_blacklist_addr_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_blacklist_addr_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_add_blacklist_addr_req_t.\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_add_blacklist_addr_cnf_t = sl_wfx_add_blacklist_addr_cnf_s;
#[doc = " @brief Request message body for sl_wfx_set_max_tx_power_req_t.\n @details\n          | Field      | Default value    | Reset to default value |\n          |:-----------|:-----------------|:-----------------------|\n          | max_tx_power | device dependent | when device reset      |\n          <BR>"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_tx_power_req_body_s {
    #[doc = " @brief Maximum transmit power to set\n @details Expressed in units of 0.1d_bm."]
    pub max_tx_power: i32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_tx_power_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_max_tx_power_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_tx_power_req_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_set_max_tx_power_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_tx_power_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_max_tx_power_req_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_tx_power) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_tx_power_req_body_s),
            "::",
            stringify!(max_tx_power)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_set_max_tx_power_req_t.\n @details\n          | Field      | Default value    | Reset to default value |\n          |:-----------|:-----------------|:-----------------------|\n          | max_tx_power | device dependent | when device reset      |\n          <BR>"]
pub type sl_wfx_set_max_tx_power_req_body_t = sl_wfx_set_max_tx_power_req_body_s;
#[doc = " @brief Request message for setting the maximum transmit power of the device.\n @details The host can use this request to set a maximum transmit power.\n          The device can still use a lower transmit power depending on regulatory rules\n          or internal limitations.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | Yes             |\n          | station        | Yes             |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_tx_power_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_set_max_tx_power_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_tx_power_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_max_tx_power_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_tx_power_req_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_max_tx_power_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_tx_power_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_max_tx_power_req_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_tx_power_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_tx_power_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message for setting the maximum transmit power of the device.\n @details The host can use this request to set a maximum transmit power.\n          The device can still use a lower transmit power depending on regulatory rules\n          or internal limitations.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | Yes             |\n          | station        | Yes             |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_set_max_tx_power_req_t = sl_wfx_set_max_tx_power_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_max_tx_power_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_tx_power_cnf_body_s {
    #[doc = " @brief Status of the add request.\n @details <B>WFM_STATUS_SUCCESS</B>: the add request was completed successfully.\n          <BR><B>any other value</B>: the add request failed.\n          <BR>See ::sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_tx_power_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_max_tx_power_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_tx_power_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_set_max_tx_power_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_tx_power_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_max_tx_power_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_tx_power_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_set_max_tx_power_cnf_t."]
pub type sl_wfx_set_max_tx_power_cnf_body_t = sl_wfx_set_max_tx_power_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_max_tx_power_req_t.\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_tx_power_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_set_max_tx_power_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_tx_power_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_set_max_tx_power_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_tx_power_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_max_tx_power_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_tx_power_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_max_tx_power_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_tx_power_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_tx_power_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_set_max_tx_power_req_t.\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_set_max_tx_power_cnf_t = sl_wfx_set_max_tx_power_cnf_s;
#[doc = " @brief General Message header structure\n"]
pub type sl_wfx_get_max_tx_power_req_t = sl_wfx_header_t;
#[doc = " @brief Confirmation message body for sl_wfx_get_max_tx_power_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_get_max_tx_power_cnf_body_s {
    #[doc = " @brief Status of the add request.\n @details <B>WFM_STATUS_SUCCESS</B>: the add request was completed successfully.\n          <BR><B>any other value</B>: the add request failed.\n          <BR>See ::sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
    #[doc = " @brief Maximum transmit power for RF port 1.\n @details Expressed in units of 0.1d_bm."]
    pub max_tx_power_rf_port1: i32,
    #[doc = " @brief Maximum transmit power for RF port 2.\n @details Expressed in units of 0.1d_bm."]
    pub max_tx_power_rf_port2: i32,
}
#[test]
fn bindgen_test_layout_sl_wfx_get_max_tx_power_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_get_max_tx_power_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_get_max_tx_power_cnf_body_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_get_max_tx_power_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_get_max_tx_power_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_get_max_tx_power_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_max_tx_power_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_tx_power_rf_port1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_max_tx_power_cnf_body_s),
            "::",
            stringify!(max_tx_power_rf_port1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_tx_power_rf_port2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_max_tx_power_cnf_body_s),
            "::",
            stringify!(max_tx_power_rf_port2)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_get_max_tx_power_cnf_t."]
pub type sl_wfx_get_max_tx_power_cnf_body_t = sl_wfx_get_max_tx_power_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_get_max_tx_power_req_t.\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_get_max_tx_power_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_get_max_tx_power_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_get_max_tx_power_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_get_max_tx_power_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_get_max_tx_power_cnf_s>(),
        16usize,
        concat!("Size of: ", stringify!(sl_wfx_get_max_tx_power_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_get_max_tx_power_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_get_max_tx_power_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_max_tx_power_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_max_tx_power_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_get_max_tx_power_req_t.\n @ingroup WFM_GROUP_MODE_IDLE\n @ingroup WFM_GROUP_MODE_STA\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_get_max_tx_power_cnf_t = sl_wfx_get_max_tx_power_cnf_s;
#[doc = " @brief General Message header structure\n"]
pub type sl_wfx_get_pmk_req_t = sl_wfx_header_t;
#[doc = " @brief Confirmation message body for sl_wfx_get_pmk_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_get_pmk_cnf_body_s {
    #[doc = " @brief Status of the add request.\n @details <B>WFM_STATUS_SUCCESS</B>: the get request was completed successfully.\n          <BR><B>any other value</B>: the get request failed.\n          <BR>See ::sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
    #[doc = " @brief Length of the Pairwise Master Key.\n @details <B>0 - 64</B>: The amount of bytes."]
    pub password_length: u32,
    #[doc = " @brief PMK of the network.\n @details <B>WPA PMK</B>: 64 bytes in HEX format.\n          <BR>See @ref WFM_CONCEPT_PASSWORD for further details."]
    pub password: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_get_pmk_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_get_pmk_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_get_pmk_cnf_body_s>(),
        72usize,
        concat!("Size of: ", stringify!(sl_wfx_get_pmk_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_get_pmk_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_get_pmk_cnf_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_pmk_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).password_length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_pmk_cnf_body_s),
            "::",
            stringify!(password_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).password) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_pmk_cnf_body_s),
            "::",
            stringify!(password)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_get_pmk_cnf_t."]
pub type sl_wfx_get_pmk_cnf_body_t = sl_wfx_get_pmk_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_get_pmk_req_t.\n @ingroup WFM_GROUP_MODE_STA\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_get_pmk_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_get_pmk_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_get_pmk_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_get_pmk_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_get_pmk_cnf_s>(),
        76usize,
        concat!("Size of: ", stringify!(sl_wfx_get_pmk_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_get_pmk_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_get_pmk_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_pmk_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_pmk_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_get_pmk_req_t.\n @ingroup WFM_GROUP_MODE_STA\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_get_pmk_cnf_t = sl_wfx_get_pmk_cnf_s;
#[doc = " @brief Request message body for sl_wfx_get_ap_client_signal_strength_req_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_get_ap_client_signal_strength_req_body_s {
    #[doc = " @brief MAC address of the station."]
    pub mac: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_get_ap_client_signal_strength_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_get_ap_client_signal_strength_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_get_ap_client_signal_strength_req_body_s>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_get_ap_client_signal_strength_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_get_ap_client_signal_strength_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_get_ap_client_signal_strength_req_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_ap_client_signal_strength_req_body_s),
            "::",
            stringify!(mac)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_get_ap_client_signal_strength_req_t."]
pub type sl_wfx_get_ap_client_signal_strength_req_body_t =
    sl_wfx_get_ap_client_signal_strength_req_body_s;
#[doc = " @brief Request message for retrieving the signal strength of a client of the started Wi-Fi network.\n @details The host can use this request to retrieve the signal strength of a client of the started Wi-Fi network.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | No              |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_get_ap_client_signal_strength_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_get_ap_client_signal_strength_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_get_ap_client_signal_strength_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_get_ap_client_signal_strength_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_get_ap_client_signal_strength_req_s>(),
        10usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_get_ap_client_signal_strength_req_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_get_ap_client_signal_strength_req_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_get_ap_client_signal_strength_req_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_ap_client_signal_strength_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_ap_client_signal_strength_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message for retrieving the signal strength of a client of the started Wi-Fi network.\n @details The host can use this request to retrieve the signal strength of a client of the started Wi-Fi network.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | No              |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_get_ap_client_signal_strength_req_t = sl_wfx_get_ap_client_signal_strength_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_get_ap_client_signal_strength_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_get_ap_client_signal_strength_cnf_body_s {
    #[doc = " @brief Status of the get request.\n @details <B>WFM_STATUS_SUCCESS</B>: the get request was completed.\n          <BR><B>any other value</B>: the get request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
    #[doc = " @brief Received Channel Power Indicator (RCPI) of the client.\n @details See @ref WFM_CONCEPT_RCPI for further details."]
    pub rcpi: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_get_ap_client_signal_strength_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_get_ap_client_signal_strength_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_get_ap_client_signal_strength_cnf_body_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_get_ap_client_signal_strength_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_get_ap_client_signal_strength_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_get_ap_client_signal_strength_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_ap_client_signal_strength_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcpi) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_ap_client_signal_strength_cnf_body_s),
            "::",
            stringify!(rcpi)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_get_ap_client_signal_strength_cnf_t."]
pub type sl_wfx_get_ap_client_signal_strength_cnf_body_t =
    sl_wfx_get_ap_client_signal_strength_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_get_ap_client_signal_strength_req_t.\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_get_ap_client_signal_strength_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_get_ap_client_signal_strength_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_get_ap_client_signal_strength_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_get_ap_client_signal_strength_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_get_ap_client_signal_strength_cnf_s>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_get_ap_client_signal_strength_cnf_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_get_ap_client_signal_strength_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_get_ap_client_signal_strength_cnf_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_ap_client_signal_strength_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_ap_client_signal_strength_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_get_ap_client_signal_strength_req_t.\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_get_ap_client_signal_strength_cnf_t = sl_wfx_get_ap_client_signal_strength_cnf_s;
#[doc = " @brief Request message body for sl_wfx_ext_auth_req_t."]
#[repr(C, packed)]
pub struct sl_wfx_ext_auth_req_body_s {
    #[doc = " @brief Type of the authentication message\n @details See ::sl_wfx_ext_auth_data_type_t for enumeration values."]
    pub auth_data_type: u16,
    #[doc = " @brief Length of the authentication message"]
    pub auth_data_length: u16,
    #[doc = " @brief The authentication message"]
    pub auth_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_ext_auth_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_ext_auth_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ext_auth_req_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_ext_auth_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ext_auth_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_ext_auth_req_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).auth_data_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ext_auth_req_body_s),
            "::",
            stringify!(auth_data_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).auth_data_length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ext_auth_req_body_s),
            "::",
            stringify!(auth_data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).auth_data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ext_auth_req_body_s),
            "::",
            stringify!(auth_data)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_ext_auth_req_t."]
pub type sl_wfx_ext_auth_req_body_t = sl_wfx_ext_auth_req_body_s;
#[repr(C, packed)]
pub struct sl_wfx_ext_auth_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_ext_auth_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_ext_auth_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_ext_auth_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ext_auth_req_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_ext_auth_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ext_auth_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_ext_auth_req_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ext_auth_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ext_auth_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_ext_auth_req_t = sl_wfx_ext_auth_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_ext_auth_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_ext_auth_cnf_body_s {
    #[doc = " @brief Status of the update request.\n @details <B>WFM_STATUS_SUCCESS</B>: the authentication request was completed.\n          <BR><B>any other value</B>: the authentication request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_ext_auth_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_ext_auth_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ext_auth_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_ext_auth_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ext_auth_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_ext_auth_cnf_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ext_auth_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_ext_auth_cnf_t."]
pub type sl_wfx_ext_auth_cnf_body_t = sl_wfx_ext_auth_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_ext_auth_req_t.\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_ext_auth_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_ext_auth_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_ext_auth_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_ext_auth_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ext_auth_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_ext_auth_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ext_auth_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_ext_auth_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ext_auth_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ext_auth_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_ext_auth_req_t.\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_ext_auth_cnf_t = sl_wfx_ext_auth_cnf_s;
#[doc = " @brief Indication message body for sl_wfx_ext_auth_ind_t."]
#[repr(C, packed)]
pub struct sl_wfx_ext_auth_ind_body_s {
    #[doc = " @brief Type of the authentication message\n @details See ::sl_wfx_ext_auth_data_type_t for enumeration values."]
    pub auth_data_type: u16,
    #[doc = " @brief Length of the authentication message"]
    pub auth_data_length: u16,
    #[doc = " @brief The authentication message"]
    pub auth_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_ext_auth_ind_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_ext_auth_ind_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ext_auth_ind_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_ext_auth_ind_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ext_auth_ind_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_ext_auth_ind_body_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).auth_data_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ext_auth_ind_body_s),
            "::",
            stringify!(auth_data_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).auth_data_length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ext_auth_ind_body_s),
            "::",
            stringify!(auth_data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).auth_data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ext_auth_ind_body_s),
            "::",
            stringify!(auth_data)
        )
    );
}
#[doc = " @brief Indication message body for sl_wfx_ext_auth_ind_t."]
pub type sl_wfx_ext_auth_ind_body_t = sl_wfx_ext_auth_ind_body_s;
#[doc = " @brief Indication message triggered during a WPA3 authentication process.\n @details The device will send this indication when an authentication\n          packet is received and needs to be handled by the host.\n @ingroup WFM_GROUP_MESSAGES\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
pub struct sl_wfx_ext_auth_ind_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Indication message body."]
    pub body: sl_wfx_ext_auth_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_ext_auth_ind_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_ext_auth_ind_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ext_auth_ind_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_ext_auth_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ext_auth_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_ext_auth_ind_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ext_auth_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ext_auth_ind_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Indication message triggered during a WPA3 authentication process.\n @details The device will send this indication when an authentication\n          packet is received and needs to be handled by the host.\n @ingroup WFM_GROUP_MESSAGES\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_ext_auth_ind_t = sl_wfx_ext_auth_ind_s;
#[doc = " @brief Request message body for sl_wfx_ap_scan_filter_req_body_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_ap_scan_filter_req_body_s {
    #[doc = " @brief Length of vendor-specific Information Element (IE) byte pattern.\n @details <B>0</B>: The filter is disabled\n          <BR><B>1 - SL_WFX_IE_DATA_FILTER_SIZE</B>: The amount of bytes."]
    pub ie_data_length: u16,
    #[doc = " @brief Vendor-specific IE byte pattern, starting from the Organization\n        Identifier field."]
    pub ie_data: [u8; 16usize],
    #[doc = " @brief Vendor-specific IE byte pattern mask.\n @details The byte pattern mask is ANDed with the frame data before\n          pattern matching, fill with 0xFF to match the whole pattern."]
    pub ie_data_mask: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_ap_scan_filter_req_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_ap_scan_filter_req_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ap_scan_filter_req_body_s>(),
        34usize,
        concat!("Size of: ", stringify!(sl_wfx_ap_scan_filter_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ap_scan_filter_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_ap_scan_filter_req_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ie_data_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_scan_filter_req_body_s),
            "::",
            stringify!(ie_data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ie_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_scan_filter_req_body_s),
            "::",
            stringify!(ie_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ie_data_mask) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_scan_filter_req_body_s),
            "::",
            stringify!(ie_data_mask)
        )
    );
}
#[doc = " @brief Request message body for sl_wfx_ap_scan_filter_req_body_t."]
pub type sl_wfx_ap_scan_filter_req_body_t = sl_wfx_ap_scan_filter_req_body_s;
#[doc = " @brief Request message for setting probe request forwarding filter.\n @details The host can use this request to set the filter for forwarded\n          probe requests. Any probe request where one the vendor-specific\n          IEs matches the given filter, is forwarded to the host using a\n          sl_wfx_ap_scan_filter_ind_t indication message. The forwarding can\n          be disabled by setting the IE byte pattern length to zero.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | No              |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MESSAGES\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_ap_scan_filter_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_ap_scan_filter_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_ap_scan_filter_req_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_ap_scan_filter_req_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ap_scan_filter_req_s>(),
        38usize,
        concat!("Size of: ", stringify!(sl_wfx_ap_scan_filter_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ap_scan_filter_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_ap_scan_filter_req_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_scan_filter_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_scan_filter_req_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Request message for setting probe request forwarding filter.\n @details The host can use this request to set the filter for forwarded\n          probe requests. Any probe request where one the vendor-specific\n          IEs matches the given filter, is forwarded to the host using a\n          sl_wfx_ap_scan_filter_ind_t indication message. The forwarding can\n          be disabled by setting the IE byte pattern length to zero.\n          | Interface mode | Request allowed |\n          |:---------------|:----------------|\n          | idle           | No              |\n          | station        | No              |\n          | AP             | Yes             |\n          <BR>\n @ingroup WFM_GROUP_MESSAGES\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_ap_scan_filter_req_t = sl_wfx_ap_scan_filter_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_ap_scan_filter_cnf_body_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_ap_scan_filter_cnf_body_s {
    #[doc = " @brief Status of the set request.\n @details <B>WFM_STATUS_SUCCESS</B>: the set request was completed successfully.\n          <BR><B>any other value</B>: the set request failed.\n          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_ap_scan_filter_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_ap_scan_filter_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ap_scan_filter_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_ap_scan_filter_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ap_scan_filter_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_ap_scan_filter_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_scan_filter_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief Confirmation message body for sl_wfx_ap_scan_filter_cnf_body_t."]
pub type sl_wfx_ap_scan_filter_cnf_body_t = sl_wfx_ap_scan_filter_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_ap_scan_filter_cnf_t.\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_ap_scan_filter_cnf_t {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_ap_scan_filter_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_ap_scan_filter_cnf_t() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_ap_scan_filter_cnf_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ap_scan_filter_cnf_t>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_ap_scan_filter_cnf_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ap_scan_filter_cnf_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_ap_scan_filter_cnf_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_scan_filter_cnf_t),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_scan_filter_cnf_t),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Indication message body for sl_wfx_ap_scan_filter_ind_body_t."]
#[repr(C, packed)]
pub struct sl_wfx_ap_scan_filter_ind_body_s {
    #[doc = " @brief MAC address of the station."]
    pub mac: [u8; 6usize],
    #[doc = " @brief reserved field, set to 0"]
    pub reserved: u16,
    #[doc = " @brief Received Channel Power Indicator (RCPI) of the station.\n @details See @ref WFM_CONCEPT_RCPI for further details."]
    pub rcpi: u16,
    #[doc = " @brief Length of access point Information Element (IE) data in bytes."]
    pub ie_data_length: u16,
    #[doc = " @brief Station IE data from the 802.11 Probe Request frame."]
    pub ie_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_ap_scan_filter_ind_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_ap_scan_filter_ind_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ap_scan_filter_ind_body_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_ap_scan_filter_ind_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ap_scan_filter_ind_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_ap_scan_filter_ind_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_scan_filter_ind_body_s),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_scan_filter_ind_body_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcpi) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_scan_filter_ind_body_s),
            "::",
            stringify!(rcpi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ie_data_length) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_scan_filter_ind_body_s),
            "::",
            stringify!(ie_data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ie_data) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_scan_filter_ind_body_s),
            "::",
            stringify!(ie_data)
        )
    );
}
#[doc = " @brief Indication message body for sl_wfx_ap_scan_filter_ind_body_t."]
pub type sl_wfx_ap_scan_filter_ind_body_t = sl_wfx_ap_scan_filter_ind_body_s;
#[doc = " @brief Indication message used to signal a received probe request.\n @details The device will send this indication when a probe request matching\n          the filter set with sl_wfx_ap_scan_filter_req_t, has been\n          received.\n @ingroup WFM_GROUP_MESSAGES\n @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
pub struct sl_wfx_ap_scan_filter_ind_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Indication message body."]
    pub body: sl_wfx_ap_scan_filter_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_ap_scan_filter_ind_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_ap_scan_filter_ind_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ap_scan_filter_ind_s>(),
        16usize,
        concat!("Size of: ", stringify!(sl_wfx_ap_scan_filter_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ap_scan_filter_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_ap_scan_filter_ind_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_scan_filter_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_scan_filter_ind_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Indication message used to signal a received probe request.\n @details The device will send this indication when a probe request matching\n          the filter set with sl_wfx_ap_scan_filter_req_t, has been\n          received.\n @ingroup WFM_GROUP_MESSAGES\n @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_ap_scan_filter_ind_t = sl_wfx_ap_scan_filter_ind_s;
#[doc = " @brief General Message header structure\n"]
pub type sl_wfx_get_statistics_req_t = sl_wfx_header_t;
#[doc = " @brief Confirmation message body for SL_WFX_GET_STATISTICS_CNF_ID."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_get_statistics_cnf_body_s {
    #[doc = " @brief Status of the get request.\n @details <B>WFM_STATUS_SUCCESS</B>: the get request was completed.\n          <BR><B>any other value</B>: the get request failed.\n          <BR>See ::WFM_STATUS for enumeration values."]
    pub status: u32,
    #[doc = " The amount of beacons received."]
    pub beacon_rx_count: u32,
    #[doc = " The amount of beacons missed. This value only includes beacons the\n device was expecting to receive but did not. Modifying device sleep\n interval with WFM_HI_SET_PM_MODE_REQ command may cause the device\n to skip beacons, which are not included in this value."]
    pub beacon_rx_missed_count: u32,
    #[doc = " AP is supposed to transmit a beacon on Target Beacon Transmission Time\n (TBTT) but the actual transmission time may vary depending on channel\n utilization and due to AP-specific functionality. This value shows\n the time difference in microseconds between the expected time and the\n actual receive time of the previous beacon."]
    pub beacon_tbtt_diff: i32,
    #[doc = " The amount of unicast data packets received and forwarded to the\n host."]
    pub unicast_rx_count: u32,
    #[doc = " The amount of successful unicast data packet transmission requests\n made by the host."]
    pub unicast_tx_success_count: u32,
    #[doc = " The amount of failed unicast data packet transmission requests\n made by the host."]
    pub unicast_tx_failure_count: u32,
    #[doc = " The amount of multicast/broadcast data packets received and forwarded\n to the host."]
    pub multicast_rx_count: u32,
    #[doc = " The amount of successful multicast/broadcast data packet transmission\n requests made by the host."]
    pub multicast_tx_success_count: u32,
    #[doc = " The amount of failed multicast/broadcast data packet transmission\n requests made by the host."]
    pub multicast_tx_failure_count: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_get_statistics_cnf_body_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_get_statistics_cnf_body_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_get_statistics_cnf_body_s>(),
        40usize,
        concat!("Size of: ", stringify!(sl_wfx_get_statistics_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_get_statistics_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_get_statistics_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_statistics_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beacon_rx_count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_statistics_cnf_body_s),
            "::",
            stringify!(beacon_rx_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beacon_rx_missed_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_statistics_cnf_body_s),
            "::",
            stringify!(beacon_rx_missed_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beacon_tbtt_diff) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_statistics_cnf_body_s),
            "::",
            stringify!(beacon_tbtt_diff)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unicast_rx_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_statistics_cnf_body_s),
            "::",
            stringify!(unicast_rx_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unicast_tx_success_count) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_statistics_cnf_body_s),
            "::",
            stringify!(unicast_tx_success_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unicast_tx_failure_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_statistics_cnf_body_s),
            "::",
            stringify!(unicast_tx_failure_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).multicast_rx_count) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_statistics_cnf_body_s),
            "::",
            stringify!(multicast_rx_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).multicast_tx_success_count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_statistics_cnf_body_s),
            "::",
            stringify!(multicast_tx_success_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).multicast_tx_failure_count) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_statistics_cnf_body_s),
            "::",
            stringify!(multicast_tx_failure_count)
        )
    );
}
#[doc = " @brief Confirmation message body for SL_WFX_GET_STATISTICS_CNF_ID."]
pub type sl_wfx_get_statistics_cnf_body_t = sl_wfx_get_statistics_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_get_statistics_req_t.\n @ingroup WFM_GROUP_MESSAGES\n @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_get_statistics_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_get_statistics_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_get_statistics_cnf_s() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_get_statistics_cnf_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_get_statistics_cnf_s>(),
        44usize,
        concat!("Size of: ", stringify!(sl_wfx_get_statistics_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_get_statistics_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_get_statistics_cnf_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_statistics_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_statistics_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
#[doc = " @brief Confirmation message for sl_wfx_get_statistics_req_t.\n @ingroup WFM_GROUP_MESSAGES\n @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_get_statistics_cnf_t = sl_wfx_get_statistics_cnf_s;
extern "C" {
    pub static sl_wfx_firmware: [u8; 310352usize];
}
pub const sl_wfx_firmware_size: u32 = 310352;
pub const sl_wfx_register_address_t_SL_WFX_CONFIG_REG_ID: sl_wfx_register_address_t = 0;
pub const sl_wfx_register_address_t_SL_WFX_CONTROL_REG_ID: sl_wfx_register_address_t = 1;
pub const sl_wfx_register_address_t_SL_WFX_IN_OUT_QUEUE_REG_ID: sl_wfx_register_address_t = 2;
pub const sl_wfx_register_address_t_SL_WFX_AHB_DPORT_REG_ID: sl_wfx_register_address_t = 3;
pub const sl_wfx_register_address_t_SL_WFX_SRAM_BASE_ADDR_REG_ID: sl_wfx_register_address_t = 4;
pub const sl_wfx_register_address_t_SL_WFX_SRAM_DPORT_REG_ID: sl_wfx_register_address_t = 5;
pub const sl_wfx_register_address_t_SL_WFX_TSET_GEN_R_W_REG_ID: sl_wfx_register_address_t = 6;
pub const sl_wfx_register_address_t_SL_WFX_FRAME_OUT_REG_ID: sl_wfx_register_address_t = 7;
#[doc = "//**\n @enum sl_wfx_register_address_t\n @brief Enum listing the registers of the WFx solution"]
pub type sl_wfx_register_address_t = c_types::c_uint;
pub const sl_wfx_state_t_SL_WFX_STARTED: sl_wfx_state_t = 1;
pub const sl_wfx_state_t_SL_WFX_STA_INTERFACE_CONNECTED: sl_wfx_state_t = 2;
pub const sl_wfx_state_t_SL_WFX_AP_INTERFACE_UP: sl_wfx_state_t = 4;
pub const sl_wfx_state_t_SL_WFX_SLEEPING: sl_wfx_state_t = 8;
pub const sl_wfx_state_t_SL_WFX_POWER_SAVE_ACTIVE: sl_wfx_state_t = 16;
#[doc = "//**\n @enum sl_wfx_state_t\n @brief Enum listing the different state of the WFx chip"]
pub type sl_wfx_state_t = c_types::c_uint;
#[doc = "< Interface 0, linked to the station"]
pub const sl_wfx_interface_t_SL_WFX_STA_INTERFACE: sl_wfx_interface_t = 0;
#[doc = "< Interface 1, linked to the softap"]
pub const sl_wfx_interface_t_SL_WFX_SOFTAP_INTERFACE: sl_wfx_interface_t = 1;
#[doc = "//**\n @enum sl_wfx_interface_t\n @brief Enum listing available interfaces in WFx Wi-Fi solution\n @details For convenience, interface 0 is associated with the station\n interface and interface 1 is associated with the softap interface."]
pub type sl_wfx_interface_t = c_types::c_uint;
#[doc = "< RF output 1 is used"]
pub const sl_wfx_antenna_config_t_SL_WFX_ANTENNA_1_ONLY: sl_wfx_antenna_config_t = 0;
#[doc = "< RF output 2 is used"]
pub const sl_wfx_antenna_config_t_SL_WFX_ANTENNA_2_ONLY: sl_wfx_antenna_config_t = 1;
#[doc = "< RF output 1 is used for TX, RF 2 for RX"]
pub const sl_wfx_antenna_config_t_SL_WFX_ANTENNA_TX1_RX2: sl_wfx_antenna_config_t = 2;
#[doc = "< RF output 2 is used for TX, RF 1 for RX"]
pub const sl_wfx_antenna_config_t_SL_WFX_ANTENNA_TX2_RX1: sl_wfx_antenna_config_t = 3;
#[doc = "< WF200 uses an antenna diversity algorithm"]
pub const sl_wfx_antenna_config_t_SL_WFX_ANTENNA_DIVERSITY: sl_wfx_antenna_config_t = 4;
#[doc = "//**\n @enum sl_wfx_antenna_config_t\n @brief Enum listing the different antenna configurations"]
pub type sl_wfx_antenna_config_t = c_types::c_uint;
#[doc = "< Frame type indicating a confirmation message is available"]
pub const sl_wfx_received_message_type_t_SL_WFX_CONFIRMATION_MESSAGE:
    sl_wfx_received_message_type_t = 0;
#[doc = "< Frame type indicating an indication message is available"]
pub const sl_wfx_received_message_type_t_SL_WFX_INDICATION_MESSAGE: sl_wfx_received_message_type_t =
    1;
#[doc = "< Reserved from Low MAC interface"]
pub const sl_wfx_received_message_type_t_SL_WFX_MANAGEMENT_MESSAGE: sl_wfx_received_message_type_t =
    2;
#[doc = "< Frame type indicating message encapsulating a data frame is available"]
pub const sl_wfx_received_message_type_t_SL_WFX_ETHERNET_DATA_MESSAGE:
    sl_wfx_received_message_type_t = 3;
#[doc = "//**\n @enum sl_wfx_received_message_type_t\n @brief Enum listing different message types received from WFx. The\n information is found in the control register using\n SL_WFX_CONT_FRAME_TYPE_INFO mask."]
pub type sl_wfx_received_message_type_t = c_types::c_uint;
pub const sl_wfx_buffer_type_t_SL_WFX_TX_FRAME_BUFFER: sl_wfx_buffer_type_t = 0;
pub const sl_wfx_buffer_type_t_SL_WFX_RX_FRAME_BUFFER: sl_wfx_buffer_type_t = 1;
pub const sl_wfx_buffer_type_t_SL_WFX_CONTROL_BUFFER: sl_wfx_buffer_type_t = 2;
#[doc = "//**\n @enum sl_wfx_buffer_type_t\n @brief Enumerates the different types of buffer"]
pub type sl_wfx_buffer_type_t = c_types::c_uint;
pub const sl_wfx_host_bus_transfer_type_t_SL_WFX_BUS_WRITE: sl_wfx_host_bus_transfer_type_t = 1;
pub const sl_wfx_host_bus_transfer_type_t_SL_WFX_BUS_READ: sl_wfx_host_bus_transfer_type_t = 2;
pub const sl_wfx_host_bus_transfer_type_t_SL_WFX_BUS_WRITE_AND_READ:
    sl_wfx_host_bus_transfer_type_t = 3;
#[doc = "//**\n @enum sl_wfx_host_bus_transfer_type_t\n @brief Enumerates the different types of bus transfers"]
pub type sl_wfx_host_bus_transfer_type_t = c_types::c_uint;
#[doc = "//**\n @struct sl_wfx_mac_address_t\n @brief Structure to handle MAC address format"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sl_wfx_mac_address_t {
    #[doc = "< Table to store a MAC address"]
    pub octet: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_mac_address_t() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_mac_address_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_mac_address_t>(),
        6usize,
        concat!("Size of: ", stringify!(sl_wfx_mac_address_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_mac_address_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_mac_address_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).octet) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_mac_address_t),
            "::",
            stringify!(octet)
        )
    );
}
#[doc = "//**\n @struct sl_wfx_password_t\n @brief Structure to handle password format"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sl_wfx_password_t {
    #[doc = "< Table to store a password"]
    pub password: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_password_t() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_password_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_password_t>(),
        64usize,
        concat!("Size of: ", stringify!(sl_wfx_password_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_password_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_password_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).password) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_password_t),
            "::",
            stringify!(password)
        )
    );
}
#[doc = "//**\n @struct sl_wfx_statistics_t\n @brief Structure to handle per-interface statistics"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sl_wfx_statistics_t {
    #[doc = "< The amount of beacons received."]
    pub beacon_rx_count: u32,
    #[doc = "< The amount of beacons missed."]
    pub beacon_rx_missed_count: u32,
    #[doc = "< The time difference in microseconds\n< between the expected time and the actual\n< receive time of the previous beacon."]
    pub beacon_tbtt_diff: i32,
    #[doc = "< The amount of unicast data packets\n< received and forwarded to the host."]
    pub unicast_rx_count: u32,
    #[doc = "< The amount of successful unicast data packet\n< transmission requests made by the host."]
    pub unicast_tx_success_count: u32,
    #[doc = "< The amount of failed unicast data packet\n< transmission requests made by the host."]
    pub unicast_tx_failure_count: u32,
    #[doc = "< The amount of multicast/broadcast data packets\n< received and forwarded to the host."]
    pub multicast_rx_count: u32,
    #[doc = "< The amount of successful multicast/broadcast\n< data packet transmission requests made by the host."]
    pub multicast_tx_success_count: u32,
    #[doc = "< The amount of failed multicast/broadcast data\n< packet transmission requests made by the host."]
    pub multicast_tx_failure_count: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_statistics_t() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_statistics_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_statistics_t>(),
        36usize,
        concat!("Size of: ", stringify!(sl_wfx_statistics_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_statistics_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sl_wfx_statistics_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beacon_rx_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_statistics_t),
            "::",
            stringify!(beacon_rx_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beacon_rx_missed_count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_statistics_t),
            "::",
            stringify!(beacon_rx_missed_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beacon_tbtt_diff) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_statistics_t),
            "::",
            stringify!(beacon_tbtt_diff)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unicast_rx_count) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_statistics_t),
            "::",
            stringify!(unicast_rx_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unicast_tx_success_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_statistics_t),
            "::",
            stringify!(unicast_tx_success_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unicast_tx_failure_count) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_statistics_t),
            "::",
            stringify!(unicast_tx_failure_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).multicast_rx_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_statistics_t),
            "::",
            stringify!(multicast_rx_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).multicast_tx_success_count) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_statistics_t),
            "::",
            stringify!(multicast_tx_success_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).multicast_tx_failure_count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_statistics_t),
            "::",
            stringify!(multicast_tx_failure_count)
        )
    );
}
#[doc = "//**\n @struct sl_wfx_nonce_t\n @brief Structure to maintain secure link counters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sl_wfx_nonce_t {
    #[doc = "< High priority packet counter"]
    pub hp_packet_count: u32,
    #[doc = "< Received packet counter"]
    pub rx_packet_count: u32,
    #[doc = "< Sent packet counter"]
    pub tx_packet_count: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_nonce_t() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_nonce_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_nonce_t>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_nonce_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_nonce_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sl_wfx_nonce_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hp_packet_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_nonce_t),
            "::",
            stringify!(hp_packet_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_packet_count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_nonce_t),
            "::",
            stringify!(rx_packet_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_packet_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_nonce_t),
            "::",
            stringify!(tx_packet_count)
        )
    );
}
#[doc = "//**\n @struct sl_wfx_error_log_t\n @brief Structure used to display error logs"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sl_wfx_err_log_t {
    pub val: u32,
    pub str_: *const c_types::c_char,
    pub param_length: u8,
}
#[test]
fn bindgen_test_layout_sl_wfx_err_log_t() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_err_log_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_err_log_t>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_err_log_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_err_log_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sl_wfx_err_log_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_err_log_t),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_err_log_t),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).param_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_err_log_t),
            "::",
            stringify!(param_length)
        )
    );
}
#[doc = "//**\n @struct sl_wfx_context_t\n @brief Structure used to maintain the Wi-Fi solution context on the host\n side"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sl_wfx_context_t {
    #[doc = "< Event payload associated with the last posted event"]
    pub event_payload_buffer: [u8; 512usize],
    #[doc = "< Firmware build version"]
    pub firmware_build: u8,
    #[doc = "< Firmware minor version"]
    pub firmware_minor: u8,
    #[doc = "< Firmware major version"]
    pub firmware_major: u8,
    #[doc = "< Frame ID incremented by ::sl_wfx_send_ethernet_frame"]
    pub data_frame_id: u16,
    #[doc = "< Number of buffers currently in use by the WFx chip"]
    pub used_buffers: u16,
    #[doc = "< OPN of the part"]
    pub wfx_opn: [u8; 14usize],
    #[doc = "< Mac address used by WFx interface 0, station"]
    pub mac_addr_0: sl_wfx_mac_address_t,
    #[doc = "< Mac address used by WFx interface 1, softap"]
    pub mac_addr_1: sl_wfx_mac_address_t,
    #[doc = "< State of the WFx Wi-Fi chip"]
    pub state: sl_wfx_state_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_context_t() {
    const UNINIT: ::core::mem::MaybeUninit<sl_wfx_context_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_context_t>(),
        552usize,
        concat!("Size of: ", stringify!(sl_wfx_context_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_context_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sl_wfx_context_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_payload_buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_context_t),
            "::",
            stringify!(event_payload_buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).firmware_build) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_context_t),
            "::",
            stringify!(firmware_build)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).firmware_minor) as usize - ptr as usize },
        513usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_context_t),
            "::",
            stringify!(firmware_minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).firmware_major) as usize - ptr as usize },
        514usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_context_t),
            "::",
            stringify!(firmware_major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_frame_id) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_context_t),
            "::",
            stringify!(data_frame_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).used_buffers) as usize - ptr as usize },
        518usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_context_t),
            "::",
            stringify!(used_buffers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wfx_opn) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_context_t),
            "::",
            stringify!(wfx_opn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr_0) as usize - ptr as usize },
        534usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_context_t),
            "::",
            stringify!(mac_addr_0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr_1) as usize - ptr as usize },
        540usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_context_t),
            "::",
            stringify!(mac_addr_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        548usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_context_t),
            "::",
            stringify!(state)
        )
    );
}
extern "C" {
    #[doc = "                    Variables"]
    pub static mut sl_wfx_context: *mut sl_wfx_context_t;
}
extern "C" {
    #[doc = "//**\n @brief Driver hook to initialize the host resources\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise\n\n @note Called once during the driver initialization phase"]
    pub fn sl_wfx_host_init() -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Driver hook to retrieve a firmware chunk\n\n @param data is a pointer to the firmware data\n @param data_size is the size of data requested by the driver\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise\n\n @note Called multiple times during the driver initialization phase"]
    pub fn sl_wfx_host_get_firmware_data(data: *mut *const u8, data_size: u32) -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Driver hook to retrieve the firmware size\n\n @param firmware_size is a pointer to the firmware size value\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise\n\n @note Called once during the driver initialization phase"]
    pub fn sl_wfx_host_get_firmware_size(firmware_size: *mut u32) -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Driver hook to retrieve a PDS line\n\n @param pds_data is a pointer to the PDS data\n @param index is the index of the line requested by the driver\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise\n\n @note Called multiple times during the driver initialization phase"]
    pub fn sl_wfx_host_get_pds_data(
        pds_data: *mut *const c_types::c_char,
        index: u16,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Driver hook to get the number of lines of the PDS\n\n @param pds_size is a pointer to the PDS size value\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise\n\n @note Called once during the driver initialization phase"]
    pub fn sl_wfx_host_get_pds_size(pds_size: *mut u16) -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Driver hook to deinitialize the host resources\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise\n\n @note Called if an error occurs during the initialization phase"]
    pub fn sl_wfx_host_deinit() -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Implement the reset of the WFx chip\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise\n\n @note This function asserts the reset pin of the WFx chip for a while before\n returning"]
    pub fn sl_wfx_host_reset_chip() -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Drive the wake up pin in the requested state\n\n @param state to be applied to the wake up pin\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise\n\n @note Called if the sleep mode is enabled"]
    pub fn sl_wfx_host_set_wake_up_pin(state: u8) -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Called once the WFx chip is waking up\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise\n\n @note Called if the sleep mode is enabled. The function waits for the WFx\n interruption"]
    pub fn sl_wfx_host_wait_for_wake_up() -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Called when the driver is considering putting the WFx in\n sleep mode\n\n @param type is the type of the message sent\n @param address is the address of the message sent\n @param length is the length of the message to be sent\n @returns Returns SL_STATUS_WIFI_SLEEP_GRANTED to let the WFx go to sleep,\n SL_STATUS_WIFI_SLEEP_NOT_GRANTED otherwise\n\n @note The parameters are given as information for the host to take a decision\n on whether or not the WFx is put back to sleep mode."]
    pub fn sl_wfx_host_sleep_grant(
        type_: sl_wfx_host_bus_transfer_type_t,
        address: sl_wfx_register_address_t,
        length: u32,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Hold the WFx chip in reset mode\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise\n\n @note The reset pin is asserted by the host to keep the WFx chip in reset"]
    pub fn sl_wfx_host_hold_in_reset() -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Set up the next event that the driver will wait\n\n @param event_id is the ID to be waited\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise\n\n @note Called every time a API command is called"]
    pub fn sl_wfx_host_setup_waited_event(event_id: u8) -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Called when the driver is waiting for a confirmation\n\n @param confirmation_id is the ID to be waited\n @param timeout_ms is the time before the command times out\n @param event_payload_out is a pointer to the data returned by the\n confirmation\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise\n\n @note Called every time a API command is called"]
    pub fn sl_wfx_host_wait_for_confirmation(
        confirmation_id: u8,
        timeout_ms: u32,
        event_payload_out: *mut *mut c_types::c_void,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Called when the FMAC driver wants to add a delay\n\n @param wait_ms is the time to wait\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise\n\n @note Can be a passive wait or in a RTOS context a task sleep"]
    pub fn sl_wfx_host_wait(wait_ms: u32) -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Called when a message is received from the WFx chip\n\n @param event_payload is a pointer to the data received\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise\n\n @note Called by ::sl_wfx_receive_frame function"]
    pub fn sl_wfx_host_post_event(event_payload: *mut sl_wfx_generic_message_t) -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Called when the driver wants to allocate memory\n\n @param buffer is a pointer to the data\n @param type is the type of buffer to allocate (see ::sl_wfx_buffer_type_t)\n @param buffer_size represents the amount of memory to allocate\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise\n\n @note Called by the driver every time it needs memory"]
    pub fn sl_wfx_host_allocate_buffer(
        buffer: *mut *mut c_types::c_void,
        type_: sl_wfx_buffer_type_t,
        buffer_size: u32,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Called when the driver wants to free memory\n\n @param buffer is the pointer to the memory to free\n @param type is the type of buffer to free (see ::sl_wfx_buffer_type_t)\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    pub fn sl_wfx_host_free_buffer(
        buffer: *mut c_types::c_void,
        type_: sl_wfx_buffer_type_t,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Called when the driver sends a frame to the WFx chip\n\n @param frame is a pointer to the frame data\n @param frame_len is size of the frame\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    pub fn sl_wfx_host_transmit_frame(frame: *mut c_types::c_void, frame_len: u32) -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Called when the driver needs to lock its access\n\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_NO_MORE_RESOURCE\n otherwise"]
    pub fn sl_wfx_host_lock() -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Called when the driver needs to unlock its access\n\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    pub fn sl_wfx_host_unlock() -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Initialize the host bus\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise\n\n @note Called once during the driver initialization phase"]
    pub fn sl_wfx_host_init_bus() -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Deinitialize the host bus\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise\n\n @note Called if an error occurs during the initialization phase"]
    pub fn sl_wfx_host_deinit_bus() -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Enable the bus interrupt\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    pub fn sl_wfx_host_enable_platform_interrupt() -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Disable the bus interrupt\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    pub fn sl_wfx_host_disable_platform_interrupt() -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Assert the SPI Chip Select pin\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    pub fn sl_wfx_host_spi_cs_assert() -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Deassert the SPI Chip Select pin\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    pub fn sl_wfx_host_spi_cs_deassert() -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Send data on the SPI bus\n\n @param type is the type of bus action (see ::sl_wfx_host_bus_transfer_type_t)\n @param header is a pointer to the header data\n @param header_length is the length of the header data\n @param buffer is a pointer to the buffer data\n @param buffer_length is the length of the buffer data\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    pub fn sl_wfx_host_spi_transfer_no_cs_assert(
        type_: sl_wfx_host_bus_transfer_type_t,
        header: *mut u8,
        header_length: u16,
        buffer: *mut u8,
        buffer_length: u16,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Send command 52 on the SDIO bus\n\n @param type is the type of bus action (see ::sl_wfx_host_bus_transfer_type_t)\n @param function is the function to use in the SDIO command\n @param address is the address to use in the SDIO command\n @param buffer is a pointer to the buffer data\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    pub fn sl_wfx_host_sdio_transfer_cmd52(
        type_: sl_wfx_host_bus_transfer_type_t,
        function: u8,
        address: u32,
        buffer: *mut u8,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Send command 53 on the SDIO bus\n\n @param type is the type of bus action (see ::sl_wfx_host_bus_transfer_type_t)\n @param function is the function to use in the SDIO command\n @param address is the address to use in the SDIO command\n @param buffer is a pointer to the buffer data\n @param buffer_length is the length of the buffer data\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    pub fn sl_wfx_host_sdio_transfer_cmd53(
        type_: sl_wfx_host_bus_transfer_type_t,
        function: u8,
        address: u32,
        buffer: *mut u8,
        buffer_length: u16,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = "//**\n @brief Enable the SDIO high-speed mode\n @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    pub fn sl_wfx_host_sdio_enable_high_speed_mode() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_init_bus() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_deinit_bus() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_reg_read(
        address: sl_wfx_register_address_t,
        buffer: *mut c_types::c_void,
        length: u32,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_reg_write(
        address: sl_wfx_register_address_t,
        buffer: *const c_types::c_void,
        length: u32,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_notify_bus_thread() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_reg_read_16(
        address: sl_wfx_register_address_t,
        value_out: *mut u16,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_reg_write_16(address: sl_wfx_register_address_t, value_in: u16) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_reg_read_32(
        address: sl_wfx_register_address_t,
        value_out: *mut u32,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_reg_write_32(address: sl_wfx_register_address_t, value_in: u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_data_read(buffer: *mut c_types::c_void, length: u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_data_write(buffer: *const c_types::c_void, length: u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_apb_write_32(address: u32, value_in: u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_apb_read_32(address: u32, value_out: *mut u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_apb_write(
        address: u32,
        buffer: *const c_types::c_void,
        length: u32,
    ) -> sl_status_t;
}
pub type wchar_t = c_types::c_int;
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = c_types::c_uint;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = f64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct div_t {
    pub quot: c_types::c_int,
    pub rem: c_types::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::core::mem::MaybeUninit<div_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::core::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ldiv_t {
    pub quot: c_types::c_long,
    pub rem: c_types::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<ldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lldiv_t {
    pub quot: c_types::c_longlong,
    pub rem: c_types::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<lldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const c_types::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const c_types::c_char) -> c_types::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const c_types::c_char) -> c_types::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const c_types::c_char, __endptr: *mut *mut c_types::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const c_types::c_char, __endptr: *mut *mut c_types::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const c_types::c_char, __endptr: *mut *mut c_types::c_char) -> f64;
}
extern "C" {
    pub fn strtol(
        __nptr: *const c_types::c_char,
        __endptr: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const c_types::c_char,
        __endptr: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const c_types::c_char,
        __endptr: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const c_types::c_char,
        __endptr: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const c_types::c_char,
        __endptr: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const c_types::c_char,
        __endptr: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: c_types::c_long) -> *mut c_types::c_char;
}
extern "C" {
    pub fn a64l(__s: *const c_types::c_char) -> c_types::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = c_types::c_ulong;
pub type ushort = c_types::c_ushort;
pub type uint = c_types::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = c_types::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigset_t {
    pub __val: [c_types::c_ulong; 32usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::core::mem::MaybeUninit<__sigset_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__sigset_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::core::mem::MaybeUninit<timeval> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        8usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        4usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::core::mem::MaybeUninit<timespec> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        8usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        4usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = c_types::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::core::mem::MaybeUninit<fd_set> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: c_types::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: c_types::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> c_types::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_internal_list> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_internal_list>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_internal_list>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_internal_slist> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_internal_slist>(),
        4usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_internal_slist>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: c_types::c_int,
    pub __count: c_types::c_uint,
    pub __owner: c_types::c_int,
    pub __kind: c_types::c_int,
    pub __nusers: c_types::c_uint,
    pub __bindgen_anon_1: __pthread_mutex_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_mutex_s__bindgen_ty_1 {
    pub __elision_data: __pthread_mutex_s__bindgen_ty_1__bindgen_ty_1,
    pub __list: __pthread_slist_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_mutex_s__bindgen_ty_1__bindgen_ty_1 {
    pub __espins: c_types::c_short,
    pub __eelision: c_types::c_short,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_mutex_s__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_mutex_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_mutex_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_mutex_s__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_mutex_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__espins) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__espins)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__eelision) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__eelision)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_mutex_s__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_mutex_s__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_mutex_s__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_mutex_s__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__elision_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s__bindgen_ty_1),
            "::",
            stringify!(__elision_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s__bindgen_ty_1),
            "::",
            stringify!(__list)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_mutex_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_mutex_s>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_mutex_s>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: c_types::c_uint,
    pub __writers: c_types::c_uint,
    pub __wrphase_futex: c_types::c_uint,
    pub __writers_futex: c_types::c_uint,
    pub __pad3: c_types::c_uint,
    pub __pad4: c_types::c_uint,
    pub __flags: c_types::c_uchar,
    pub __shared: c_types::c_uchar,
    pub __rwelision: c_types::c_schar,
    pub __pad2: c_types::c_uchar,
    pub __cur_writer: c_types::c_int,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_rwlock_arch_t>(),
        32usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_rwlock_arch_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [c_types::c_uint; 2usize],
    pub __g_size: [c_types::c_uint; 2usize],
    pub __g1_orig_size: c_types::c_uint,
    pub __wrefs: c_types::c_uint,
    pub __g_signals: [c_types::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: c_types::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: c_types::c_uint,
    pub __high: c_types::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wseq32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: c_types::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: c_types::c_uint,
    pub __high: c_types::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g1_start32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_cond_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = c_types::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [c_types::c_char; 4usize],
    pub __align: c_types::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_mutexattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [c_types::c_char; 4usize],
    pub __align: c_types::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_condattr_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = c_types::c_uint;
pub type pthread_once_t = c_types::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [c_types::c_char; 36usize],
    pub __align: c_types::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_attr_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_attr_t>(),
        36usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_attr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [c_types::c_char; 24usize],
    pub __align: c_types::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_mutex_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_mutex_t>(),
        24usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutex_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [c_types::c_char; 48usize],
    pub __align: c_types::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_cond_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_cond_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [c_types::c_char; 32usize],
    pub __align: c_types::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_rwlock_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_rwlock_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_rwlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [c_types::c_char; 8usize],
    pub __align: c_types::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_rwlockattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_rwlockattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = c_types::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [c_types::c_char; 20usize],
    pub __align: c_types::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_barrier_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_barrier_t>(),
        20usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_barrier_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [c_types::c_char; 4usize],
    pub __align: c_types::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_barrierattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> c_types::c_long;
}
extern "C" {
    pub fn srandom(__seed: c_types::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: c_types::c_uint,
        __statebuf: *mut c_types::c_char,
        __statelen: usize,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut c_types::c_char) -> *mut c_types::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: c_types::c_int,
    pub rand_deg: c_types::c_int,
    pub rand_sep: c_types::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::core::mem::MaybeUninit<random_data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<random_data>(),
        28usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::core::mem::align_of::<random_data>(),
        4usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> c_types::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: c_types::c_uint, __buf: *mut random_data) -> c_types::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: c_types::c_uint,
        __statebuf: *mut c_types::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut c_types::c_char, __buf: *mut random_data) -> c_types::c_int;
}
extern "C" {
    pub fn rand() -> c_types::c_int;
}
extern "C" {
    pub fn srand(__seed: c_types::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut c_types::c_uint) -> c_types::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut c_types::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> c_types::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut c_types::c_ushort) -> c_types::c_long;
}
extern "C" {
    pub fn mrand48() -> c_types::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut c_types::c_ushort) -> c_types::c_long;
}
extern "C" {
    pub fn srand48(__seedval: c_types::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut c_types::c_ushort) -> *mut c_types::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut c_types::c_ushort);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drand48_data {
    pub __x: [c_types::c_ushort; 3usize],
    pub __old_x: [c_types::c_ushort; 3usize],
    pub __c: c_types::c_ushort,
    pub __init: c_types::c_ushort,
    pub __a: c_types::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::core::mem::MaybeUninit<drand48_data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::core::mem::align_of::<drand48_data>(),
        4usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> c_types::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut c_types::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data, __result: *mut c_types::c_long)
        -> c_types::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut c_types::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut c_types::c_long,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data, __result: *mut c_types::c_long)
        -> c_types::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut c_types::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut c_types::c_long,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: c_types::c_long, __buffer: *mut drand48_data) -> c_types::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut c_types::c_ushort,
        __buffer: *mut drand48_data,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut c_types::c_ushort,
        __buffer: *mut drand48_data,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn malloc(__size: c_types::c_uint) -> *mut c_types::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: c_types::c_uint, __size: c_types::c_uint) -> *mut c_types::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut c_types::c_void, __size: c_types::c_uint) -> *mut c_types::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut c_types::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut c_types::c_void);
}
extern "C" {
    pub fn alloca(__size: c_types::c_uint) -> *mut c_types::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut c_types::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut c_types::c_void,
        __alignment: usize,
        __size: usize,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut c_types::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> c_types::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> c_types::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(__status: c_types::c_int, __arg: *mut c_types::c_void),
        >,
        __arg: *mut c_types::c_void,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn exit(__status: c_types::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: c_types::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: c_types::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const c_types::c_char,
        __value: *const c_types::c_char,
        __replace: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn clearenv() -> c_types::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut c_types::c_char,
        __suffixlen: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn system(__command: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const c_types::c_char,
        __resolved: *mut c_types::c_char,
    ) -> *mut c_types::c_char;
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const c_types::c_void,
        arg2: *const c_types::c_void,
    ) -> c_types::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const c_types::c_void,
        __base: *const c_types::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut c_types::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn labs(__x: c_types::c_long) -> c_types::c_long;
}
extern "C" {
    pub fn llabs(__x: c_types::c_longlong) -> c_types::c_longlong;
}
extern "C" {
    pub fn div(__numer: c_types::c_int, __denom: c_types::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: c_types::c_long, __denom: c_types::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: c_types::c_longlong, __denom: c_types::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: c_types::c_int,
        __decpt: *mut c_types::c_int,
        __sign: *mut c_types::c_int,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: c_types::c_int,
        __decpt: *mut c_types::c_int,
        __sign: *mut c_types::c_int,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: c_types::c_int,
        __buf: *mut c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: f64,
        __ndigit: c_types::c_int,
        __decpt: *mut c_types::c_int,
        __sign: *mut c_types::c_int,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: f64,
        __ndigit: c_types::c_int,
        __decpt: *mut c_types::c_int,
        __sign: *mut c_types::c_int,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: f64,
        __ndigit: c_types::c_int,
        __buf: *mut c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: c_types::c_int,
        __decpt: *mut c_types::c_int,
        __sign: *mut c_types::c_int,
        __buf: *mut c_types::c_char,
        __len: usize,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: c_types::c_int,
        __decpt: *mut c_types::c_int,
        __sign: *mut c_types::c_int,
        __buf: *mut c_types::c_char,
        __len: usize,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: f64,
        __ndigit: c_types::c_int,
        __decpt: *mut c_types::c_int,
        __sign: *mut c_types::c_int,
        __buf: *mut c_types::c_char,
        __len: usize,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: f64,
        __ndigit: c_types::c_int,
        __decpt: *mut c_types::c_int,
        __sign: *mut c_types::c_int,
        __buf: *mut c_types::c_char,
        __len: usize,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn mblen(__s: *const c_types::c_char, __n: usize) -> c_types::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const c_types::c_char, __n: usize) -> c_types::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut c_types::c_char, __wchar: wchar_t) -> c_types::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const c_types::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut c_types::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut c_types::c_char,
        __tokens: *const *mut c_types::c_char,
        __valuep: *mut *mut c_types::c_char,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut c_types::c_void,
        __src: *const c_types::c_void,
        __n: c_types::c_uint,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut c_types::c_void,
        __src: *const c_types::c_void,
        __n: c_types::c_uint,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut c_types::c_void,
        __src: *const c_types::c_void,
        __c: c_types::c_int,
        __n: c_types::c_uint,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut c_types::c_void,
        __c: c_types::c_int,
        __n: c_types::c_uint,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const c_types::c_void,
        __s2: *const c_types::c_void,
        __n: c_types::c_uint,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const c_types::c_void,
        __c: c_types::c_int,
        __n: c_types::c_uint,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut c_types::c_char,
        __src: *const c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut c_types::c_char,
        __src: *const c_types::c_char,
        __n: c_types::c_uint,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut c_types::c_char,
        __src: *const c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut c_types::c_char,
        __src: *const c_types::c_char,
        __n: c_types::c_uint,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const c_types::c_char, __s2: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const c_types::c_char,
        __s2: *const c_types::c_char,
        __n: c_types::c_uint,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const c_types::c_char, __s2: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut c_types::c_char,
        __src: *const c_types::c_char,
        __n: c_types::c_uint,
    ) -> c_types::c_uint;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const c_types::c_ushort,
    pub __ctype_tolower: *const c_types::c_int,
    pub __ctype_toupper: *const c_types::c_int,
    pub __names: [*const c_types::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::core::mem::MaybeUninit<__locale_struct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__locale_struct>(),
        116usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<__locale_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const c_types::c_char,
        __s2: *const c_types::c_char,
        __l: locale_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut c_types::c_char,
        __src: *const c_types::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strndup(__string: *const c_types::c_char, __n: c_types::c_uint) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strchr(__s: *const c_types::c_char, __c: c_types::c_int) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const c_types::c_char, __c: c_types::c_int) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const c_types::c_char,
        __reject: *const c_types::c_char,
    ) -> c_types::c_uint;
}
extern "C" {
    pub fn strspn(__s: *const c_types::c_char, __accept: *const c_types::c_char)
        -> c_types::c_uint;
}
extern "C" {
    pub fn strpbrk(
        __s: *const c_types::c_char,
        __accept: *const c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const c_types::c_char,
        __needle: *const c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut c_types::c_char,
        __delim: *const c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut c_types::c_char,
        __delim: *const c_types::c_char,
        __save_ptr: *mut *mut c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut c_types::c_char,
        __delim: *const c_types::c_char,
        __save_ptr: *mut *mut c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strlen(__s: *const c_types::c_char) -> c_types::c_uint;
}
extern "C" {
    pub fn strnlen(__string: *const c_types::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: c_types::c_int) -> *mut c_types::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: c_types::c_int,
        __buf: *mut c_types::c_char,
        __buflen: usize,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: c_types::c_int, __l: locale_t) -> *mut c_types::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const c_types::c_void,
        __s2: *const c_types::c_void,
        __n: c_types::c_uint,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn bcopy(__src: *const c_types::c_void, __dest: *mut c_types::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut c_types::c_void, __n: c_types::c_uint);
}
extern "C" {
    pub fn index(__s: *const c_types::c_char, __c: c_types::c_int) -> *mut c_types::c_char;
}
extern "C" {
    pub fn rindex(__s: *const c_types::c_char, __c: c_types::c_int) -> *mut c_types::c_char;
}
extern "C" {
    pub fn ffs(__i: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn ffsl(__l: c_types::c_long) -> c_types::c_int;
}
extern "C" {
    pub fn ffsll(__ll: c_types::c_longlong) -> c_types::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const c_types::c_char, __s2: *const c_types::c_char)
        -> c_types::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const c_types::c_char,
        __s2: *const c_types::c_char,
        __n: c_types::c_uint,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const c_types::c_char,
        __s2: *const c_types::c_char,
        __loc: locale_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const c_types::c_char,
        __s2: *const c_types::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut c_types::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut c_types::c_char,
        __delim: *const c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strsignal(__sig: c_types::c_int) -> *mut c_types::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut c_types::c_char,
        __src: *const c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut c_types::c_char,
        __src: *const c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut c_types::c_char,
        __src: *const c_types::c_char,
        __n: usize,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut c_types::c_char,
        __src: *const c_types::c_char,
        __n: c_types::c_uint,
    ) -> *mut c_types::c_char;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: c_types::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: c_types::c_uint,
    pub __wchb: [c_types::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::core::mem::MaybeUninit<__mbstate_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::core::mem::MaybeUninit<_G_fpos_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_G_fpos_t>(),
        12usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::core::mem::MaybeUninit<_G_fpos64_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos64_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = c_types::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: c_types::c_int,
    pub _IO_read_ptr: *mut c_types::c_char,
    pub _IO_read_end: *mut c_types::c_char,
    pub _IO_read_base: *mut c_types::c_char,
    pub _IO_write_base: *mut c_types::c_char,
    pub _IO_write_ptr: *mut c_types::c_char,
    pub _IO_write_end: *mut c_types::c_char,
    pub _IO_buf_base: *mut c_types::c_char,
    pub _IO_buf_end: *mut c_types::c_char,
    pub _IO_save_base: *mut c_types::c_char,
    pub _IO_backup_base: *mut c_types::c_char,
    pub _IO_save_end: *mut c_types::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: c_types::c_int,
    pub _flags2: c_types::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: c_types::c_ushort,
    pub _vtable_offset: c_types::c_schar,
    pub _shortbuf: [c_types::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut c_types::c_void,
    pub __pad5: usize,
    pub _mode: c_types::c_int,
    pub _unused2: [c_types::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_FILE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_FILE>(),
        148usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_FILE>(),
        4usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn rename(__old: *const c_types::c_char, __new: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: c_types::c_int,
        __old: *const c_types::c_char,
        __newfd: c_types::c_int,
        __new: *const c_types::c_char,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const c_types::c_char,
        __pfx: *const c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const c_types::c_char, __modes: *const c_types::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const c_types::c_char,
        __modes: *const c_types::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: c_types::c_int, __modes: *const c_types::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut c_types::c_void,
        __len: usize,
        __modes: *const c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut c_types::c_char, __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut c_types::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut c_types::c_char,
        __modes: c_types::c_int,
        __n: usize,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut c_types::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE, __format: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn printf(__format: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut c_types::c_char,
        __format: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const c_types::c_char,
        __arg: __builtin_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const c_types::c_char, __arg: __builtin_va_list) -> c_types::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut c_types::c_char,
        __format: *const c_types::c_char,
        __arg: __builtin_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut c_types::c_char,
        __maxlen: c_types::c_uint,
        __format: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut c_types::c_char,
        __maxlen: c_types::c_uint,
        __format: *const c_types::c_char,
        __arg: __builtin_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: c_types::c_int,
        __fmt: *const c_types::c_char,
        __arg: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn dprintf(__fd: c_types::c_int, __fmt: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE, __format: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn scanf(__format: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const c_types::c_char,
        __format: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE, __format: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const c_types::c_char,
        __format: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const c_types::c_char,
        __arg: __builtin_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const c_types::c_char, __arg: __builtin_va_list) -> c_types::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const c_types::c_char,
        __format: *const c_types::c_char,
        __arg: __builtin_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const c_types::c_char,
        __arg: __builtin_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(__format: *const c_types::c_char, __arg: __builtin_va_list) -> c_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const c_types::c_char,
        __format: *const c_types::c_char,
        __arg: __builtin_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn getchar() -> c_types::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> c_types::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fputc(__c: c_types::c_int, __stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn putc(__c: c_types::c_int, __stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn putchar(__c: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: c_types::c_int, __stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: c_types::c_int, __stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn putw(__w: c_types::c_int, __stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut c_types::c_char,
        __n: c_types::c_int,
        __stream: *mut FILE,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut c_types::c_char,
        __n: *mut usize,
        __delimiter: c_types::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut c_types::c_char,
        __n: *mut usize,
        __delimiter: c_types::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut c_types::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const c_types::c_char, __stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn puts(__s: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn ungetc(__c: c_types::c_int, __stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut c_types::c_void,
        __size: c_types::c_uint,
        __n: c_types::c_uint,
        __stream: *mut FILE,
    ) -> c_types::c_uint;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const c_types::c_void,
        __size: c_types::c_uint,
        __n: c_types::c_uint,
        __s: *mut FILE,
    ) -> c_types::c_uint;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut c_types::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const c_types::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: c_types::c_long,
        __whence: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> c_types::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> c_types::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> c_types::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn perror(__s: *const c_types::c_char);
}
extern "C" {
    pub static mut sys_nerr: c_types::c_int;
}
extern "C" {
    pub static sys_errlist: [*const c_types::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn popen(__command: *const c_types::c_char, __modes: *const c_types::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn sl_wfx_init(context: *mut sl_wfx_context_t) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_deinit() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_enable_irq() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_disable_irq() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_shutdown() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_receive_frame(ctrl_reg: *mut u16) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_send_configuration(
        pds_data: *const c_types::c_char,
        pds_data_length: u32,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_control_gpio(gpio_label: u8, gpio_mode: u8, value: *mut u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_pta_settings(
        pta_mode: u8,
        request_signal_active_level: u8,
        priority_signal_active_level: u8,
        freq_signal_active_level: u8,
        grant_signal_active_level: u8,
        coex_type: u8,
        default_grant_state: u8,
        simultaneous_rx_access: u8,
        priority_sampling_time: u8,
        tx_rx_sampling_time: u8,
        freq_sampling_time: u8,
        grant_valid_time: u8,
        fem_control_time: u8,
        first_slot_time: u8,
        periodic_tx_rx_sampling_time: u16,
        coex_quota: u16,
        wlan_quota: u16,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_pta_priority(priority: u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_pta_state(pta_state: u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_cca_config(cca_thr_mode: u8) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_prevent_rollback(magic_word: u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_get_opn(opn: *mut *mut u8) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_get_status_code(wfx_status: u32, command_id: u8) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_send_ethernet_frame(
        frame: *mut sl_wfx_send_frame_req_t,
        data_length: u32,
        interface: sl_wfx_interface_t,
        priority: u8,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_send_command(
        command_id: u8,
        data: *mut c_types::c_void,
        data_size: u32,
        interface: sl_wfx_interface_t,
        response: *mut *mut sl_wfx_generic_confirmation_t,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_send_request(
        id: u8,
        request: *mut sl_wfx_generic_message_t,
        request_length: u16,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_access_mode_message() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_mac_address(
        mac: *const sl_wfx_mac_address_t,
        interface: sl_wfx_interface_t,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_power_mode(
        mode: sl_wfx_pm_mode_t,
        strategy: sl_wfx_pm_poll_t,
        interval: u16,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_wake_up_bit(state: u8) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_enable_device_power_save() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_disable_device_power_save() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_get_signal_strength(rcpi: *mut u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_add_multicast_address(
        mac_address: *const sl_wfx_mac_address_t,
        interface: sl_wfx_interface_t,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_remove_multicast_address(
        mac_address: *const sl_wfx_mac_address_t,
        interface: sl_wfx_interface_t,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_arp_ip_address(arp_ip_addr: *mut u32, num_arp_ip_addr: u8) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_ns_ip_address(ns_ip_addr: *mut u8, num_ns_ip_addr: u8) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_broadcast_filter(filter: u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_unicast_filter(filter: u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_add_whitelist_address(mac_address: *const sl_wfx_mac_address_t) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_add_blacklist_address(mac_address: *const sl_wfx_mac_address_t) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_max_ap_client(max_clients: u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_max_ap_client_inactivity(inactivity_timeout: u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_scan_parameters(
        active_channel_time: u16,
        passive_channel_time: u16,
        num_probe_requestuests: u16,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_roam_parameters(
        rcpi_threshold: u8,
        rcpi_hysteresis: u8,
        beacon_lost_count: u8,
        channel_list: *const u8,
        channel_list_count: u8,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_tx_rate_parameters(
        rate_set_bitmask: sl_wfx_rate_set_bitmask_t,
        use_minstrel: u8,
        interface: sl_wfx_interface_t,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_max_tx_power(max_tx_power: i32, interface: sl_wfx_interface_t)
        -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_get_max_tx_power(
        max_tx_power_rf_port_1: *mut i32,
        max_tx_power_rf_port_2: *mut i32,
        interface: sl_wfx_interface_t,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_get_pmk(
        password: *mut sl_wfx_password_t,
        password_length: *mut u32,
        interface: sl_wfx_interface_t,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_get_ap_client_signal_strength(
        client: *const sl_wfx_mac_address_t,
        signal_strength: *mut u32,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_ext_auth(
        auth_data_type: sl_wfx_ext_auth_data_type_t,
        auth_data_length: u16,
        auth_data: *const u8,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_probe_request_filter(
        ie_data_mask: *const u8,
        ie_data: *const u8,
        ie_data_length: u16,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_get_statistics(stats: *mut sl_wfx_statistics_t) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_send_join_command(
        ssid: *const u8,
        ssid_length: u32,
        bssid: *const sl_wfx_mac_address_t,
        channel: u16,
        security_mode: sl_wfx_security_mode_t,
        prevent_roaming: u8,
        management_frame_protection: u16,
        passkey: *const u8,
        passkey_length: u16,
        ie_data: *const u8,
        ie_data_length: u16,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_send_disconnect_command() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_send_scan_command(
        scan_mode: u16,
        channel_list: *const u8,
        channel_list_count: u16,
        ssid_list: *const sl_wfx_ssid_def_t,
        ssid_list_count: u16,
        ie_data: *const u8,
        ie_data_length: u16,
        bssid: *const u8,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_send_stop_scan_command() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_start_ap_command(
        channel: u16,
        ssid: *mut u8,
        ssid_length: u32,
        hidden_ssid: u8,
        client_isolation: u8,
        security_mode: sl_wfx_security_mode_t,
        management_frame_protection: u8,
        passkey: *const u8,
        passkey_length: u16,
        beacon_ie_data: *const u8,
        beacon_ie_data_length: u16,
        probe_response_ie_data: *const u8,
        probe_response_ie_data_length: u16,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_update_ap_command(
        beacon_ie_data_length: u16,
        probe_response_ie_data_length: u16,
        beacon_ie_data: *mut u32,
        probe_response_ie_data: *mut u32,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_stop_ap_command() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_disconnect_ap_client_command(client: *const sl_wfx_mac_address_t) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_antenna_config(config: sl_wfx_antenna_config_t) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_allocate_command_buffer(
        buffer: *mut *mut sl_wfx_generic_message_t,
        command_id: u32,
        type_: sl_wfx_buffer_type_t,
        buffer_size: u32,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_free_command_buffer(
        buffer: *mut sl_wfx_generic_message_t,
        command_id: u32,
        type_: sl_wfx_buffer_type_t,
    ) -> sl_status_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = *mut c_types::c_char;
