#![no_std]
#![allow(nonstandard_style)]
extern crate c_types;
/* automatically generated by rust-bindgen */

pub const SL_STATUS_SPACE_MASK: u32 = 65280;
pub const SL_STATUS_GENERIC_SPACE: u32 = 0;
pub const SL_STATUS_PLATFORM_1_SPACE: u32 = 256;
pub const SL_STATUS_PLATFORM_2_SPACE: u32 = 512;
pub const SL_STATUS_HARDWARE_SPACE: u32 = 768;
pub const SL_STATUS_BLUETOOTH_SPACE: u32 = 1024;
pub const SL_STATUS_BLUETOOTH_MESH_SPACE: u32 = 1280;
pub const SL_STATUS_CAN_CANOPEN_SPACE: u32 = 1536;
pub const SL_STATUS_CONNECT_SPACE: u32 = 1792;
pub const SL_STATUS_NET_SUITE_SPACE: u32 = 2048;
pub const UINT32_THREAD_SPACE: u32 = 2304;
pub const SL_STATUS_USB_SPACE: u32 = 2560;
pub const SL_STATUS_WIFI_SPACE: u32 = 2816;
pub const SL_STATUS_ZIGBEE_SPACE: u32 = 3072;
pub const SL_STATUS_Z_WAVE_SPACE: u32 = 3328;
pub const SL_STATUS_GECKO_OS_1_SPACE: u32 = 3584;
pub const SL_STATUS_GECKO_OS_2_SPACE: u32 = 3840;
pub const SL_STATUS_BLUETOOTH_CTRL_SPACE: u32 = 4096;
pub const SL_STATUS_BLUETOOTH_ATT_SPACE: u32 = 4352;
pub const SL_STATUS_BLUETOOTH_SMP_SPACE: u32 = 4608;
pub const SL_STATUS_BLUETOOTH_MESH_FOUNDATION_SPACE: u32 = 4864;
pub const SL_STATUS_OK: u32 = 0;
pub const SL_STATUS_FAIL: u32 = 1;
pub const SL_STATUS_INVALID_STATE: u32 = 2;
pub const SL_STATUS_NOT_READY: u32 = 3;
pub const SL_STATUS_BUSY: u32 = 4;
pub const SL_STATUS_IN_PROGRESS: u32 = 5;
pub const SL_STATUS_ABORT: u32 = 6;
pub const UINT32_TIMEOUT: u32 = 7;
pub const SL_STATUS_PERMISSION: u32 = 8;
pub const SL_STATUS_WOULD_BLOCK: u32 = 9;
pub const SL_STATUS_IDLE: u32 = 10;
pub const SL_STATUS_IS_WAITING: u32 = 11;
pub const SL_STATUS_NONE_WAITING: u32 = 12;
pub const SL_STATUS_SUSPENDED: u32 = 13;
pub const SL_STATUS_NOT_AVAILABLE: u32 = 14;
pub const SL_STATUS_NOT_SUPPORTED: u32 = 15;
pub const SL_STATUS_INITIALIZATION: u32 = 16;
pub const SL_STATUS_NOT_INITIALIZED: u32 = 17;
pub const SL_STATUS_ALREADY_INITIALIZED: u32 = 18;
pub const SL_STATUS_DELETED: u32 = 19;
pub const SL_STATUS_ISR: u32 = 20;
pub const SL_STATUS_NETWORK_UP: u32 = 21;
pub const SL_STATUS_NETWORK_DOWN: u32 = 22;
pub const SL_STATUS_NOT_JOINED: u32 = 23;
pub const SL_STATUS_NO_BEACONS: u32 = 24;
pub const SL_STATUS_ALLOCATION_FAILED: u32 = 25;
pub const SL_STATUS_NO_MORE_RESOURCE: u32 = 26;
pub const SL_STATUS_EMPTY: u32 = 27;
pub const SL_STATUS_FULL: u32 = 28;
pub const SL_STATUS_WOULD_OVERFLOW: u32 = 29;
pub const SL_STATUS_HAS_OVERFLOWED: u32 = 30;
pub const SL_STATUS_OWNERSHIP: u32 = 31;
pub const SL_STATUS_IS_OWNER: u32 = 32;
pub const SL_STATUS_INVALID_PARAMETER: u32 = 33;
pub const SL_STATUS_NULL_POINTER: u32 = 34;
pub const SL_STATUS_INVALID_CONFIGURATION: u32 = 35;
pub const SL_STATUS_INVALID_MODE: u32 = 36;
pub const SL_STATUS_INVALID_HANDLE: u32 = 37;
pub const SL_STATUS_INVALID_TYPE: u32 = 38;
pub const SL_STATUS_INVALID_INDEX: u32 = 39;
pub const SL_STATUS_INVALID_RANGE: u32 = 40;
pub const SL_STATUS_INVALID_KEY: u32 = 41;
pub const SL_STATUS_INVALID_CREDENTIALS: u32 = 42;
pub const SL_STATUS_INVALID_COUNT: u32 = 43;
pub const SL_STATUS_NOT_FOUND: u32 = 44;
pub const SL_STATUS_ALREADY_EXISTS: u32 = 45;
pub const SL_STATUS_IO: u32 = 46;
pub const SL_STATUS_IO_TIMEOUT: u32 = 47;
pub const UINT32_TRANSMIT: u32 = 48;
pub const UINT32_TRANSMIT_UNDERFLOW: u32 = 49;
pub const UINT32_TRANSMIT_INCOMPLETE: u32 = 50;
pub const UINT32_TRANSMIT_BUSY: u32 = 51;
pub const SL_STATUS_RECEIVE: u32 = 52;
pub const SL_STATUS_OBJECT_READ: u32 = 53;
pub const SL_STATUS_OBJECT_WRITE: u32 = 54;
pub const SL_STATUS_MESSAGE_TOO_LONG: u32 = 55;
pub const SL_STATUS_EEPROM_MFG_VERSION_MISMATCH: u32 = 56;
pub const SL_STATUS_EEPROM_STACK_VERSION_MISMATCH: u32 = 57;
pub const SL_STATUS_FLASH_WRITE_INHIBITED: u32 = 58;
pub const SL_STATUS_FLASH_VERIFY_FAILED: u32 = 59;
pub const SL_STATUS_FLASH_PROGRAM_FAILED: u32 = 60;
pub const SL_STATUS_FLASH_ERASE_FAILED: u32 = 61;
pub const SL_STATUS_MAC_NO_DATA: u32 = 62;
pub const SL_STATUS_MAC_NO_ACK_RECEIVED: u32 = 63;
pub const SL_STATUS_MAC_INDIRECT_TIMEOUT: u32 = 64;
pub const SL_STATUS_MAC_UNKNOWN_HEADER_TYPE: u32 = 65;
pub const SL_STATUS_MAC_ACK_HEADER_TYPE: u32 = 66;
pub const SL_STATUS_MAC_COMMAND_TRANSMIT_FAILURE: u32 = 67;
pub const SL_STATUS_CLI_STORAGE_NVM_OPEN_ERROR: u32 = 68;
pub const SL_STATUS_SECURITY_IMAGE_CHECKSUM_ERROR: u32 = 69;
pub const SL_STATUS_SECURITY_DECRYPT_ERROR: u32 = 70;
pub const SL_STATUS_COMMAND_IS_INVALID: u32 = 71;
pub const SL_STATUS_COMMAND_TOO_LONG: u32 = 72;
pub const SL_STATUS_COMMAND_INCOMPLETE: u32 = 73;
pub const SL_STATUS_BT_OUT_OF_BONDS: u32 = 1026;
pub const SL_STATUS_BT_UNSPECIFIED: u32 = 1027;
pub const SL_STATUS_BT_HARDWARE: u32 = 1028;
pub const SL_STATUS_BT_NO_BONDING: u32 = 1030;
pub const SL_STATUS_BT_CRYPTO: u32 = 1031;
pub const SL_STATUS_BT_DATA_CORRUPTED: u32 = 1032;
pub const SL_STATUS_BT_INVALID_SYNC_HANDLE: u32 = 1034;
pub const SL_STATUS_BT_INVALID_MODULE_ACTION: u32 = 1035;
pub const SL_STATUS_BT_RADIO: u32 = 1036;
pub const SL_STATUS_BT_L2CAP_REMOTE_DISCONNECTED: u32 = 1037;
pub const SL_STATUS_BT_L2CAP_LOCAL_DISCONNECTED: u32 = 1038;
pub const SL_STATUS_BT_L2CAP_CID_NOT_EXIST: u32 = 1039;
pub const SL_STATUS_BT_L2CAP_LE_DISCONNECTED: u32 = 1040;
pub const SL_STATUS_BT_L2CAP_FLOW_CONTROL_VIOLATED: u32 = 1042;
pub const SL_STATUS_BT_L2CAP_FLOW_CONTROL_CREDIT_OVERFLOWED: u32 = 1043;
pub const SL_STATUS_BT_L2CAP_NO_FLOW_CONTROL_CREDIT: u32 = 1044;
pub const SL_STATUS_BT_L2CAP_CONNECTION_REQUEST_TIMEOUT: u32 = 1045;
pub const SL_STATUS_BT_L2CAP_INVALID_CID: u32 = 1046;
pub const SL_STATUS_BT_L2CAP_WRONG_STATE: u32 = 1047;
pub const SL_STATUS_BT_PS_STORE_FULL: u32 = 1051;
pub const SL_STATUS_BT_PS_KEY_NOT_FOUND: u32 = 1052;
pub const SL_STATUS_BT_APPLICATION_MISMATCHED_OR_INSUFFICIENT_SECURITY: u32 = 1053;
pub const SL_STATUS_BT_APPLICATION_ENCRYPTION_DECRYPTION_ERROR: u32 = 1054;
pub const SL_STATUS_BT_CTRL_UNKNOWN_CONNECTION_IDENTIFIER: u32 = 4098;
pub const SL_STATUS_BT_CTRL_AUTHENTICATION_FAILURE: u32 = 4101;
pub const SL_STATUS_BT_CTRL_PIN_OR_KEY_MISSING: u32 = 4102;
pub const SL_STATUS_BT_CTRL_MEMORY_CAPACITY_EXCEEDED: u32 = 4103;
pub const SL_STATUS_BT_CTRL_CONNECTION_TIMEOUT: u32 = 4104;
pub const SL_STATUS_BT_CTRL_CONNECTION_LIMIT_EXCEEDED: u32 = 4105;
pub const SL_STATUS_BT_CTRL_SYNCHRONOUS_CONNECTIONTION_LIMIT_EXCEEDED: u32 = 4106;
pub const SL_STATUS_BT_CTRL_ACL_CONNECTION_ALREADY_EXISTS: u32 = 4107;
pub const SL_STATUS_BT_CTRL_COMMAND_DISALLOWED: u32 = 4108;
pub const SL_STATUS_BT_CTRL_CONNECTION_REJECTED_DUE_TO_LIMITED_RESOURCES: u32 = 4109;
pub const SL_STATUS_BT_CTRL_CONNECTION_REJECTED_DUE_TO_SECURITY_REASONS: u32 = 4110;
pub const SL_STATUS_BT_CTRL_CONNECTION_REJECTED_DUE_TO_UNACCEPTABLE_BD_ADDR: u32 = 4111;
pub const SL_STATUS_BT_CTRL_CONNECTION_ACCEPT_TIMEOUT_EXCEEDED: u32 = 4112;
pub const SL_STATUS_BT_CTRL_UNSUPPORTED_FEATURE_OR_PARAMETER_VALUE: u32 = 4113;
pub const SL_STATUS_BT_CTRL_INVALID_COMMAND_PARAMETERS: u32 = 4114;
pub const SL_STATUS_BT_CTRL_REMOTE_USER_TERMINATED: u32 = 4115;
pub const SL_STATUS_BT_CTRL_REMOTE_DEVICE_TERMINATED_CONNECTION_DUE_TO_LOW_RESOURCES: u32 = 4116;
pub const SL_STATUS_BT_CTRL_REMOTE_POWERING_OFF: u32 = 4117;
pub const SL_STATUS_BT_CTRL_CONNECTION_TERMINATED_BY_LOCAL_HOST: u32 = 4118;
pub const SL_STATUS_BT_CTRL_REPEATED_ATTEMPTS: u32 = 4119;
pub const SL_STATUS_BT_CTRL_PAIRING_NOT_ALLOWED: u32 = 4120;
pub const SL_STATUS_BT_CTRL_UNSUPPORTED_REMOTE_FEATURE: u32 = 4122;
pub const SL_STATUS_BT_CTRL_UNSPECIFIED_ERROR: u32 = 4127;
pub const SL_STATUS_BT_CTRL_LL_RESPONSE_TIMEOUT: u32 = 4130;
pub const SL_STATUS_BT_CTRL_LL_PROCEDURE_COLLISION: u32 = 4131;
pub const SL_STATUS_BT_CTRL_ENCRYPTION_MODE_NOT_ACCEPTABLE: u32 = 4133;
pub const SL_STATUS_BT_CTRL_LINK_KEY_CANNOT_BE_CHANGED: u32 = 4134;
pub const SL_STATUS_BT_CTRL_INSTANT_PASSED: u32 = 4136;
pub const SL_STATUS_BT_CTRL_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED: u32 = 4137;
pub const SL_STATUS_BT_CTRL_DIFFERENT_TRANSACTION_COLLISION: u32 = 4138;
pub const SL_STATUS_BT_CTRL_CHANNEL_ASSESSMENT_NOT_SUPPORTED: u32 = 4142;
pub const SL_STATUS_BT_CTRL_INSUFFICIENT_SECURITY: u32 = 4143;
pub const SL_STATUS_BT_CTRL_PARAMETER_OUT_OF_MANDATORY_RANGE: u32 = 4144;
pub const SL_STATUS_BT_CTRL_SIMPLE_PAIRING_NOT_SUPPORTED_BY_HOST: u32 = 4151;
pub const SL_STATUS_BT_CTRL_HOST_BUSY_PAIRING: u32 = 4152;
pub const SL_STATUS_BT_CTRL_CONNECTION_REJECTED_DUE_TO_NO_SUITABLE_CHANNEL_FOUND: u32 = 4153;
pub const SL_STATUS_BT_CTRL_CONTROLLER_BUSY: u32 = 4154;
pub const SL_STATUS_BT_CTRL_UNACCEPTABLE_CONNECTION_INTERVAL: u32 = 4155;
pub const SL_STATUS_BT_CTRL_ADVERTISING_TIMEOUT: u32 = 4156;
pub const SL_STATUS_BT_CTRL_CONNECTION_TERMINATED_DUE_TO_MIC_FAILURE: u32 = 4157;
pub const SL_STATUS_BT_CTRL_CONNECTION_FAILED_TO_BE_ESTABLISHED: u32 = 4158;
pub const SL_STATUS_BT_CTRL_MAC_CONNECTION_FAILED: u32 = 4159;
pub const SL_STATUS_BT_CTRL_COARSE_CLOCK_ADJUSTMENT_REJECTED_BUT_WILL_TRY_TO_ADJUST_USING_CLOCK_DRAGGING : u32 = 4160 ;
pub const SL_STATUS_BT_CTRL_UNKNOWN_ADVERTISING_IDENTIFIER: u32 = 4162;
pub const SL_STATUS_BT_CTRL_LIMIT_REACHED: u32 = 4163;
pub const SL_STATUS_BT_CTRL_OPERATION_CANCELLED_BY_HOST: u32 = 4164;
pub const SL_STATUS_BT_CTRL_PACKET_TOO_LONG: u32 = 4165;
pub const SL_STATUS_BT_ATT_INVALID_HANDLE: u32 = 4353;
pub const SL_STATUS_BT_ATT_READ_NOT_PERMITTED: u32 = 4354;
pub const SL_STATUS_BT_ATT_WRITE_NOT_PERMITTED: u32 = 4355;
pub const SL_STATUS_BT_ATT_INVALID_PDU: u32 = 4356;
pub const SL_STATUS_BT_ATT_INSUFFICIENT_AUTHENTICATION: u32 = 4357;
pub const SL_STATUS_BT_ATT_REQUEST_NOT_SUPPORTED: u32 = 4358;
pub const SL_STATUS_BT_ATT_INVALID_OFFSET: u32 = 4359;
pub const SL_STATUS_BT_ATT_INSUFFICIENT_AUTHORIZATION: u32 = 4360;
pub const SL_STATUS_BT_ATT_PREPARE_QUEUE_FULL: u32 = 4361;
pub const SL_STATUS_BT_ATT_ATT_NOT_FOUND: u32 = 4362;
pub const SL_STATUS_BT_ATT_ATT_NOT_LONG: u32 = 4363;
pub const SL_STATUS_BT_ATT_INSUFFICIENT_ENC_KEY_SIZE: u32 = 4364;
pub const SL_STATUS_BT_ATT_INVALID_ATT_LENGTH: u32 = 4365;
pub const SL_STATUS_BT_ATT_UNLIKELY_ERROR: u32 = 4366;
pub const SL_STATUS_BT_ATT_INSUFFICIENT_ENCRYPTION: u32 = 4367;
pub const SL_STATUS_BT_ATT_UNSUPPORTED_GROUP_TYPE: u32 = 4368;
pub const SL_STATUS_BT_ATT_INSUFFICIENT_RESOURCES: u32 = 4369;
pub const SL_STATUS_BT_ATT_OUT_OF_SYNC: u32 = 4370;
pub const SL_STATUS_BT_ATT_VALUE_NOT_ALLOWED: u32 = 4371;
pub const SL_STATUS_BT_ATT_APPLICATION: u32 = 4480;
pub const SL_STATUS_BT_SMP_PASSKEY_ENTRY_FAILED: u32 = 4609;
pub const SL_STATUS_BT_SMP_OOB_NOT_AVAILABLE: u32 = 4610;
pub const SL_STATUS_BT_SMP_AUTHENTICATION_REQUIREMENTS: u32 = 4611;
pub const SL_STATUS_BT_SMP_CONFIRM_VALUE_FAILED: u32 = 4612;
pub const SL_STATUS_BT_SMP_PAIRING_NOT_SUPPORTED: u32 = 4613;
pub const SL_STATUS_BT_SMP_ENCRYPTION_KEY_SIZE: u32 = 4614;
pub const SL_STATUS_BT_SMP_COMMAND_NOT_SUPPORTED: u32 = 4615;
pub const SL_STATUS_BT_SMP_UNSPECIFIED_REASON: u32 = 4616;
pub const SL_STATUS_BT_SMP_REPEATED_ATTEMPTS: u32 = 4617;
pub const SL_STATUS_BT_SMP_INVALID_PARAMETERS: u32 = 4618;
pub const SL_STATUS_BT_SMP_DHKEY_CHECK_FAILED: u32 = 4619;
pub const SL_STATUS_BT_SMP_NUMERIC_COMPARISON_FAILED: u32 = 4620;
pub const SL_STATUS_BT_SMP_BREDR_PAIRING_IN_PROGRESS: u32 = 4621;
pub const SL_STATUS_BT_SMP_CROSS_TRANSPORT_KEY_DERIVATION_GENERATION_NOT_ALLOWED: u32 = 4622;
pub const SL_STATUS_BT_MESH_ALREADY_EXISTS: u32 = 1281;
pub const SL_STATUS_BT_MESH_DOES_NOT_EXIST: u32 = 1282;
pub const SL_STATUS_BT_MESH_LIMIT_REACHED: u32 = 1283;
pub const SL_STATUS_BT_MESH_INVALID_ADDRESS: u32 = 1284;
pub const SL_STATUS_BT_MESH_MALFORMED_DATA: u32 = 1285;
pub const SL_STATUS_BT_MESH_ALREADY_INITIALIZED: u32 = 1286;
pub const SL_STATUS_BT_MESH_NOT_INITIALIZED: u32 = 1287;
pub const SL_STATUS_BT_MESH_NO_FRIEND_OFFER: u32 = 1288;
pub const SL_STATUS_BT_MESH_PROV_LINK_CLOSED: u32 = 1289;
pub const SL_STATUS_BT_MESH_PROV_INVALID_PDU: u32 = 1290;
pub const SL_STATUS_BT_MESH_PROV_INVALID_PDU_FORMAT: u32 = 1291;
pub const SL_STATUS_BT_MESH_PROV_UNEXPECTED_PDU: u32 = 1292;
pub const SL_STATUS_BT_MESH_PROV_CONFIRMATION_FAILED: u32 = 1293;
pub const SL_STATUS_BT_MESH_PROV_OUT_OF_RESOURCES: u32 = 1294;
pub const SL_STATUS_BT_MESH_PROV_DECRYPTION_FAILED: u32 = 1295;
pub const SL_STATUS_BT_MESH_PROV_UNEXPECTED_ERROR: u32 = 1296;
pub const SL_STATUS_BT_MESH_PROV_CANNOT_ASSIGN_ADDR: u32 = 1297;
pub const SL_STATUS_BT_MESH_ADDRESS_TEMPORARILY_UNAVAILABLE: u32 = 1298;
pub const SL_STATUS_BT_MESH_ADDRESS_ALREADY_USED: u32 = 1299;
pub const SL_STATUS_BT_MESH_FOUNDATION_INVALID_ADDRESS: u32 = 4865;
pub const SL_STATUS_BT_MESH_FOUNDATION_INVALID_MODEL: u32 = 4866;
pub const SL_STATUS_BT_MESH_FOUNDATION_INVALID_APP_KEY: u32 = 4867;
pub const SL_STATUS_BT_MESH_FOUNDATION_INVALID_NET_KEY: u32 = 4868;
pub const SL_STATUS_BT_MESH_FOUNDATION_INSUFFICIENT_RESOURCES: u32 = 4869;
pub const SL_STATUS_BT_MESH_FOUNDATION_KEY_INDEX_EXISTS: u32 = 4870;
pub const SL_STATUS_BT_MESH_FOUNDATION_INVALID_PUBLISH_PARAMS: u32 = 4871;
pub const SL_STATUS_BT_MESH_FOUNDATION_NOT_SUBSCRIBE_MODEL: u32 = 4872;
pub const SL_STATUS_BT_MESH_FOUNDATION_STORAGE_FAILURE: u32 = 4873;
pub const SL_STATUS_BT_MESH_FOUNDATION_NOT_SUPPORTED: u32 = 4874;
pub const SL_STATUS_BT_MESH_FOUNDATION_CANNOT_UPDATE: u32 = 4875;
pub const SL_STATUS_BT_MESH_FOUNDATION_CANNOT_REMOVE: u32 = 4876;
pub const SL_STATUS_BT_MESH_FOUNDATION_CANNOT_BIND: u32 = 4877;
pub const SL_STATUS_BT_MESH_FOUNDATION_TEMPORARILY_UNABLE: u32 = 4878;
pub const SL_STATUS_BT_MESH_FOUNDATION_CANNOT_SET: u32 = 4879;
pub const SL_STATUS_BT_MESH_FOUNDATION_UNSPECIFIED: u32 = 4880;
pub const SL_STATUS_BT_MESH_FOUNDATION_INVALID_BINDING: u32 = 4881;
pub const SL_STATUS_WIFI_INVALID_KEY: u32 = 2817;
pub const SL_STATUS_WIFI_FIRMWARE_DOWNLOAD_TIMEOUT: u32 = 2818;
pub const SL_STATUS_WIFI_UNSUPPORTED_MESSAGE_ID: u32 = 2819;
pub const SL_STATUS_WIFI_WARNING: u32 = 2820;
pub const SL_STATUS_WIFI_NO_PACKET_TO_RECEIVE: u32 = 2821;
pub const SL_STATUS_WIFI_SLEEP_GRANTED: u32 = 2824;
pub const SL_STATUS_WIFI_SLEEP_NOT_GRANTED: u32 = 2825;
pub const SL_STATUS_WIFI_SECURE_LINK_MAC_KEY_ERROR: u32 = 2832;
pub const SL_STATUS_WIFI_SECURE_LINK_MAC_KEY_ALREADY_BURNED: u32 = 2833;
pub const SL_STATUS_WIFI_SECURE_LINK_RAM_MODE_NOT_ALLOWED: u32 = 2834;
pub const SL_STATUS_WIFI_SECURE_LINK_FAILED_UNKNOWN_MODE: u32 = 2835;
pub const SL_STATUS_WIFI_SECURE_LINK_EXCHANGE_FAILED: u32 = 2836;
pub const SL_STATUS_WIFI_WRONG_STATE: u32 = 2840;
pub const SL_STATUS_WIFI_CHANNEL_NOT_ALLOWED: u32 = 2841;
pub const SL_STATUS_WIFI_NO_MATCHING_AP: u32 = 2842;
pub const SL_STATUS_WIFI_CONNECTION_ABORTED: u32 = 2843;
pub const SL_STATUS_WIFI_CONNECTION_TIMEOUT: u32 = 2844;
pub const SL_STATUS_WIFI_CONNECTION_REJECTED_BY_AP: u32 = 2845;
pub const SL_STATUS_WIFI_CONNECTION_AUTH_FAILURE: u32 = 2846;
pub const SL_STATUS_WIFI_RETRY_EXCEEDED: u32 = 2847;
pub const SL_STATUS_WIFI_TX_LIFETIME_EXCEEDED: u32 = 2848;
/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201505;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 23;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const _BITS_WCHAR_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const SL_WFX_API_VERSION_MINOR: u32 = 3;
pub const SL_WFX_API_VERSION_MAJOR: u32 = 2;
pub const SL_WFX_SSID_SIZE: u32 = 32;
pub const SL_WFX_MAC_ADDR_SIZE: u32 = 6;
pub const SL_WFX_BSSID_SIZE: u32 = 6;
pub const GENERAL_INTERFACE_ID: u32 = 2;
pub const SL_WFX_MSG_ID_MASK: u32 = 255;
pub const SL_WFX_MSG_TYPE_MASK: u32 = 128;
pub const SL_WFX_MSG_SEQ_RANGE: u32 = 7;
pub const SL_WFX_REQ_BASE: u32 = 0;
pub const SL_WFX_CNF_BASE: u32 = 0;
pub const SL_WFX_IND_BASE: u32 = 128;
pub const SL_WFX_OPN_SIZE: u32 = 14;
pub const SL_WFX_UID_SIZE: u32 = 8;
pub const SL_WFX_DISABLED_CHANNEL_LIST_SIZE: u32 = 2;
pub const SL_WFX_FIRMWARE_LABEL_SIZE: u32 = 128;
pub const SL_WFX_EXCEPTION_DATA_SIZE: u32 = 124;
pub const SL_WFX_KEY_VALUE_SIZE: u32 = 32;
pub const SL_WFX_HOST_PUB_KEY_SIZE: u32 = 32;
pub const SL_WFX_HOST_PUB_KEY_MAC_SIZE: u32 = 64;
pub const SL_WFX_NCP_PUB_KEY_SIZE: u32 = 32;
pub const SL_WFX_NCP_PUB_KEY_MAC_SIZE: u32 = 64;
pub const SL_WFX_SESSION_KEY_PROTECTION_DISABLE_MAGIC: u32 = 4196525571;
pub const SL_WFX_ENCR_BMP_SIZE: u32 = 32;
pub const SL_WFX_FMAC_MAC_ADDR_SIZE: u32 = 6;
pub const SL_WFX_FMAC_BSSID_SIZE: u32 = 6;
pub const SL_WFX_PASSWORD_SIZE: u32 = 64;
pub const SL_WFX_CHANNEL_NUMBER_SIZE: u32 = 14;
pub const SL_WFX_SSID_DEF_SIZE: u32 = 2;
pub const SL_WFX_FMAC_SSID_SIZE: u32 = 32;
pub const SL_WFX_ARP_IP_ADDR_SIZE: u32 = 2;
pub const SL_WFX_NS_IP_ADDR_SIZE: u32 = 2;
pub const SL_WFX_IPV6_ADDR_SIZE: u32 = 16;
pub const FIRMWARE_VERSION: &'static [u8; 6usize] = b"3.3.1\0";
pub const FMAC_DRIVER_VERSION_MAJOR: u32 = 2;
pub const FMAC_DRIVER_VERSION_MINOR: u32 = 3;
pub const FMAC_DRIVER_VERSION_REVISION: u32 = 2;
pub const FMAC_DRIVER_VERSION_RC: u32 = 255;
pub const FMAC_DRIVER_RC_RELEASE: u32 = 255;
pub const FMAC_DRIVER_RC_DEVELOPMENT: u32 = 0;
pub const FMAC_DRIVER_VERSION_STRING_SUFFIX: &'static [u8; 1usize] = b"\0";
pub const FMAC_DRIVER_VERSION: u32 = 33751807;
pub const SL_WAIT_FOREVER: u32 = 4294967295;
pub const SL_WFX_DEBUG_MASK: u32 = 0;
pub const SL_WFX_DEBUG_ERROR: u32 = 1;
pub const SL_WFX_DEBUG_INIT: u32 = 2;
pub const SL_WFX_DEBUG_SLEEP: u32 = 4;
pub const SL_WFX_DEBUG_SLK: u32 = 8;
pub const SL_WFX_DEBUG_RX: u32 = 16;
pub const SL_WFX_DEBUG_RX_RAW: u32 = 32;
pub const SL_WFX_DEBUG_RX_REG: u32 = 64;
pub const SL_WFX_DEBUG_TX: u32 = 128;
pub const SL_WFX_DEBUG_TX_RAW: u32 = 256;
pub const SL_WFX_DEBUG_TX_REG: u32 = 512;
pub const SL_WFX_DEBUG_FW_LOAD: u32 = 1024;
pub const IE_RSNE_ID: u32 = 48;
pub const IE_RSNE_CIPHER_SUITE_TKIP: u32 = 44830464;
pub const IE_RSNE_CIPHER_SUITE_CCMP: u32 = 78384896;
pub const IE_VENDOR_SPECIFIC_ID: u32 = 221;
pub const IE_WPA_OUI: u32 = 20722;
pub const PDS_HF_CLK_KEY: u8 = 101u8;
pub const PDS_POWER_CONFIG_KEY: u8 = 104u8;
pub const PDS_ANTENNA_SEL_KEY: u8 = 106u8;
pub const PDS_KEY_A: u8 = 97u8;
pub const PDS_KEY_B: u8 = 98u8;
pub const PDS_KEY_C: u8 = 99u8;
pub const PDS_KEY_D: u8 = 100u8;
pub const PDS_KEY_E: u8 = 101u8;
pub const PDS_KEY_F: u8 = 102u8;
pub const WFX_PTE_INFO: u32 = 151044288;
pub const PTE_INFO_KEYSET_IDX: u32 = 13;
pub const PTE_INFO_SIZE: u32 = 16;
pub const SL_WFX_MSG_ID_GENERAL_API_MASK: u32 = 32;
pub const SL_WFX_MSG_INFO_INTERFACE_OFFSET: u32 = 1;
pub const SL_WFX_MSG_INFO_INTERFACE_MASK: u32 = 6;
pub const SL_WFX_CONT_FRAME_TYPE_OFFSET: u32 = 14;
pub const SL_WFX_CONFIG_REVISION_OFFSET: u32 = 24;
pub const SL_WFX_CONFIG_REVISION_MASK: u32 = 7;
pub const SL_WFX_CONFIG_TYPE_OFFSET: u32 = 31;
pub const SL_WFX_CONFIG_TYPE_MASK: u32 = 1;
pub const SL_WFX_CTRL_REGISTER_SIZE: u32 = 2;
pub const SL_WFX_ROUND_UP_VALUE: u32 = 1;
pub const SL_WFX_DEFAULT_REQUEST_TIMEOUT_MS: u32 = 5000;
pub const SYS_BASE_ADDR_SILICON: u32 = 0;
pub const PAC_BASE_ADDRESS_SILICON: u32 = 150994944;
pub const PAC_SHARED_MEMORY_SILICON: u32 = 150994944;
pub const DOWNLOAD_BOOT_LOADER_OFFSET: u32 = 0;
pub const DOWNLOAD_FIFO_SIZE: u32 = 32768;
pub const DOWNLOAD_CTRL_DATA_DWORDS: u32 = 26;
pub const DOWNLOAD_CTRL_OFFSET: u32 = 151044096;
pub const DOWNLOAD_IMAGE_SIZE_REG: u32 = 151044096;
pub const DOWNLOAD_DEBUG_DATA_LEN: u32 = 108;
pub const DOWNLOAD_BLOCK_SIZE: u32 = 1024;
pub const ADDR_DWL_CTRL_AREA: u32 = 151044096;
pub const FW_KEYSET_SIZE: u32 = 8;
pub const FW_SIGNATURE_SIZE: u32 = 64;
pub const FW_HASH_SIZE: u32 = 8;
pub const ADDR_DWL_CTRL_AREA_IMAGE_SIZE: u32 = 151044096;
pub const ADDR_DWL_CTRL_AREA_PUT: u32 = 151044100;
pub const ADDR_DWL_CTRL_AREA_GET: u32 = 151044104;
pub const ADDR_DWL_CTRL_AREA_HOST_STATUS: u32 = 151044108;
pub const ADDR_DWL_CTRL_AREA_NCP_STATUS: u32 = 151044112;
pub const ADDR_DWL_CTRL_AREA_SIGNATURE: u32 = 151044116;
pub const ADDR_DWL_CTRL_AREA_FW_HASH: u32 = 151044180;
pub const ADDR_DWL_CTRL_AREA_FW_VERSION: u32 = 151044188;
pub const HOST_STATE_UNDEF: u32 = 4294967295;
pub const HOST_STATE_NOT_READY: u32 = 305419896;
pub const HOST_STATE_READY: u32 = 2271560481;
pub const HOST_STATE_HOST_INFO_READ: u32 = 2807283097;
pub const HOST_STATE_UPLOAD_PENDING: u32 = 2882395322;
pub const HOST_STATE_UPLOAD_COMPLETE: u32 = 3569765017;
pub const HOST_STATE_OK_TO_JUMP: u32 = 391104642;
pub const NCP_STATE_UNDEF: u32 = 4294967295;
pub const NCP_STATE_NOT_READY: u32 = 305419896;
pub const NCP_STATE_INFO_READY: u32 = 3176394649;
pub const NCP_STATE_READY: u32 = 2271560481;
pub const NCP_STATE_DOWNLOAD_PENDING: u32 = 2882395322;
pub const NCP_STATE_DOWNLOAD_COMPLETE: u32 = 3405709002;
pub const NCP_STATE_AUTH_OK: u32 = 3569765017;
pub const NCP_STATE_AUTH_FAIL: u32 = 391104642;
pub const NCP_STATE_PUB_KEY_RDY: u32 = 2058624281;
pub const ADDR_DOWNLOAD_FIFO_BASE: u32 = 151011328;
pub const ADDR_DOWNLOAD_FIFO_END: u32 = 151044096;
pub const ADDR_SHARED_RAM_DEBUG_AREA: u32 = 151003136;
pub const SL_WFX_CONT_NEXT_LEN_MASK: u32 = 4095;
pub const SL_WFX_SDIO_CCCR_IO_QUEUE_ENABLE: u32 = 2;
pub const SL_WFX_SDIO_CCCR_IRQ_ENABLE: u32 = 4;
pub const SL_WFX_SDIO_CCCR_BUS_INTERFACE_CONTROL: u32 = 7;
pub const SL_WFX_SDIO_CCCR_HIGH_SPEED_ENABLE: u32 = 19;
pub const SL_WFX_SDIO_FBR1_BLOCK_SIZE_LSB: u32 = 272;
pub const SL_WFX_SDIO_FBR1_BLOCK_SIZE_MSB: u32 = 273;
pub const FW_VERSION_VALUE: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const _SIGSET_H_types: u32 = 1;
pub const __timespec_defined: u32 = 1;
pub const _STRUCT_TIMEVAL: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _SYS_SYSMACROS_H: u32 = 1;
pub const _BITS_PTHREADTYPES_H: u32 = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __have_pthread_attr_t: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _XLOCALE_H: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const _G_config_h: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub type int_least8_t = c_types::c_schar;
pub type int_least16_t = c_types::c_short;
pub type int_least32_t = c_types::c_int;
pub type int_least64_t = c_types::c_long;
pub type uint_least8_t = c_types::c_uchar;
pub type uint_least16_t = c_types::c_ushort;
pub type uint_least32_t = c_types::c_uint;
pub type uint_least64_t = c_types::c_ulong;
pub type int_fast8_t = c_types::c_schar;
pub type int_fast16_t = c_types::c_long;
pub type int_fast32_t = c_types::c_long;
pub type int_fast64_t = c_types::c_long;
pub type uint_fast8_t = c_types::c_uchar;
pub type uint_fast16_t = c_types::c_ulong;
pub type uint_fast32_t = c_types::c_ulong;
pub type uint_fast64_t = c_types::c_ulong;
pub type intmax_t = c_types::c_long;
pub type uintmax_t = c_types::c_ulong;
#[doc = "   DATA TYPES   *******************************"]
pub type sl_status_t = u32;
#[doc = "< Data rate 802.11b 1Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_B_1MBPS: sl_wfx_rate_index_e = 0;
#[doc = "< Data rate 802.11b 2Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_B_2MBPS: sl_wfx_rate_index_e = 1;
#[doc = "< Data rate 802.11b 5.5Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_B_5P5MBPS: sl_wfx_rate_index_e = 2;
#[doc = "< Data rate 802.11b 11Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_B_11MBPS: sl_wfx_rate_index_e = 3;
#[doc = "<ERP-PBCC, not supported"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_PBCC_22MBPS: sl_wfx_rate_index_e = 4;
#[doc = "<ERP-PBCC, not supported"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_PBCC_33MBPS: sl_wfx_rate_index_e = 5;
#[doc = "< Data rate 802.11g 6Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_G_6MBPS: sl_wfx_rate_index_e = 6;
#[doc = "< Data rate 802.11g 9Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_G_9MBPS: sl_wfx_rate_index_e = 7;
#[doc = "< Data rate 802.11g 12Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_G_12MBPS: sl_wfx_rate_index_e = 8;
#[doc = "< Data rate 802.11g 18Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_G_18MBPS: sl_wfx_rate_index_e = 9;
#[doc = "< Data rate 802.11g 24Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_G_24MBPS: sl_wfx_rate_index_e = 10;
#[doc = "< Data rate 802.11g 36Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_G_36MBPS: sl_wfx_rate_index_e = 11;
#[doc = "< Data rate 802.11g 48Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_G_48MBPS: sl_wfx_rate_index_e = 12;
#[doc = "< Data rate 802.11g 54Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_G_54MBPS: sl_wfx_rate_index_e = 13;
#[doc = "< Data rate 802.11n 6.5Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_N_6P5MBPS: sl_wfx_rate_index_e = 14;
#[doc = "< Data rate 802.11n 13Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_N_13MBPS: sl_wfx_rate_index_e = 15;
#[doc = "< Data rate 802.11n 19.5Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_N_19P5MBPS: sl_wfx_rate_index_e = 16;
#[doc = "< Data rate 802.11n 26Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_N_26MBPS: sl_wfx_rate_index_e = 17;
#[doc = "< Data rate 802.11n 39Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_N_39MBPS: sl_wfx_rate_index_e = 18;
#[doc = "< Data rate 802.11n 52Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_N_52MBPS: sl_wfx_rate_index_e = 19;
#[doc = "< Data rate 802.11n 58.5Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_N_58P5MBPS: sl_wfx_rate_index_e = 20;
#[doc = "< Data rate 802.11n 65Mbps"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_INDEX_N_65MBPS: sl_wfx_rate_index_e = 21;
#[doc = "< Number of defined data rates"]
pub const sl_wfx_rate_index_e_SL_WFX_RATE_NUM_ENTRIES: sl_wfx_rate_index_e = 22;
#[doc = " @brief List of possible transmission rates."]
#[doc = ""]
#[doc = " Note that ERP-PBCC is not supported by the hardware. The rate indices for 22 Mbit/s and 33 Mbit/s are only provided for standard compatibility.@n"]
#[doc = " Data rates (in the names) are for 20 MHz channel operation. Corresponding data rates for 10 MHz channel operation are half of them."]
#[doc = ""]
#[doc = " In this API, some parameters such as 'basic_rate_set' encode a list of rates in a bitstream format.@n"]
#[doc = "     for instance SUPPORTED_B_RATES_MASK = 0x0000000F @n"]
#[doc = "                  SUPPORTED_G_RATES_MASK = 0x00003FC0 @n"]
#[doc = "                  SUPPORTED_N_RATES_MASK = 0x003FC000"]
pub type sl_wfx_rate_index_e = u32;
pub use self::sl_wfx_rate_index_e as sl_wfx_rate_index_t;
#[doc = " @brief General Message header structure"]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_header_s {
    #[doc = "< Message length in bytes including this uint16_t."]
    #[doc = "< Maximum value is 8188 but maximum Request size is FW dependent and reported in the ::sl_wfx_startup_ind_body_t::size_inp_ch_buf."]
    pub length: u16,
    #[doc = "< Contains the message Id indexed by sl_wfx_general_commands_ids_t or sl_wfx_message_ids_t."]
    pub id: u8,
    #[doc = "< TODO comment missing"]
    pub info: u8,
}
#[test]
fn bindgen_test_layout_sl_wfx_header_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_header_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_header_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_header_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_header_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_header_s>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_header_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_header_s>())).id as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_header_s),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_header_s>())).info as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_header_s),
            "::",
            stringify!(info)
        )
    );
}
pub type sl_wfx_header_t = sl_wfx_header_s;
#[doc = " @brief Generic message structure for all requests, confirmations and indications"]
#[doc = ""]
#[repr(C, packed)]
pub struct sl_wfx_generic_message_s {
    #[doc = "<4 bytes header"]
    pub header: sl_wfx_header_t,
    #[doc = "<variable size payload of the message"]
    pub body: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_generic_message_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_generic_message_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_generic_message_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_generic_message_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_generic_message_s))
    );
}
pub type sl_wfx_generic_message_t = sl_wfx_generic_message_s;
#[doc = " @brief Generic confirmation message with the body reduced to the status field."]
#[doc = ""]
#[doc = " This structure is not related to a specific confirmation ID. @n"]
#[doc = " It is a global simplified structure that can be used to easily access the header and status fields."]
#[doc = ""]
#[doc = " All confirmation bodies start with a status word and in a lot of them it is followed by other data (not present in this structure)."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_generic_confirmation_s {
    #[doc = "<4 bytes header"]
    pub header: sl_wfx_header_t,
    #[doc = "<See enum sl_wfx_status_t and (wsm_status or wfm_status)"]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_generic_confirmation_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_generic_confirmation_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_generic_confirmation_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_generic_confirmation_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_generic_confirmation_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_generic_confirmation_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_generic_confirmation_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_generic_confirmation_s>())).status as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_generic_confirmation_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_generic_confirmation_t = sl_wfx_generic_confirmation_s;
#[doc = "< \\b CONFIGURATION request Id use body sl_wfx_configuration_req_body_t and returns sl_wfx_configuration_cnf_body_t"]
pub const sl_wfx_generic_requests_ids_e_SL_WFX_CONFIGURATION_REQ_ID: sl_wfx_generic_requests_ids_e =
    9;
#[doc = "< \\b CONTROL_GPIO request Id use body sl_wfx_control_gpio_req_body_t and returns sl_wfx_control_gpio_cnf_body_t"]
pub const sl_wfx_generic_requests_ids_e_SL_WFX_CONTROL_GPIO_REQ_ID: sl_wfx_generic_requests_ids_e =
    38;
#[doc = "< \\b SET_SL_MAC_KEY request Id use body sl_wfx_set_sl_mac_key_req_body_t and returns sl_wfx_set_sl_mac_key_cnf_body_t"]
pub const sl_wfx_generic_requests_ids_e_SL_WFX_SET_SL_MAC_KEY_REQ_ID:
    sl_wfx_generic_requests_ids_e = 39;
#[doc = "< \\b SL_EXCHANGE_PUB_KEYS request Id use body sl_wfx_securelink_exchange_pub_keys_req_body_t and returns sl_wfx_securelink_exchange_pub_keys_cnf_body_t"]
pub const sl_wfx_generic_requests_ids_e_SL_WFX_SECURELINK_EXCHANGE_PUB_KEYS_REQ_ID:
    sl_wfx_generic_requests_ids_e = 40;
#[doc = "< \\b SL_CONFIGURE request Id use body sl_wfx_securelink_configure_req_body_t and returns sl_wfx_securelink_exchange_pub_keys_cnf_body_t"]
pub const sl_wfx_generic_requests_ids_e_SL_WFX_SECURELINK_CONFIGURE_REQ_ID:
    sl_wfx_generic_requests_ids_e = 41;
#[doc = "< \\b PREVENT_ROLLBACK request Id use body sl_wfx_prevent_rollback_req_body_t and returns sl_wfx_prevent_rollback_cnf_body_t"]
pub const sl_wfx_generic_requests_ids_e_SL_WFX_PREVENT_ROLLBACK_REQ_ID:
    sl_wfx_generic_requests_ids_e = 42;
#[doc = "< \\b PTA_SETTINGS request Id use body sl_wfx_pta_settings_req_body_t and returns sl_wfx_pta_settings_cnf_body_t"]
pub const sl_wfx_generic_requests_ids_e_SL_WFX_PTA_SETTINGS_REQ_ID: sl_wfx_generic_requests_ids_e =
    43;
#[doc = "< \\b PTA_PRIORITY request Id use body sl_wfx_pta_priority_req_body_t and returns sl_wfx_pta_priority_cnf_body_t"]
pub const sl_wfx_generic_requests_ids_e_SL_WFX_PTA_PRIORITY_REQ_ID: sl_wfx_generic_requests_ids_e =
    44;
#[doc = "< \\b PTA_STATE request Id use body sl_wfx_pta_state_req_body_t and returns sl_wfx_pta_state_cnf_body_t"]
pub const sl_wfx_generic_requests_ids_e_SL_WFX_PTA_STATE_REQ_ID: sl_wfx_generic_requests_ids_e = 45;
#[doc = "< \\b SHUT_DOWN request Id use body sl_wfx_shut_down_req_t and never returns"]
pub const sl_wfx_generic_requests_ids_e_SL_WFX_SHUT_DOWN_REQ_ID: sl_wfx_generic_requests_ids_e = 50;
#[doc = " @brief General request message IDs"]
#[doc = ""]
#[doc = " API general request message IDs available in both split and full MAC."]
#[doc = " These are messages from the host towards the WLAN."]
pub type sl_wfx_generic_requests_ids_e = u32;
pub use self::sl_wfx_generic_requests_ids_e as sl_wfx_generic_requests_ids_t;
#[doc = "< \\b CONFIGURATION confirmation Id returns body sl_wfx_configuration_cnf_body_t"]
pub const sl_wfx_general_confirmations_ids_e_SL_WFX_CONFIGURATION_CNF_ID:
    sl_wfx_general_confirmations_ids_e = 9;
#[doc = "< \\b CONTROL_GPIO confirmation Id returns body sl_wfx_control_gpio_cnf_body_t"]
pub const sl_wfx_general_confirmations_ids_e_SL_WFX_CONTROL_GPIO_CNF_ID:
    sl_wfx_general_confirmations_ids_e = 38;
#[doc = "< \\b SET_SL_MAC_KEY confirmation Id returns body sl_wfx_set_sl_mac_key_cnf_body_t"]
pub const sl_wfx_general_confirmations_ids_e_SL_WFX_SET_SL_MAC_KEY_CNF_ID:
    sl_wfx_general_confirmations_ids_e = 39;
#[doc = "< \\b SL_EXCHANGE_PUB_KEYS confirmation Id returns body sl_wfx_securelink_exchange_pub_keys_cnf_body_t"]
pub const sl_wfx_general_confirmations_ids_e_SL_WFX_SECURELINK_EXCHANGE_PUB_KEYS_CNF_ID:
    sl_wfx_general_confirmations_ids_e = 40;
#[doc = "< \\b SL_CONFIGURE confirmation Id returns body sl_wfx_securelink_configure_cnf_body_t"]
pub const sl_wfx_general_confirmations_ids_e_SL_WFX_SECURELINK_CONFIGURE_CNF_ID:
    sl_wfx_general_confirmations_ids_e = 41;
#[doc = "< \\b PREVENT_ROLLBACK confirmation Id use body sl_wfx_prevent_rollback_cnf_body_t"]
pub const sl_wfx_general_confirmations_ids_e_SL_WFX_PREVENT_ROLLBACK_CNF_ID:
    sl_wfx_general_confirmations_ids_e = 42;
#[doc = "< \\b PTA_SETTINGS confirmation Id returns sl_wfx_pta_settings_cnf_body_t"]
pub const sl_wfx_general_confirmations_ids_e_SL_WFX_PTA_SETTINGS_CNF_ID:
    sl_wfx_general_confirmations_ids_e = 43;
#[doc = "< \\b PTA_PRIORITY confirmation Id returns sl_wfx_pta_priority_cnf_body_t"]
pub const sl_wfx_general_confirmations_ids_e_SL_WFX_PTA_PRIORITY_CNF_ID:
    sl_wfx_general_confirmations_ids_e = 44;
#[doc = "< \\b PTA_STATE confirmation Id returns sl_wfx_pta_state_cnf_body_t"]
pub const sl_wfx_general_confirmations_ids_e_SL_WFX_PTA_STATE_CNF_ID:
    sl_wfx_general_confirmations_ids_e = 45;
#[doc = " @brief General confirmation message IDs"]
#[doc = ""]
#[doc = " API general confirmation message IDs returned by requests described in sl_wfx_general_requests_ids."]
#[doc = " These are messages from the WLAN towards the host."]
pub type sl_wfx_general_confirmations_ids_e = u32;
pub use self::sl_wfx_general_confirmations_ids_e as sl_wfx_general_confirmations_ids_t;
#[doc = "< \\b EXCEPTION indication Id content is sl_wfx_exception_ind_body_t"]
pub const sl_wfx_general_indications_ids_e_SL_WFX_EXCEPTION_IND_ID:
    sl_wfx_general_indications_ids_e = 224;
#[doc = "< \\b STARTUP indication Id content is sl_wfx_startup_ind_body_t"]
pub const sl_wfx_general_indications_ids_e_SL_WFX_STARTUP_IND_ID: sl_wfx_general_indications_ids_e =
    225;
#[doc = "< \\b WAKE UP indication Id has no content"]
pub const sl_wfx_general_indications_ids_e_SL_WFX_WAKEUP_IND_ID: sl_wfx_general_indications_ids_e =
    226;
#[doc = "< \\b GENERIC indication Id content is sl_wfx_generic_ind_body_t"]
pub const sl_wfx_general_indications_ids_e_SL_WFX_GENERIC_IND_ID: sl_wfx_general_indications_ids_e =
    227;
#[doc = "< \\b ERROR indication Id content is sl_wfx_error_ind_body_t"]
pub const sl_wfx_general_indications_ids_e_SL_WFX_ERROR_IND_ID: sl_wfx_general_indications_ids_e =
    228;
#[doc = "< \\b SECURELINK_EXCHANGE_PUB_KEYS indication Id content is sl_wfx_securelink_exchange_pub_keys_ind_body_t"]
pub const sl_wfx_general_indications_ids_e_SL_WFX_SECURELINK_EXCHANGE_PUB_KEYS_IND_ID:
    sl_wfx_general_indications_ids_e = 229;
#[doc = " @brief General indications message IDs"]
#[doc = ""]
#[doc = " API general indication message IDs available in both split and full MAC."]
#[doc = " These are messages from the WLAN towards the host."]
pub type sl_wfx_general_indications_ids_e = u32;
pub use self::sl_wfx_general_indications_ids_e as sl_wfx_general_indications_ids_t;
#[doc = " @brief General command message IDs"]
#[doc = ""]
#[doc = " All general API message IDs."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sl_wfx_general_commands_ids_u {
    #[doc = "< Request from the host to the WLAN device"]
    pub request: sl_wfx_generic_requests_ids_t,
    #[doc = "< Confirmation of a request from the WLAN device to the host"]
    pub confirmation: sl_wfx_general_confirmations_ids_t,
    #[doc = "< Indication from the WLAN device to the host"]
    pub indication: sl_wfx_general_indications_ids_t,
    _bindgen_union_align: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_general_commands_ids_u() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_general_commands_ids_u>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_general_commands_ids_u))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_general_commands_ids_u>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_general_commands_ids_u))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_general_commands_ids_u>())).request as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_general_commands_ids_u),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_general_commands_ids_u>())).confirmation as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_general_commands_ids_u),
            "::",
            stringify!(confirmation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_general_commands_ids_u>())).indication as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_general_commands_ids_u),
            "::",
            stringify!(indication)
        )
    );
}
pub type sl_wfx_general_commands_ids_t = sl_wfx_general_commands_ids_u;
#[doc = "<The firmware has successfully completed the request."]
pub const sl_wfx_status_e_SL_WFX_STATUS_SUCCESS: sl_wfx_status_e = 0;
#[doc = "<This is a generic failure code : other error codes do not apply."]
pub const sl_wfx_status_e_SL_WFX_STATUS_FAILURE: sl_wfx_status_e = 1;
#[doc = "<The request contains one or more invalid parameters."]
pub const sl_wfx_status_e_SL_WFX_INVALID_PARAMETER: sl_wfx_status_e = 2;
#[doc = "<Warning : the GPIO CMD is successful but the read value is not as expected (likely a drive conflict on the line)"]
pub const sl_wfx_status_e_SL_WFX_STATUS_GPIO_WARNING: sl_wfx_status_e = 3;
#[doc = "<Unknown request ID or wrong interface ID used"]
pub const sl_wfx_status_e_SL_WFX_ERROR_UNSUPPORTED_MSG_ID: sl_wfx_status_e = 4;
#[doc = "<Key has been correctly written"]
pub const sl_wfx_status_e_SL_WFX_MAC_KEY_STATUS_SUCCESS: sl_wfx_status_e = 90;
#[doc = "<Key already exists in OTP"]
pub const sl_wfx_status_e_SL_WFX_MAC_KEY_STATUS_FAILED_KEY_ALREADY_BURNED: sl_wfx_status_e = 107;
#[doc = "<RAM mode is not allowed"]
pub const sl_wfx_status_e_SL_WFX_MAC_KEY_STATUS_FAILED_RAM_MODE_NOT_ALLOWED: sl_wfx_status_e = 124;
#[doc = "<Unknown mode (should be RAM or OTP)"]
pub const sl_wfx_status_e_SL_WFX_MAC_KEY_STATUS_FAILED_UNKNOWN_MODE: sl_wfx_status_e = 141;
#[doc = "<Host Public Key authenticated"]
pub const sl_wfx_status_e_SL_WFX_PUB_KEY_EXCHANGE_STATUS_SUCCESS: sl_wfx_status_e = 158;
#[doc = "<Host Public Key authentication failed"]
pub const sl_wfx_status_e_SL_WFX_PUB_KEY_EXCHANGE_STATUS_FAILED: sl_wfx_status_e = 175;
#[doc = "<OTP rollback value has been successfully updated"]
pub const sl_wfx_status_e_SL_WFX_PREVENT_ROLLBACK_CNF_SUCCESS: sl_wfx_status_e = 4660;
#[doc = "<Wrong magic word detected"]
pub const sl_wfx_status_e_SL_WFX_PREVENT_ROLLBACK_CNF_WRONG_MAGIC_WORD: sl_wfx_status_e = 4694;
#[doc = " @brief General confirmation possible values for returned 'status' field"]
#[doc = "WLAN"]
#[doc = " All general confirmation messages have a field 'status' just after the message header.@n"]
#[doc = " A value of zero indicates the request is completed successfully."]
#[doc = ""]
pub type sl_wfx_status_e = u32;
pub use self::sl_wfx_status_e as sl_wfx_status_t;
#[doc = "<Test Firmware"]
pub const sl_wfx_type_e_SL_WFX_FW_TYPE_ETF: sl_wfx_type_e = 0;
#[doc = "<WLAN Full MAC (WFM)"]
pub const sl_wfx_type_e_SL_WFX_FW_TYPE_WFM: sl_wfx_type_e = 1;
#[doc = "<WLAN Split MAC (WSM)"]
pub const sl_wfx_type_e_SL_WFX_FW_TYPE_WSM: sl_wfx_type_e = 2;
#[doc = " @addtogroup General_Configuration"]
#[doc = " @brief General configuration commands"]
#[doc = ""]
#[doc = ""]
#[doc = " @{"]
pub type sl_wfx_type_e = u32;
pub use self::sl_wfx_type_e as sl_wfx_fw_type_t;
#[doc = " @brief Capabilities offered by the WLAN used in command sl_wfx_startup_ind_body_t"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_capabilities_s {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = "<Bit 8-15 : Reserved"]
    pub reserved2: u8,
    #[doc = "<Bit 16-23 : Reserved"]
    pub reserved3: u8,
    #[doc = "<Bit 24-31 : Reserved"]
    pub reserved4: u8,
}
#[test]
fn bindgen_test_layout_sl_wfx_capabilities_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_capabilities_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_capabilities_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_capabilities_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_capabilities_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_capabilities_s>())).reserved2 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_capabilities_s),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_capabilities_s>())).reserved3 as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_capabilities_s),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_capabilities_s>())).reserved4 as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_capabilities_s),
            "::",
            stringify!(reserved4)
        )
    );
}
impl sl_wfx_capabilities_s {
    #[inline]
    pub fn linkmode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_linkmode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(linkmode: u8, reserved1: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let linkmode: u8 = unsafe { ::core::mem::transmute(linkmode) };
            linkmode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let reserved1: u8 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type sl_wfx_capabilities_t = sl_wfx_capabilities_s;
#[doc = " @brief REGUL_SEL_MODE OTP field reported in command sl_wfx_startup_ind_body_t"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_otp_regul_sel_mode_info_s {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_otp_regul_sel_mode_info_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_otp_regul_sel_mode_info_s>(),
        1usize,
        concat!("Size of: ", stringify!(sl_wfx_otp_regul_sel_mode_info_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_otp_regul_sel_mode_info_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_otp_regul_sel_mode_info_s)
        )
    );
}
impl sl_wfx_otp_regul_sel_mode_info_s {
    #[inline]
    pub fn region_sel_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_region_sel_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        region_sel_mode: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let region_sel_mode: u8 = unsafe { ::core::mem::transmute(region_sel_mode) };
            region_sel_mode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type sl_wfx_otp_regul_sel_mode_info_t = sl_wfx_otp_regul_sel_mode_info_s;
#[doc = " @brief OTP_PHY_INFO OTP field reported in command sl_wfx_startup_ind_body_t"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_otp_phy_info_s {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_otp_phy_info_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_otp_phy_info_s>(),
        1usize,
        concat!("Size of: ", stringify!(sl_wfx_otp_phy_info_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_otp_phy_info_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_otp_phy_info_s))
    );
}
impl sl_wfx_otp_phy_info_s {
    #[inline]
    pub fn phy1_region(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_phy1_region(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn phy0_region(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_phy0_region(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn otp_phy_ver(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_otp_phy_ver(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        phy1_region: u8,
        phy0_region: u8,
        otp_phy_ver: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let phy1_region: u8 = unsafe { ::core::mem::transmute(phy1_region) };
            phy1_region as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let phy0_region: u8 = unsafe { ::core::mem::transmute(phy0_region) };
            phy0_region as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let otp_phy_ver: u8 = unsafe { ::core::mem::transmute(otp_phy_ver) };
            otp_phy_ver as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type sl_wfx_otp_phy_info_t = sl_wfx_otp_phy_info_s;
#[doc = " @brief Startup Indication message."]
#[doc = " This is the first message sent to the host to confirm boot success."]
#[doc = " It gives detailed information on the HW and FW versions and capabilities"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_startup_ind_body_s {
    #[doc = "<Initialization status. A value of zero indicates the boot is completed successfully  (see enum sl_wfx_status_t)"]
    pub status: u32,
    #[doc = "<=RO misc_read_reg7 register value"]
    pub hardware_id: u16,
    #[doc = "<=OTP part_OPN"]
    pub opn: [u8; 14usize],
    #[doc = "<=OTP UID"]
    pub uid: [u8; 8usize],
    #[doc = "<Number of buffers available for request messages."]
    pub num_inp_ch_bufs: u16,
    #[doc = "<TX Buffer size in bytes=request message max size."]
    pub size_inp_ch_buf: u16,
    #[doc = "<number of STA that are supported in AP mode"]
    pub num_links_aP: u8,
    #[doc = "<number of interfaces (WIFI link : STA or AP) that can be created by the user"]
    pub num_interfaces: u8,
    #[doc = "<MAC addresses derived from OTP"]
    pub mac_addr: [[u8; 6usize]; 2usize],
    pub api_version_minor: u8,
    pub api_version_major: u8,
    #[doc = "<List some FW options"]
    pub capabilities: sl_wfx_capabilities_t,
    pub firmware_build: u8,
    pub firmware_minor: u8,
    pub firmware_major: u8,
    #[doc = "<See enum sl_wfx_fw_type_t"]
    pub firmware_type: u8,
    #[doc = "<=OTP Disabled channel list info"]
    pub disabled_channel_list: [u8; 2usize],
    #[doc = "<OTP region selection mode info"]
    pub regul_sel_mode_info: sl_wfx_otp_regul_sel_mode_info_t,
    #[doc = "<info on OTP backoff tables used to enforce the different DFS regulations."]
    pub otp_phy_info: sl_wfx_otp_phy_info_t,
    #[doc = "<A bit mask that indicates which rates are supported by the Physical layer. See enum api_rate_index."]
    pub supported_rate_mask: u32,
    #[doc = "<Null terminated text string describing the loaded FW."]
    pub firmware_label: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_startup_ind_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_startup_ind_body_s>(),
        192usize,
        concat!("Size of: ", stringify!(sl_wfx_startup_ind_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_startup_ind_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_startup_ind_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_startup_ind_body_s>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_startup_ind_body_s>())).hardware_id as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(hardware_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_startup_ind_body_s>())).opn as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(opn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_startup_ind_body_s>())).uid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_startup_ind_body_s>())).num_inp_ch_bufs as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(num_inp_ch_bufs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_startup_ind_body_s>())).size_inp_ch_buf as *const _
                as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(size_inp_ch_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_startup_ind_body_s>())).num_links_aP as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(num_links_aP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_startup_ind_body_s>())).num_interfaces as *const _
                as usize
        },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(num_interfaces)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_startup_ind_body_s>())).mac_addr as *const _ as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_startup_ind_body_s>())).api_version_minor as *const _
                as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(api_version_minor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_startup_ind_body_s>())).api_version_major as *const _
                as usize
        },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(api_version_major)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_startup_ind_body_s>())).capabilities as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_startup_ind_body_s>())).firmware_build as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(firmware_build)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_startup_ind_body_s>())).firmware_minor as *const _
                as usize
        },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(firmware_minor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_startup_ind_body_s>())).firmware_major as *const _
                as usize
        },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(firmware_major)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_startup_ind_body_s>())).firmware_type as *const _
                as usize
        },
        55usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(firmware_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_startup_ind_body_s>())).disabled_channel_list as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(disabled_channel_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_startup_ind_body_s>())).regul_sel_mode_info as *const _
                as usize
        },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(regul_sel_mode_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_startup_ind_body_s>())).otp_phy_info as *const _ as usize
        },
        59usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(otp_phy_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_startup_ind_body_s>())).supported_rate_mask as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(supported_rate_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_startup_ind_body_s>())).firmware_label as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_body_s),
            "::",
            stringify!(firmware_label)
        )
    );
}
pub type sl_wfx_startup_ind_body_t = sl_wfx_startup_ind_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_startup_ind_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_startup_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_startup_ind_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_startup_ind_s>(),
        196usize,
        concat!("Size of: ", stringify!(sl_wfx_startup_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_startup_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_startup_ind_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_startup_ind_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_startup_ind_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_startup_ind_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_startup_ind_t = sl_wfx_startup_ind_s;
#[doc = " @brief Wake-up indication message."]
#[doc = " @since API1.4.0"]
#[doc = ""]
#[doc = " Its body is empty. It signals that the chip is awake and ready to receive commands after a wake-up request from the host."]
#[doc = " It generates a DATA_IRQ to the host driver when ready."]
#[doc = " It can be replaced or passed by another message that would have appeared concurrently like a Rx frame."]
pub type sl_wfx_wakeup_ind_t = sl_wfx_header_t;
#[doc = " @brief Configure the device."]
#[doc = " It sends a PDS compressed file that configures the device regarding board dependent parameters."]
#[doc = " The PDS compressed file must fit in a command buffer and have less than 256 elements."]
#[doc = ""]
#[doc = " @todo Need to create a specific doc to explain PDS"]
#[repr(C, packed)]
pub struct sl_wfx_configuration_req_body_s {
    #[doc = "<pds_data length in bytes"]
    pub length: u16,
    #[doc = "<variable size PDS data byte array"]
    pub pds_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_configuration_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_configuration_req_body_s>(),
        2usize,
        concat!("Size of: ", stringify!(sl_wfx_configuration_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_configuration_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_configuration_req_body_s))
    );
}
pub type sl_wfx_configuration_req_body_t = sl_wfx_configuration_req_body_s;
#[repr(C, packed)]
pub struct sl_wfx_configuration_req_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_configuration_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_configuration_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_configuration_req_s>(),
        6usize,
        concat!("Size of: ", stringify!(sl_wfx_configuration_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_configuration_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_configuration_req_s))
    );
}
pub type sl_wfx_configuration_req_t = sl_wfx_configuration_req_s;
#[doc = " @brief Confirmation message of CONFIGURATION command sl_wfx_configuration_req_body_t"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_configuration_cnf_body_s {
    #[doc = "<Configuration status. A value of zero indicates the boot is completed successfully (see enum sl_wfx_status_t)"]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_configuration_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_configuration_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_configuration_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_configuration_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_configuration_cnf_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_configuration_cnf_body_s>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_configuration_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_configuration_cnf_body_t = sl_wfx_configuration_cnf_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_configuration_cnf_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_configuration_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_configuration_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_configuration_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_configuration_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_configuration_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_configuration_cnf_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_configuration_cnf_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_configuration_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_configuration_cnf_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_configuration_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_configuration_cnf_t = sl_wfx_configuration_cnf_s;
#[doc = "< Configure the GPIO to drive 0"]
pub const sl_wfx_gpio_mode_e_SL_WFX_GPIO_MODE_D0: sl_wfx_gpio_mode_e = 0;
#[doc = "< Configure the GPIO to drive 1"]
pub const sl_wfx_gpio_mode_e_SL_WFX_GPIO_MODE_D1: sl_wfx_gpio_mode_e = 1;
#[doc = "< Configure the GPIO to open drain with pull_down to 0"]
pub const sl_wfx_gpio_mode_e_SL_WFX_GPIO_MODE_OD0: sl_wfx_gpio_mode_e = 2;
#[doc = "< Configure the GPIO to open drain with pull_up to 1"]
pub const sl_wfx_gpio_mode_e_SL_WFX_GPIO_MODE_OD1: sl_wfx_gpio_mode_e = 3;
#[doc = "< Configure the GPIO to tristate"]
pub const sl_wfx_gpio_mode_e_SL_WFX_GPIO_MODE_TRISTATE: sl_wfx_gpio_mode_e = 4;
#[doc = "< Toggle the GPIO output value : switches between D0 and D1 or between OD0 and OD1"]
pub const sl_wfx_gpio_mode_e_SL_WFX_GPIO_MODE_TOGGLE: sl_wfx_gpio_mode_e = 5;
#[doc = "< Read the level at the GPIO pin"]
pub const sl_wfx_gpio_mode_e_SL_WFX_GPIO_MODE_READ: sl_wfx_gpio_mode_e = 6;
#[doc = " @brief Configure GPIO mode. Used in sl_wfx_control_gpio_req_body_t"]
pub type sl_wfx_gpio_mode_e = u32;
pub use self::sl_wfx_gpio_mode_e as sl_wfx_gpio_mode_t;
#[doc = " @brief Send a request to read or write a GPIO identified by its label (that is defined in the PDS)"]
#[doc = ""]
#[doc = " After a write it also read back the value to check there is no drive conflict"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_control_gpio_req_body_s {
    #[doc = "<Identify the GPIO by its label (defined in the PDS)"]
    pub gpio_label: u8,
    #[doc = "<define how to set or read the GPIO (see enum sl_wfx_gpio_mode_t)"]
    pub gpio_mode: u8,
}
#[test]
fn bindgen_test_layout_sl_wfx_control_gpio_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_control_gpio_req_body_s>(),
        2usize,
        concat!("Size of: ", stringify!(sl_wfx_control_gpio_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_control_gpio_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_control_gpio_req_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_control_gpio_req_body_s>())).gpio_label as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_control_gpio_req_body_s),
            "::",
            stringify!(gpio_label)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_control_gpio_req_body_s>())).gpio_mode as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_control_gpio_req_body_s),
            "::",
            stringify!(gpio_mode)
        )
    );
}
pub type sl_wfx_control_gpio_req_body_t = sl_wfx_control_gpio_req_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_control_gpio_req_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_control_gpio_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_control_gpio_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_control_gpio_req_s>(),
        6usize,
        concat!("Size of: ", stringify!(sl_wfx_control_gpio_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_control_gpio_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_control_gpio_req_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_control_gpio_req_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_control_gpio_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_control_gpio_req_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_control_gpio_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_control_gpio_req_t = sl_wfx_control_gpio_req_s;
#[doc = "< Undefined GPIO_ID"]
pub const sl_wfx_gpio_error_e_SL_WFX_GPIO_ERROR_0: sl_wfx_gpio_error_e = 0;
#[doc = "< GPIO_ID not configured in GPIO mode (gpio_enabled =0)"]
pub const sl_wfx_gpio_error_e_SL_WFX_GPIO_ERROR_1: sl_wfx_gpio_error_e = 1;
#[doc = "< Toggle not possible while in tristate"]
pub const sl_wfx_gpio_error_e_SL_WFX_GPIO_ERROR_2: sl_wfx_gpio_error_e = 2;
#[doc = " @brief detailed error cause returned by CONTROL_GPIO confirmation message sl_wfx_control_gpio_cnf_body_t"]
pub type sl_wfx_gpio_error_e = u32;
pub use self::sl_wfx_gpio_error_e as sl_wfx_gpio_error_t;
#[doc = " @brief Confirmation from request to read and write a GPIO"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_control_gpio_cnf_body_s {
    #[doc = "<enum sl_wfx_status_t : a value of zero indicates the request is completed successfully."]
    pub status: u32,
    #[doc = "<the error detail (see enum sl_wfx_gpio_error_t) when ::sl_wfx_control_gpio_cnf_body_t::status reports an error else the gpio read value."]
    pub value: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_control_gpio_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_control_gpio_cnf_body_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_control_gpio_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_control_gpio_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_control_gpio_cnf_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_control_gpio_cnf_body_s>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_control_gpio_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_control_gpio_cnf_body_s>())).value as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_control_gpio_cnf_body_s),
            "::",
            stringify!(value)
        )
    );
}
pub type sl_wfx_control_gpio_cnf_body_t = sl_wfx_control_gpio_cnf_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_control_gpio_cnf_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_control_gpio_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_control_gpio_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_control_gpio_cnf_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_control_gpio_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_control_gpio_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_control_gpio_cnf_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_control_gpio_cnf_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_control_gpio_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_control_gpio_cnf_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_control_gpio_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_control_gpio_cnf_t = sl_wfx_control_gpio_cnf_s;
#[doc = " @brief SHUT_DOWN command."]
#[doc = " A hardware reset and complete reboot is required to resume from that state."]
#[doc = " There is no confirmation to this command."]
#[doc = " It is effective when WUP register bit and WUP pin (when used) are both to 0."]
pub type sl_wfx_shut_down_req_t = sl_wfx_header_t;
#[doc = "<Byte stream type, currently not used"]
pub const sl_wfx_generic_indication_type_e_SL_WFX_GENERIC_INDICATION_TYPE_RAW:
    sl_wfx_generic_indication_type_e = 0;
#[doc = "<NULL terminating String"]
pub const sl_wfx_generic_indication_type_e_SL_WFX_GENERIC_INDICATION_TYPE_STRING:
    sl_wfx_generic_indication_type_e = 1;
#[doc = "<Rx statistics structure"]
pub const sl_wfx_generic_indication_type_e_SL_WFX_GENERIC_INDICATION_TYPE_RX_STATS:
    sl_wfx_generic_indication_type_e = 2;
#[doc = " @brief specifies the type of data reported by the indication message sl_wfx_generic_ind_body_t"]
#[doc = ""]
pub type sl_wfx_generic_indication_type_e = u32;
pub use self::sl_wfx_generic_indication_type_e as sl_wfx_generic_indication_type_t;
#[doc = " @brief RX stats from the GENERIC indication message sl_wfx_generic_ind_body_t"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_rx_stats_s {
    #[doc = "<Total number of frame received"]
    pub nb_rx_frame: u32,
    #[doc = "<Number of frame received with bad CRC"]
    pub nb_crc_frame: u32,
    #[doc = "<PER on the total number of frame"]
    pub per_total: u32,
    #[doc = "<Throughput calculated on correct frames received"]
    pub throughput: u32,
    #[doc = "<Number of frame received by rate"]
    pub nb_rx_by_rate: [u32; 22usize],
    #[doc = "<PER*10000 by frame rate"]
    pub per: [u16; 22usize],
    #[doc = "<SNR in Db*100 by frame rate"]
    pub snr: [i16; 22usize],
    #[doc = "<RSSI in Dbm*100 by frame rate"]
    pub rssi: [i16; 22usize],
    #[doc = "<CFO in k_hz by frame rate"]
    pub cfo: [i16; 22usize],
    #[doc = "<This message transmission date in firmware timebase (microsecond)"]
    pub date: u32,
    #[doc = "<Frequency of the low power clock in Hz"]
    pub pwr_clk_freq: u32,
    #[doc = "<Indicate if the low power clock is external"]
    pub is_ext_pwr_clk: u8,
}
#[test]
fn bindgen_test_layout_sl_wfx_rx_stats_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_rx_stats_s>(),
        289usize,
        concat!("Size of: ", stringify!(sl_wfx_rx_stats_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_rx_stats_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_rx_stats_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_rx_stats_s>())).nb_rx_frame as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(nb_rx_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_rx_stats_s>())).nb_crc_frame as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(nb_crc_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_rx_stats_s>())).per_total as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(per_total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_rx_stats_s>())).throughput as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(throughput)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_rx_stats_s>())).nb_rx_by_rate as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(nb_rx_by_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_rx_stats_s>())).per as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(per)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_rx_stats_s>())).snr as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(snr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_rx_stats_s>())).rssi as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(rssi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_rx_stats_s>())).cfo as *const _ as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(cfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_rx_stats_s>())).date as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(date)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_rx_stats_s>())).pwr_clk_freq as *const _ as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(pwr_clk_freq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_rx_stats_s>())).is_ext_pwr_clk as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rx_stats_s),
            "::",
            stringify!(is_ext_pwr_clk)
        )
    );
}
pub type sl_wfx_rx_stats_t = sl_wfx_rx_stats_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sl_wfx_indication_data_u {
    pub rx_stats: sl_wfx_rx_stats_t,
    pub raw_data: [u8; 376usize],
    _bindgen_union_align: [u8; 376usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_indication_data_u() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_indication_data_u>(),
        376usize,
        concat!("Size of: ", stringify!(sl_wfx_indication_data_u))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_indication_data_u>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_indication_data_u))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_indication_data_u>())).rx_stats as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_indication_data_u),
            "::",
            stringify!(rx_stats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_indication_data_u>())).raw_data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_indication_data_u),
            "::",
            stringify!(raw_data)
        )
    );
}
pub type sl_wfx_indication_data_t = sl_wfx_indication_data_u;
#[doc = " @brief the Generic indication message."]
#[doc = ""]
#[doc = " It reports different type of information that can be printed by the driver."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_generic_ind_body_s {
    #[doc = "<Identify the indication data (see enum type sl_wfx_generic_indication_type_t)"]
    pub indication_type: u32,
    #[doc = "<Indication data."]
    pub indication_data: sl_wfx_indication_data_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_generic_ind_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_generic_ind_body_s>(),
        380usize,
        concat!("Size of: ", stringify!(sl_wfx_generic_ind_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_generic_ind_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_generic_ind_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_generic_ind_body_s>())).indication_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_generic_ind_body_s),
            "::",
            stringify!(indication_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_generic_ind_body_s>())).indication_data as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_generic_ind_body_s),
            "::",
            stringify!(indication_data)
        )
    );
}
pub type sl_wfx_generic_ind_body_t = sl_wfx_generic_ind_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_generic_ind_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_generic_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_generic_ind_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_generic_ind_s>(),
        384usize,
        concat!("Size of: ", stringify!(sl_wfx_generic_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_generic_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_generic_ind_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_generic_ind_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_generic_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_generic_ind_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_generic_ind_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_generic_ind_t = sl_wfx_generic_ind_s;
#[doc = " @brief Exception indication message"]
#[doc = ""]
#[doc = " It reports unexpected errors. A reboot is needed after this message."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_exception_ind_body_s {
    #[doc = "<Raw data array"]
    pub data: [u8; 124usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_exception_ind_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_exception_ind_body_s>(),
        124usize,
        concat!("Size of: ", stringify!(sl_wfx_exception_ind_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_exception_ind_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_exception_ind_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_exception_ind_body_s>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_exception_ind_body_s),
            "::",
            stringify!(data)
        )
    );
}
pub type sl_wfx_exception_ind_body_t = sl_wfx_exception_ind_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_exception_ind_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_exception_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_exception_ind_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_exception_ind_s>(),
        128usize,
        concat!("Size of: ", stringify!(sl_wfx_exception_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_exception_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_exception_ind_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_exception_ind_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_exception_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_exception_ind_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_exception_ind_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_exception_ind_t = sl_wfx_exception_ind_s;
#[doc = "<Firmware rollback error, no data returned"]
pub const sl_wfx_error_e_WSM_SL_WFX_ERROR_FIRMWARE_ROLLBACK: sl_wfx_error_e = 0;
#[doc = "<Firmware debug feature enabled, no data returned"]
pub const sl_wfx_error_e_WSM_SL_WFX_ERROR_FIRMWARE_DEBUG_ENABLED: sl_wfx_error_e = 1;
#[doc = "<SecureLink Session key is outdated, 4 bytes returned (nonce counter)"]
pub const sl_wfx_error_e_WSM_SL_WFX_ERROR_OUTDATED_SESSION_KEY: sl_wfx_error_e = 2;
#[doc = "<SecureLink Session key is invalid, 0 or 4 bytes returned"]
pub const sl_wfx_error_e_WSM_SL_WFX_ERROR_INVALID_SESSION_KEY: sl_wfx_error_e = 3;
#[doc = "<Out-of-range power supply voltage detected, no data returned"]
pub const sl_wfx_error_e_WSM_SL_WFX_ERROR_OOR_VOLTAGE: sl_wfx_error_e = 4;
#[doc = "<Wrong PDS version detected, no data returned"]
pub const sl_wfx_error_e_WSM_SL_WFX_ERROR_PDS_VERSION: sl_wfx_error_e = 5;
#[doc = "<Out-of-range temperature, no data returned"]
pub const sl_wfx_error_e_WSM_SL_ERROR_OOR_TEMPERATURE: sl_wfx_error_e = 6;
#[doc = "<Requets from Host are forbidden until the end of key exchange (Host should wait for the associated indication)"]
pub const sl_wfx_error_e_WSM_SL_ERROR_REQ_DURING_KEY_EXCHANGE: sl_wfx_error_e = 7;
#[doc = "<'Multi TX conf' feature is not supported in SecureLink mode"]
pub const sl_wfx_error_e_WSM_SL_ERROR_MULTI_TX_CNF_SECURELINK: sl_wfx_error_e = 8;
#[doc = "<HT SecureLink traffic is producing an internal overflow"]
pub const sl_wfx_error_e_WSM_SL_ERROR_SECURELINK_OVERFLOW: sl_wfx_error_e = 9;
#[doc = "<An error occured during message decryption (can be a counter mismatch or wrong CCM tag)"]
pub const sl_wfx_error_e_WSM_SL_ERROR_SECURELINK_DECRYPTION: sl_wfx_error_e = 10;
#[doc = " @brief specifies the type of error reported by the indication message sl_wfx_error_ind_body_t"]
#[doc = ""]
pub type sl_wfx_error_e = u32;
pub use self::sl_wfx_error_e as sl_wfx_error_t;
#[doc = " @brief Error indication message."]
#[doc = ""]
#[doc = " It reports user configuration errors."]
#[doc = " A reboot is needed after this message."]
#[repr(C, packed)]
pub struct sl_wfx_error_ind_body_s {
    #[doc = "<error type, see enum sl_wfx_error_t"]
    pub type_: u32,
    #[doc = "<Generic data buffer - contents depends on the error type."]
    pub data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_error_ind_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_error_ind_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_error_ind_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_error_ind_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_error_ind_body_s))
    );
}
pub type sl_wfx_error_ind_body_t = sl_wfx_error_ind_body_s;
#[repr(C, packed)]
pub struct sl_wfx_error_ind_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_error_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_error_ind_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_error_ind_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_error_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_error_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_error_ind_s))
    );
}
pub type sl_wfx_error_ind_t = sl_wfx_error_ind_s;
#[doc = "<Reserved"]
pub const sl_wfx_secure_link_state_e_SECURE_LINK_NA_MODE: sl_wfx_secure_link_state_e = 0;
#[doc = "<Untrusted mode - SecureLink not available"]
pub const sl_wfx_secure_link_state_e_SECURE_LINK_UNTRUSTED_MODE: sl_wfx_secure_link_state_e = 1;
#[doc = "<Trusted (Evaluation) mode"]
pub const sl_wfx_secure_link_state_e_SECURE_LINK_TRUSTED_MODE: sl_wfx_secure_link_state_e = 2;
#[doc = "<Trusted (Enforced) mode"]
pub const sl_wfx_secure_link_state_e_SECURE_LINK_TRUSTED_ACTIVE_ENFORCED:
    sl_wfx_secure_link_state_e = 3;
#[doc = " @brief *Secure Link' device state"]
pub type sl_wfx_secure_link_state_e = u32;
pub use self::sl_wfx_secure_link_state_e as sl_wfx_secure_link_state_t;
#[doc = "<Key will be stored in OTP"]
pub const sl_wfx_securelink_mac_key_dest_e_SECURE_LINK_MAC_KEY_DEST_OTP:
    sl_wfx_securelink_mac_key_dest_e = 120;
#[doc = "<Key will be stored in RAM"]
pub const sl_wfx_securelink_mac_key_dest_e_SECURE_LINK_MAC_KEY_DEST_RAM:
    sl_wfx_securelink_mac_key_dest_e = 135;
#[doc = " @brief destination of the *Secure Link MAC key*, used by request message sl_wfx_set_sl_mac_key_req_body_t"]
pub type sl_wfx_securelink_mac_key_dest_e = u32;
pub use self::sl_wfx_securelink_mac_key_dest_e as sl_wfx_securelink_mac_key_dest_t;
#[doc = " @brief Set the Secure Link MAC key"]
#[doc = ""]
#[doc = " This API can be used for *Trusted Eval* devices in two contexts:"]
#[doc = " - to set a temporary *SecureLink MAC key* in RAM."]
#[doc = " - to permanently burn the *SecureLink MAC key* in OTP memory. In that case, the OTP *SecureLink mode* will"]
#[doc = " switch to *Trusted Enforced* mode"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_sl_mac_key_req_body_s {
    #[doc = "<Key destination - OTP or RAM (see enum sl_wfx_securelink_mac_key_dest_t)"]
    pub otp_or_ram: u8,
    #[doc = "<Secure Link MAC Key value"]
    pub key_value: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_set_sl_mac_key_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_sl_mac_key_req_body_s>(),
        33usize,
        concat!("Size of: ", stringify!(sl_wfx_set_sl_mac_key_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_sl_mac_key_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_sl_mac_key_req_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_sl_mac_key_req_body_s>())).otp_or_ram as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_sl_mac_key_req_body_s),
            "::",
            stringify!(otp_or_ram)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_sl_mac_key_req_body_s>())).key_value as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_sl_mac_key_req_body_s),
            "::",
            stringify!(key_value)
        )
    );
}
pub type sl_wfx_set_sl_mac_key_req_body_t = sl_wfx_set_sl_mac_key_req_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_sl_mac_key_req_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_set_sl_mac_key_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_sl_mac_key_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_sl_mac_key_req_s>(),
        37usize,
        concat!("Size of: ", stringify!(sl_wfx_set_sl_mac_key_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_sl_mac_key_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_sl_mac_key_req_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_sl_mac_key_req_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_sl_mac_key_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_sl_mac_key_req_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_sl_mac_key_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_sl_mac_key_req_t = sl_wfx_set_sl_mac_key_req_s;
#[doc = " @brief Confirmation for the Secure Link MAC key setting"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_sl_mac_key_cnf_body_s {
    #[doc = "<Key upload status (see enum sl_wfx_status_t)"]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_sl_mac_key_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_sl_mac_key_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_set_sl_mac_key_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_sl_mac_key_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_sl_mac_key_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_sl_mac_key_cnf_body_s>())).status as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_sl_mac_key_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_set_sl_mac_key_cnf_body_t = sl_wfx_set_sl_mac_key_cnf_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_sl_mac_key_cnf_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_set_sl_mac_key_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_sl_mac_key_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_sl_mac_key_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_sl_mac_key_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_sl_mac_key_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_sl_mac_key_cnf_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_sl_mac_key_cnf_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_sl_mac_key_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_sl_mac_key_cnf_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_sl_mac_key_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_sl_mac_key_cnf_t = sl_wfx_set_sl_mac_key_cnf_s;
#[doc = "< Session key is computed using curve25519 algorithm"]
pub const sl_wfx_secure_link_session_key_alg_e_SECURE_LINK_CURVE25519:
    sl_wfx_secure_link_session_key_alg_e = 1;
#[doc = "< Session key is computed using KDF algorithm (not available yet)"]
pub const sl_wfx_secure_link_session_key_alg_e_SECURE_LINK_KDF:
    sl_wfx_secure_link_session_key_alg_e = 2;
#[doc = " @brief Session Key computation algorithms"]
#[doc = ""]
pub type sl_wfx_secure_link_session_key_alg_e = u32;
pub use self::sl_wfx_secure_link_session_key_alg_e as sl_wfx_secure_link_session_key_alg_t;
#[doc = " @brief Exchange Secure Link Public Keys"]
#[doc = ""]
#[doc = " This API is used by the Host to send its *curve25519* public key to Device, and get back Device public key in the confirmation message."]
#[doc = " Once keys are exchanged and authenticated (using their respective MAC), each peer computes the Secure Link *session key* that will be used"]
#[doc = " to encrypt/decrypt future Host<->Device messages."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_securelink_exchange_pub_keys_req_body_s {
    #[doc = "<Choice of the cryptographic algorithm used in the session key computation (see enum sl_wfx_secure_link_session_key_alg_t)"]
    pub algorithm: u32,
    #[doc = "<Host Public Key"]
    pub host_pub_key: [u8; 32usize],
    #[doc = "<Host Public Key MAC"]
    pub host_pub_key_mac: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_securelink_exchange_pub_keys_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_securelink_exchange_pub_keys_req_body_s>(),
        100usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_securelink_exchange_pub_keys_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_req_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_securelink_exchange_pub_keys_req_body_s>())).algorithm
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_req_body_s),
            "::",
            stringify!(algorithm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_securelink_exchange_pub_keys_req_body_s>())).host_pub_key
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_req_body_s),
            "::",
            stringify!(host_pub_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_securelink_exchange_pub_keys_req_body_s>()))
                .host_pub_key_mac as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_req_body_s),
            "::",
            stringify!(host_pub_key_mac)
        )
    );
}
pub type sl_wfx_securelink_exchange_pub_keys_req_body_t =
    sl_wfx_securelink_exchange_pub_keys_req_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_securelink_exchange_pub_keys_req_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_securelink_exchange_pub_keys_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_securelink_exchange_pub_keys_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_securelink_exchange_pub_keys_req_s>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_req_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_securelink_exchange_pub_keys_req_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_req_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_securelink_exchange_pub_keys_req_s>())).header
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_securelink_exchange_pub_keys_req_s>())).body as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_securelink_exchange_pub_keys_req_t = sl_wfx_securelink_exchange_pub_keys_req_s;
#[doc = " @brief Confirmation for exchange of Secure Link Public Keys"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_securelink_exchange_pub_keys_cnf_body_s {
    #[doc = "<Request status (see enum sl_wfx_status_t)"]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_securelink_exchange_pub_keys_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_securelink_exchange_pub_keys_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_securelink_exchange_pub_keys_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_securelink_exchange_pub_keys_cnf_body_s>())).status
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_securelink_exchange_pub_keys_cnf_body_t =
    sl_wfx_securelink_exchange_pub_keys_cnf_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_securelink_exchange_pub_keys_cnf_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_securelink_exchange_pub_keys_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_securelink_exchange_pub_keys_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_securelink_exchange_pub_keys_cnf_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_cnf_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_securelink_exchange_pub_keys_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_cnf_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_securelink_exchange_pub_keys_cnf_s>())).header
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_securelink_exchange_pub_keys_cnf_s>())).body as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_securelink_exchange_pub_keys_cnf_t = sl_wfx_securelink_exchange_pub_keys_cnf_s;
#[doc = " @brief Indication for exchange of Secure Link Public Keys"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_securelink_exchange_pub_keys_ind_body_s {
    #[doc = "<Request status (see enum sl_wfx_status_t)"]
    pub status: u32,
    #[doc = "<Device Public Key"]
    pub ncp_pub_key: [u8; 32usize],
    #[doc = "<Device Public Key MAC"]
    pub ncp_pub_key_mac: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_securelink_exchange_pub_keys_ind_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_securelink_exchange_pub_keys_ind_body_s>(),
        100usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_ind_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_securelink_exchange_pub_keys_ind_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_ind_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_securelink_exchange_pub_keys_ind_body_s>())).status
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_ind_body_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_securelink_exchange_pub_keys_ind_body_s>())).ncp_pub_key
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_ind_body_s),
            "::",
            stringify!(ncp_pub_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_securelink_exchange_pub_keys_ind_body_s>()))
                .ncp_pub_key_mac as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_ind_body_s),
            "::",
            stringify!(ncp_pub_key_mac)
        )
    );
}
pub type sl_wfx_securelink_exchange_pub_keys_ind_body_t =
    sl_wfx_securelink_exchange_pub_keys_ind_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_securelink_exchange_pub_keys_ind_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_securelink_exchange_pub_keys_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_securelink_exchange_pub_keys_ind_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_securelink_exchange_pub_keys_ind_s>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_ind_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_securelink_exchange_pub_keys_ind_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_ind_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_securelink_exchange_pub_keys_ind_s>())).header
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_securelink_exchange_pub_keys_ind_s>())).body as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_exchange_pub_keys_ind_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_securelink_exchange_pub_keys_ind_t = sl_wfx_securelink_exchange_pub_keys_ind_s;
#[doc = " @brief Configure Secure Link Layer"]
#[doc = ""]
#[doc = " This API can be used to:"]
#[doc = " - Set/update the Secure Link *encryption bitmap*"]
#[doc = " - Disable Session Key Protection"]
#[doc = ""]
#[doc = " About the Session Key protection:"]
#[doc = " SecureLink underlying encryption algorithm is AES CCM. This algorithm is using an internal Nonce counter incremented each time a message is"]
#[doc = " encrypted/decrypted. This counter is not supposed to go beyond a given limit to guarantee AES CCM security properties."]
#[doc = " This is why Host Driver is responsible for renegotiating the session key once the message counter is approaching the limit."]
#[doc = " Disabling the Session Key protection will disable the check performed by the firmware that the Nonce counter is crossing the limit,"]
#[doc = " allowing Host Driver to use the same session key during the same power cycle, even during a very long time."]
#[doc = " This behavior is not recommended."]
#[doc = ""]
#[doc = " To disable the protection, a given magic word (SL_WFX_SESSION_KEY_PROTECTION_DISABLE_MAGIC) must be provided as _DisableSessionKeyProtection_ parameter value. Any other value will let the protection set."]
#[doc = ""]
#[doc = " @note When SecureLink is activated, _SL Configure_ API must be called right after the key exchange."]
#[doc = " @note It is not recommended to call this API a second time during the same power cycle."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_securelink_configure_req_body_s {
    #[doc = "<Encryption bitmap"]
    pub encr_bmp: [u8; 32usize],
    #[doc = "<Force the firmware to authorize the use of the same session key during a complete power cycle, even very long. NOT RECOMMENDED"]
    pub disable_session_key_protection: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_securelink_configure_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_securelink_configure_req_body_s>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_securelink_configure_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_securelink_configure_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_securelink_configure_req_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_securelink_configure_req_body_s>())).encr_bmp as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_configure_req_body_s),
            "::",
            stringify!(encr_bmp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_securelink_configure_req_body_s>()))
                .disable_session_key_protection as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_configure_req_body_s),
            "::",
            stringify!(disable_session_key_protection)
        )
    );
}
pub type sl_wfx_securelink_configure_req_body_t = sl_wfx_securelink_configure_req_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_securelink_configure_req_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_securelink_configure_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_securelink_configure_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_securelink_configure_req_s>(),
        40usize,
        concat!("Size of: ", stringify!(sl_wfx_securelink_configure_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_securelink_configure_req_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_securelink_configure_req_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_securelink_configure_req_s>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_configure_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_securelink_configure_req_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_configure_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_securelink_configure_req_t = sl_wfx_securelink_configure_req_s;
#[doc = " @brief Confirmation of Secure Link Layer configuration sl_wfx_securelink_configure_req_body_t"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_securelink_configure_cnf_body_s {
    #[doc = "<Request status (see enum wsm_status)"]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_securelink_configure_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_securelink_configure_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_securelink_configure_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_securelink_configure_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_securelink_configure_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_securelink_configure_cnf_body_s>())).status as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_configure_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_securelink_configure_cnf_body_t = sl_wfx_securelink_configure_cnf_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_securelink_configure_cnf_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_securelink_configure_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_securelink_configure_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_securelink_configure_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_securelink_configure_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_securelink_configure_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_securelink_configure_cnf_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_securelink_configure_cnf_s>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_configure_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_securelink_configure_cnf_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_securelink_configure_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_securelink_configure_cnf_t = sl_wfx_securelink_configure_cnf_s;
#[doc = "@brief Prevent Rollback request"]
#[doc = ""]
#[doc = " *Prevent Rollback* asks WLAN firmware to burn a new *Firmware Rollback* value in a dedicated OTP section."]
#[doc = ""]
#[doc = " The new value is encoded in the firmware itself. After it is burned, this value will prevent from starting"]
#[doc = "  all firmwares whose internal rollback value is lower than the OTP value."]
#[doc = ""]
#[doc = " *Magic Word* is used to prevent mistakenly sent requests from burning the OTP."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_prevent_rollback_req_body_s {
    #[doc = "<Magic Word - should be 0x5C8912F3"]
    pub magic_word: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_prevent_rollback_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_prevent_rollback_req_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_prevent_rollback_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_prevent_rollback_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_prevent_rollback_req_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_prevent_rollback_req_body_s>())).magic_word as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_prevent_rollback_req_body_s),
            "::",
            stringify!(magic_word)
        )
    );
}
pub type sl_wfx_prevent_rollback_req_body_t = sl_wfx_prevent_rollback_req_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_prevent_rollback_req_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_prevent_rollback_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_prevent_rollback_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_prevent_rollback_req_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_prevent_rollback_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_prevent_rollback_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_prevent_rollback_req_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_prevent_rollback_req_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_prevent_rollback_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_prevent_rollback_req_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_prevent_rollback_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_prevent_rollback_req_t = sl_wfx_prevent_rollback_req_s;
#[doc = " @brief Confirmation of the *Prevent Rollback* request"]
#[doc = ""]
#[doc = " The request might have failed for the following reasons:"]
#[doc = " - Wrong *magic word* value"]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_prevent_rollback_cnf_body_s {
    #[doc = "<Confirmation status, see enum sl_wfx_status_t"]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_prevent_rollback_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_prevent_rollback_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_prevent_rollback_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_prevent_rollback_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_prevent_rollback_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_prevent_rollback_cnf_body_s>())).status as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_prevent_rollback_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_prevent_rollback_cnf_body_t = sl_wfx_prevent_rollback_cnf_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_prevent_rollback_cnf_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_prevent_rollback_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_prevent_rollback_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_prevent_rollback_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_prevent_rollback_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_prevent_rollback_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_prevent_rollback_cnf_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_prevent_rollback_cnf_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_prevent_rollback_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_prevent_rollback_cnf_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_prevent_rollback_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_prevent_rollback_cnf_t = sl_wfx_prevent_rollback_cnf_s;
#[doc = "< PTA 1-wire interface with WLAN master on PTA_TX_CONF pin (GRANT signal),"]
pub const sl_wfx_pta_mode_e_SL_WFX_PTA_1W_WLAN_MASTER: sl_wfx_pta_mode_e = 0;
#[doc = "< PTA 1-wire interface with COEX master on PTA_RF_ACT pin (REQUEST signal),"]
pub const sl_wfx_pta_mode_e_SL_WFX_PTA_1W_COEX_MASTER: sl_wfx_pta_mode_e = 1;
#[doc = "< PTA 2-wire interface on PTA_RF_ACT and PTA_TX_CONF pins (respectively REQUEST and GRANT signals),"]
pub const sl_wfx_pta_mode_e_SL_WFX_PTA_2W: sl_wfx_pta_mode_e = 2;
#[doc = "< PTA 3-wire interface on same pins as SL_WFX_PTA_2W, plus PTA_STATUS pin (PRIORITY signal)"]
pub const sl_wfx_pta_mode_e_SL_WFX_PTA_3W: sl_wfx_pta_mode_e = 3;
#[doc = "< PTA 4-wire interface on same pins as SL_WFX_PTA_3W, plus PTA_FREQ pin (FREQ signal)."]
pub const sl_wfx_pta_mode_e_SL_WFX_PTA_4W: sl_wfx_pta_mode_e = 4;
#[doc = " @brief PTA modes."]
pub type sl_wfx_pta_mode_e = u32;
pub use self::sl_wfx_pta_mode_e as sl_wfx_pta_mode_t;
#[doc = "< Signal level is low"]
pub const sl_wfx_signal_level_e_SL_WFX_SIGNAL_LOW: sl_wfx_signal_level_e = 0;
#[doc = "< Signal level is high"]
pub const sl_wfx_signal_level_e_SL_WFX_SIGNAL_HIGH: sl_wfx_signal_level_e = 1;
#[doc = " @brief Signal levels."]
pub type sl_wfx_signal_level_e = u32;
pub use self::sl_wfx_signal_level_e as sl_wfx_signal_level_t;
#[doc = "< IEEE 802.15.4 standards ZigBee SDK, Thread SDK, and so on."]
pub const sl_wfx_coex_type_e_SL_WFX_COEX_TYPE_GENERIC: sl_wfx_coex_type_e = 0;
#[doc = "< Bluetooth Low-Energy Stack"]
pub const sl_wfx_coex_type_e_SL_WFX_COEX_TYPE_BLE: sl_wfx_coex_type_e = 1;
#[doc = " @brief Coexistence types supported by PTA."]
pub type sl_wfx_coex_type_e = u32;
pub use self::sl_wfx_coex_type_e as sl_wfx_coex_type_t;
#[doc = "< WLAN has the RF, Coex is not allowed to transmit"]
pub const sl_wfx_grant_state_e_SL_WFX_NO_GRANT: sl_wfx_grant_state_e = 0;
#[doc = "< Coex is granted"]
pub const sl_wfx_grant_state_e_SL_WFX_GRANT: sl_wfx_grant_state_e = 1;
#[doc = " @brief Grant states."]
pub type sl_wfx_grant_state_e = u32;
pub use self::sl_wfx_grant_state_e as sl_wfx_grant_state_t;
#[doc = " @brief Request sent by the host to set the PTA mode, the active levels on signals, the Coex type,"]
#[doc = " to define the timings, quotas, combined mode and default grant state."]
#[doc = ""]
#[doc = " Depending on specified PTA mode, every setting is not necessarily used and can then be set to '0'.<br/>"]
#[doc = " The following table indicates the PTA mode for which the setting is significant.<br/>"]
#[doc = " Combined mode is activated during concurrent RX (WLAN and Coex) requests and if SimultaneousRxAccesses is set to '1'."]
#[doc = ""]
#[doc = " | Settings                 | 1-wire WLAN Master | 1-wire Coex Master | 2-wire | 3-wire | 3-wire (combined) | 4-wire | 4-wire (combined) |"]
#[doc = " |--------------------------|:------------------:|:------------------:|:------:|:------:|:-----------------:|:------:|:-----------------:|"]
#[doc = " | PrioritySamplingTime     |                    |                    |        |    x   |          x        |    x   |          x        |"]
#[doc = " | TxRxSamplingTime         |                    |                    |        |        |          x        |        |          x        |"]
#[doc = " | FreqSamplingTime         |                    |                    |        |        |                   |    x   |          x        |"]
#[doc = " | GrantValidTime           |                    |                    |        |    x   |          x        |    x   |          x        |"]
#[doc = " | FemControlTime           |                    |                    |        |    x   |          x        |    x   |          x        |"]
#[doc = " | FirstSlotTime            |                    |                    |        |        |          x        |        |          x        |"]
#[doc = " | PeriodicTxRxSamplingTime |                    |                    |        |        |          x        |        |          x        |"]
#[doc = " | CoexQuota                |         x          |                    |    x   |        |                   |        |                   |"]
#[doc = " | WlanQuota                |         x          |                    |    x   |        |                   |        |                   |"]
#[doc = ""]
#[doc = " <br/>"]
#[doc = " @image html 3w-timings-sequence.svg \"Sequence diagram with 3-wire PTA mode\""]
#[doc = " <br/>"]
#[doc = " @image html 4w-timings-sequence.svg \"Sequence diagram with 4-wire PTA mode\""]
#[doc = ""]
#[doc = " @note Request will fail if PTA is started."]
#[doc = ""]
#[doc = " @warning"]
#[doc = " The following assertions must be respected:"]
#[doc = " - priority_sampling_time < tx_rx_sampling_time < grant_valid_time <= first_slot_time"]
#[doc = " - freq_sampling_time < grant_valid_time < fem_control_time"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_settings_req_body_s {
    #[doc = "< The PTA mode, see enum ::sl_wfx_pta_mode_t"]
    pub pta_mode: u8,
    #[doc = "< Active level on REQUEST signal (PTA_RF_ACT pin), provided by Coex to request the RF, see enum ::sl_wfx_signal_level_t"]
    pub request_signal_active_level: u8,
    #[doc = "< Active level on PRIORITY signal (PTA_STATUS pin), provided by Coex to set the priority of the request, see enum ::sl_wfx_signal_level_t"]
    pub priority_signal_active_level: u8,
    #[doc = "< Active level on FREQ signal (PTA_FREQ pin), provided by Coex in 4-wire mode when Coex and WLAN share the same band, see enum ::sl_wfx_signal_level_t"]
    pub freq_signal_active_level: u8,
    #[doc = "< Active level on GRANT signal (PTA_TX_CONF pin), generated by PTA to grant the RF to Coex, see enum ::sl_wfx_signal_level_t"]
    pub grant_signal_active_level: u8,
    #[doc = "< The Coex type, see enum ::sl_wfx_coex_type_t"]
    pub coex_type: u8,
    #[doc = "< The state of the GRANT signal before arbitration at grant_valid_time, see enum ::sl_wfx_grant_state_t"]
    pub default_grant_state: u8,
    #[doc = "< Boolean to allow both Coex and WLAN to receive concurrently, also named combined mode"]
    pub simultaneous_rx_access: u8,
    #[doc = "< The time (in microseconds) from the Coex request to the sampling of the priority on PRIORITY signal (1 to 31)"]
    pub priority_sampling_time: u8,
    #[doc = "< The time (in microseconds) from the Coex request to the sampling of the directionality on PRIORITY signal (priority_sampling_time to 63)"]
    pub tx_rx_sampling_time: u8,
    #[doc = "< The time (in microseconds) from the Coex request to the sampling of freq-match information on FREQ signal (1 to 127)"]
    pub freq_sampling_time: u8,
    #[doc = "< The time (in microseconds) from Coex request to the GRANT signal assertion (MAX(tx_rx_sampling_time, freq_sampling_time) to 255)"]
    pub grant_valid_time: u8,
    #[doc = "< The time (in microseconds) from Coex request to the control of FEM (grant_valid_time to 255)"]
    pub fem_control_time: u8,
    #[doc = "< The time (in microseconds) from the Coex request to the beginning of reception or transmission (grant_valid_time to 255)"]
    pub first_slot_time: u8,
    #[doc = "< The period (in microseconds) from first_slot_time of following samplings of the directionality on PRIORITY signal (1 to 1023)"]
    pub periodic_tx_rx_sampling_time: u16,
    #[doc = "< The duration (in microseconds) for which RF is granted to Coex before it is moved to WLAN"]
    pub coex_quota: u16,
    #[doc = "< The duration (in microseconds) for which RF is granted to WLAN before it is moved to Coex"]
    pub wlan_quota: u16,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_settings_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_settings_req_body_s>(),
        20usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_settings_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_settings_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_settings_req_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_settings_req_body_s>())).pta_mode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(pta_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_settings_req_body_s>())).request_signal_active_level
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(request_signal_active_level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_settings_req_body_s>())).priority_signal_active_level
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(priority_signal_active_level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_settings_req_body_s>())).freq_signal_active_level
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(freq_signal_active_level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_settings_req_body_s>())).grant_signal_active_level
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(grant_signal_active_level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_settings_req_body_s>())).coex_type as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(coex_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_settings_req_body_s>())).default_grant_state
                as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(default_grant_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_settings_req_body_s>())).simultaneous_rx_access
                as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(simultaneous_rx_access)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_settings_req_body_s>())).priority_sampling_time
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(priority_sampling_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_settings_req_body_s>())).tx_rx_sampling_time
                as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(tx_rx_sampling_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_settings_req_body_s>())).freq_sampling_time
                as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(freq_sampling_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_settings_req_body_s>())).grant_valid_time as *const _
                as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(grant_valid_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_settings_req_body_s>())).fem_control_time as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(fem_control_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_settings_req_body_s>())).first_slot_time as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(first_slot_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_settings_req_body_s>())).periodic_tx_rx_sampling_time
                as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(periodic_tx_rx_sampling_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_settings_req_body_s>())).coex_quota as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(coex_quota)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_settings_req_body_s>())).wlan_quota as *const _
                as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_body_s),
            "::",
            stringify!(wlan_quota)
        )
    );
}
pub type sl_wfx_pta_settings_req_body_t = sl_wfx_pta_settings_req_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_settings_req_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_pta_settings_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_settings_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_settings_req_s>(),
        24usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_settings_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_settings_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_settings_req_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_settings_req_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_pta_settings_req_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_pta_settings_req_t = sl_wfx_pta_settings_req_s;
#[doc = " @brief Confirmation sent by WLAN firmware after a ::SL_WFX_PTA_SETTINGS_REQ_ID request."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_settings_cnf_body_s {
    #[doc = "< Confirmation status, see enum ::sl_wfx_status_t"]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_settings_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_settings_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_settings_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_settings_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_settings_cnf_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_settings_cnf_body_s>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_pta_settings_cnf_body_t = sl_wfx_pta_settings_cnf_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_settings_cnf_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_pta_settings_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_settings_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_settings_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_settings_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_settings_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_settings_cnf_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_settings_cnf_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_pta_settings_cnf_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_settings_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_pta_settings_cnf_t = sl_wfx_pta_settings_cnf_s;
#[doc = "< Maximizes priority to COEX, WLAN connection is not ensured"]
pub const sl_wfx_pta_priority_e_SL_WFX_PTA_PRIORITY_COEX_MAXIMIZED: sl_wfx_pta_priority_e = 1378;
#[doc = "< High priority to COEX, targets low-latency to COEX"]
pub const sl_wfx_pta_priority_e_SL_WFX_PTA_PRIORITY_COEX_HIGH: sl_wfx_pta_priority_e = 1122;
#[doc = "< Balanced PTA arbitration, WLAN acknowledge receptions are protected"]
pub const sl_wfx_pta_priority_e_SL_WFX_PTA_PRIORITY_BALANCED: sl_wfx_pta_priority_e = 5217;
#[doc = "< High priority to WLAN, protects WLAN transmissions"]
pub const sl_wfx_pta_priority_e_SL_WFX_PTA_PRIORITY_WLAN_HIGH: sl_wfx_pta_priority_e = 6225;
#[doc = "< Maximizes priority to WLAN"]
pub const sl_wfx_pta_priority_e_SL_WFX_PTA_PRIORITY_WLAN_MAXIMIZED: sl_wfx_pta_priority_e = 6737;
#[doc = " @brief Priority levels used by PTA for concurrent (Coex and WLAN) request arbitration."]
pub type sl_wfx_pta_priority_e = u32;
pub use self::sl_wfx_pta_priority_e as sl_wfx_pta_priority_t;
#[doc = " @brief Request sent by the host to define the level of priority used to arbitrate concurrent Coex and WLAN requests."]
#[doc = ""]
#[doc = " Priority can be one value from enum ::sl_wfx_pta_priority_t but can also be an integer value whom definition is the following bitfield:"]
#[doc = ""]
#[doc = " @code{.c}"]
#[doc = " struct sl_wfx_pta_priority_s"]
#[doc = " {"]
#[doc = "   uint32_t coex_prio_low:3;    // Priority given to Coex for low-priority requests"]
#[doc = "   uint32_t reserved_1:1;       // Reserved for future use"]
#[doc = "   uint32_t coex_prio_high:3;   // Priority given to Coex for high-priority requests"]
#[doc = "   uint32_t reserved_2:1;       // Reserved for future use"]
#[doc = "   uint32_t grant_coex:1;       // Allows Coex to override WLAN"]
#[doc = "   uint32_t grant_wlan:1;       // Allows WLAN to override Coex whenever WLAN is not idle"]
#[doc = "   uint32_t protect_coex:1;     // WLAN grant is delayed until Coex has finished its present granted transaction"]
#[doc = "   uint32_t protect_wlan_tx:1;  // Prevents Coex from being granted when WLAN is transmitting (the protection is also extended to the response)"]
#[doc = "   uint32_t protect_wlan_rx:1;  // Prevents Coex from being granted when WLAN is receiving or waiting for a response to an already transmitted frame"]
#[doc = "   uint32_t reserved_3:19;      // Reserved for future use"]
#[doc = " }"]
#[doc = " @endcode"]
#[doc = ""]
#[doc = " @note Request will fail if PTA is started."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_priority_req_body_s {
    #[doc = "< The priority level, see enum ::sl_wfx_pta_priority_t"]
    pub priority: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_priority_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_priority_req_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_priority_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_priority_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_priority_req_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_priority_req_body_s>())).priority as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_priority_req_body_s),
            "::",
            stringify!(priority)
        )
    );
}
pub type sl_wfx_pta_priority_req_body_t = sl_wfx_pta_priority_req_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_priority_req_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_pta_priority_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_priority_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_priority_req_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_priority_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_priority_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_priority_req_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_priority_req_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_priority_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_pta_priority_req_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_priority_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_pta_priority_req_t = sl_wfx_pta_priority_req_s;
#[doc = " @brief Confirmation sent by WLAN firmware after a ::SL_WFX_PTA_PRIORITY_REQ_ID request."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_priority_cnf_body_s {
    #[doc = "< Confirmation status, see enum ::sl_wfx_status_t"]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_priority_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_priority_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_priority_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_priority_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_priority_cnf_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_priority_cnf_body_s>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_priority_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_pta_priority_cnf_body_t = sl_wfx_pta_priority_cnf_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_priority_cnf_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_pta_priority_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_priority_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_priority_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_priority_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_priority_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_priority_cnf_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_priority_cnf_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_priority_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_pta_priority_cnf_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_priority_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_pta_priority_cnf_t = sl_wfx_pta_priority_cnf_s;
#[doc = "< PTA is off"]
pub const sl_wfx_pta_state_e_SL_WFX_PTA_OFF: sl_wfx_pta_state_e = 0;
#[doc = "< PTA is on"]
pub const sl_wfx_pta_state_e_SL_WFX_PTA_ON: sl_wfx_pta_state_e = 1;
#[doc = " @brief PTA states."]
pub type sl_wfx_pta_state_e = u32;
pub use self::sl_wfx_pta_state_e as sl_wfx_pta_state_t;
#[doc = " @brief Request sent by host to start or stop the PTA."]
#[doc = " @note Starting PTA will fail if not first configured with ::sl_wfx_pta_settings_req_body_t request."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_state_req_body_s {
    #[doc = "< Requested PTA state, see enum ::sl_wfx_pta_state_t"]
    pub pta_state: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_state_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_state_req_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_state_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_state_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_state_req_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_state_req_body_s>())).pta_state as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_state_req_body_s),
            "::",
            stringify!(pta_state)
        )
    );
}
pub type sl_wfx_pta_state_req_body_t = sl_wfx_pta_state_req_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_state_req_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_pta_state_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_state_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_state_req_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_state_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_state_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_state_req_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_pta_state_req_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_state_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_pta_state_req_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_state_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_pta_state_req_t = sl_wfx_pta_state_req_s;
#[doc = " @brief Confirmation sent by WLAN firmware after a ::SL_WFX_PTA_STATE_REQ_ID request."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_state_cnf_body_s {
    #[doc = "< Confirmation status, see enum ::sl_wfx_status_t"]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_state_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_state_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_state_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_state_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_state_cnf_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_pta_state_cnf_body_s>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_state_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_pta_state_cnf_body_t = sl_wfx_pta_state_cnf_body_s;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_pta_state_cnf_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_pta_state_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_pta_state_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_pta_state_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_pta_state_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_pta_state_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_pta_state_cnf_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_pta_state_cnf_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_state_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_pta_state_cnf_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_pta_state_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_pta_state_cnf_t = sl_wfx_pta_state_cnf_s;
#[doc = "< \\b SET_MAC_ADDRESS request ID uses body SL_WFX_SET_MAC_ADDRESS_REQ_BODY and returns SL_WFX_SET_MAC_ADDRESS_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_MAC_ADDRESS_REQ_ID: sl_wfx_requests_ids_e = 66;
#[doc = "< \\b CONNECT request ID uses body SL_WFX_CONNECT_REQ_BODY and returns SL_WFX_CONNECT_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_CONNECT_REQ_ID: sl_wfx_requests_ids_e = 67;
#[doc = "< \\b DISCONNECT request ID uses body SL_WFX_DISCONNECT_REQ_BODY and returns SL_WFX_DISCONNECT_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_DISCONNECT_REQ_ID: sl_wfx_requests_ids_e = 68;
#[doc = "< \\b START_AP request ID uses body SL_WFX_START_AP_REQ_BODY and returns SL_WFX_START_AP_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_START_AP_REQ_ID: sl_wfx_requests_ids_e = 69;
#[doc = "< \\b UPDATE_AP request ID uses body SL_WFX_UPDATE_AP_REQ_BODY and returns SL_WFX_UPDATE_AP_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_UPDATE_AP_REQ_ID: sl_wfx_requests_ids_e = 70;
#[doc = "< \\b STOP_AP request ID uses body SL_WFX_STOP_AP_REQ_BODY and returns SL_WFX_STOP_AP_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_STOP_AP_REQ_ID: sl_wfx_requests_ids_e = 71;
#[doc = "< \\b SEND_FRAME request ID uses body SL_WFX_SEND_FRAME_REQ_BODY and returns SL_WFX_SEND_FRAME_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SEND_FRAME_REQ_ID: sl_wfx_requests_ids_e = 74;
#[doc = "< \\b START_SCAN request ID uses body SL_WFX_START_SCAN_REQ_BODY and returns SL_WFX_START_SCAN_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_START_SCAN_REQ_ID: sl_wfx_requests_ids_e = 75;
#[doc = "< \\b STOP_SCAN request ID uses body SL_WFX_STOP_SCAN_REQ_BODY and returns SL_WFX_STOP_SCAN_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_STOP_SCAN_REQ_ID: sl_wfx_requests_ids_e = 76;
#[doc = "< \\b GET_SIGNAL_STRENGTH request ID uses body SL_WFX_GET_SIGNAL_STRENGTH_REQ_BODY and returns SL_WFX_GET_SIGNAL_STRENGTH_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_GET_SIGNAL_STRENGTH_REQ_ID: sl_wfx_requests_ids_e = 78;
#[doc = "< \\b DISCONNECT_AP_CLIENT request ID uses body SL_WFX_DISCONNECT_AP_CLIENT_REQ_BODY and returns SL_WFX_DISCONNECT_AP_CLIENT_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_DISCONNECT_AP_CLIENT_REQ_ID: sl_wfx_requests_ids_e = 79;
#[doc = "< \\b JOIN_IBSS request ID uses body SL_WFX_JOIN_IBSS_REQ_BODY and returns SL_WFX_JOIN_IBSS_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_JOIN_IBSS_REQ_ID: sl_wfx_requests_ids_e = 80;
#[doc = "< \\b LEAVE_IBSS request ID uses body SL_WFX_LEAVE_IBSS_REQ_BODY and returns SL_WFX_LEAVE_IBSS_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_LEAVE_IBSS_REQ_ID: sl_wfx_requests_ids_e = 81;
#[doc = "< \\b SET_PM_MODE request ID uses body SL_WFX_SET_PM_MODE_REQ_BODY and returns SL_WFX_SET_PM_MODE_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_PM_MODE_REQ_ID: sl_wfx_requests_ids_e = 82;
#[doc = "< \\b ADD_MULTICAST_ADDR request ID uses body SL_WFX_ADD_MULTICAST_ADDR_REQ_BODY and returns SL_WFX_ADD_MULTICAST_ADDR_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_ADD_MULTICAST_ADDR_REQ_ID: sl_wfx_requests_ids_e = 83;
#[doc = "< \\b REMOVE_MULTICAST_ADDR request ID uses body SL_WFX_REMOVE_MULTICAST_ADDR_REQ_BODY and returns SL_WFX_REMOVE_MULTICAST_ADDR_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_REMOVE_MULTICAST_ADDR_REQ_ID: sl_wfx_requests_ids_e = 84;
#[doc = "< \\b SET_MAX_AP_CLIENT_COUNT request ID uses body SL_WFX_SET_MAX_AP_CLIENT_COUNT_REQ_BODY and returns SL_WFX_SET_MAX_AP_CLIENT_COUNT_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_MAX_AP_CLIENT_COUNT_REQ_ID: sl_wfx_requests_ids_e = 85;
#[doc = "< \\b SET_MAX_AP_CLIENT_INACTIVITY request ID uses body SL_WFX_SET_MAX_AP_CLIENT_INACTIVITY_REQ_BODY and returns SL_WFX_SET_MAX_AP_CLIENT_INACTIVITY_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_MAX_AP_CLIENT_INACTIVITY_REQ_ID: sl_wfx_requests_ids_e =
    86;
#[doc = "< \\b SET_ROAM_PARAMETERS request ID uses body SL_WFX_SET_ROAM_PARAMETERS_REQ_BODY and returns SL_WFX_SET_ROAM_PARAMETERS_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_ROAM_PARAMETERS_REQ_ID: sl_wfx_requests_ids_e = 87;
#[doc = "< \\b SET_TX_RATE_PARAMETERS request ID uses body SL_WFX_SET_TX_RATE_PARAMETERS_REQ_BODY and returns SL_WFX_SET_TX_RATE_PARAMETERS_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_TX_RATE_PARAMETERS_REQ_ID: sl_wfx_requests_ids_e = 88;
#[doc = "< \\b SET_ARP_IP_ADDRESS request ID uses body SL_WFX_SET_ARP_IP_ADDRESS_REQ_BODY and returns SL_WFX_SET_ARP_IP_ADDRESS_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_ARP_IP_ADDRESS_REQ_ID: sl_wfx_requests_ids_e = 89;
#[doc = "< \\b SET_NS_IP_ADDRESS request ID uses body SL_WFX_SET_NS_IP_ADDRESS_REQ_BODY and returns SL_WFX_SET_NS_IP_ADDRESS_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_NS_IP_ADDRESS_REQ_ID: sl_wfx_requests_ids_e = 90;
#[doc = "< \\b SET_BROADCAST_FILTER request ID uses body SL_WFX_SET_BROADCAST_FILTER_REQ_BODY and returns SL_WFX_SET_BROADCAST_FILTER_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_BROADCAST_FILTER_REQ_ID: sl_wfx_requests_ids_e = 91;
#[doc = "< \\b SET_SCAN_PARAMETERS request ID uses body SL_WFX_SET_SCAN_PARAMETERS_REQ_BODY and returns SL_WFX_SET_SCAN_PARAMETERS_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_SCAN_PARAMETERS_REQ_ID: sl_wfx_requests_ids_e = 92;
#[doc = "< \\b SET_UNICAST_FILTER request ID uses body SL_WFX_SET_UNICAST_FILTER_REQ_BODY and returns SL_WFX_SET_UNICAST_FILTER_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_UNICAST_FILTER_REQ_ID: sl_wfx_requests_ids_e = 93;
#[doc = "< \\b ADD_WHITELIST_ADDR request ID uses body SL_WFX_ADD_WHITELIST_ADDR_REQ_BODY and returns SL_WFX_ADD_WHITELIST_ADDR_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_ADD_WHITELIST_ADDR_REQ_ID: sl_wfx_requests_ids_e = 94;
#[doc = "< \\b ADD_BLACKLIST_ADDR request ID uses body SL_WFX_ADD_BLACKLIST_ADDR_REQ_BODY and returns SL_WFX_ADD_BLACKLIST_ADDR_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_ADD_BLACKLIST_ADDR_REQ_ID: sl_wfx_requests_ids_e = 95;
#[doc = "< \\b SET_MAX_TX_POWER request ID uses body SL_WFX_SET_MAX_TX_POWER_REQ_BODY and returns SL_WFX_SET_MAX_TX_POWER_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_SET_MAX_TX_POWER_REQ_ID: sl_wfx_requests_ids_e = 96;
#[doc = "< \\b GET_MAX_TX_POWER request ID uses body SL_WFX_GET_MAX_TX_POWER_REQ_BODY and returns SL_WFX_GET_MAX_TX_POWER_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_GET_MAX_TX_POWER_REQ_ID: sl_wfx_requests_ids_e = 97;
#[doc = "< \\b GET_PMK request ID uses body SL_WFX_GET_PMK_REQ_BODY and returns SL_WFX_GET_PMK_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_GET_PMK_REQ_ID: sl_wfx_requests_ids_e = 98;
#[doc = "< \\b GET_AP_CLIENT_SIGNAL_STRENGTH request ID uses body SL_WFX_GET_AP_CLIENT_SIGNAL_STRENGTH_BODY and returns SL_WFX_GET_AP_CLIENT_SIGNAL_STRENGTH_CNF_BODY"]
pub const sl_wfx_requests_ids_e_SL_WFX_GET_AP_CLIENT_SIGNAL_STRENGTH_REQ_ID: sl_wfx_requests_ids_e =
    99;
#[doc = " @brief WFM API request message IDs."]
pub type sl_wfx_requests_ids_e = u32;
pub use self::sl_wfx_requests_ids_e as sl_wfx_requests_ids_t;
#[doc = "< \\b SET_MAC_ADDRESS confirmation Id. Returns body SL_WFX_SET_MAC_ADDRESS_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_MAC_ADDRESS_CNF_ID: sl_wfx_confirmations_ids_e = 66;
#[doc = "< \\b CONNECT confirmation Id. Returns body SL_WFX_CONNECT_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_CONNECT_CNF_ID: sl_wfx_confirmations_ids_e = 67;
#[doc = "< \\b DISCONNECT confirmation Id. Returns body SL_WFX_DISCONNECT_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_DISCONNECT_CNF_ID: sl_wfx_confirmations_ids_e = 68;
#[doc = "< \\b START_AP confirmation Id. Returns body SL_WFX_START_AP_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_START_AP_CNF_ID: sl_wfx_confirmations_ids_e = 69;
#[doc = "< \\b UPDATE_AP confirmation Id. Returns body SL_WFX_UPDATE_AP_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_UPDATE_AP_CNF_ID: sl_wfx_confirmations_ids_e = 70;
#[doc = "< \\b STOP_AP confirmation Id. Returns body SL_WFX_STOP_AP_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_STOP_AP_CNF_ID: sl_wfx_confirmations_ids_e = 71;
#[doc = "< \\b SEND_FRAME confirmation Id. Returns body SL_WFX_SEND_FRAME_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SEND_FRAME_CNF_ID: sl_wfx_confirmations_ids_e = 74;
#[doc = "< \\b START_SCAN confirmation Id. Returns body SL_WFX_START_SCAN_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_START_SCAN_CNF_ID: sl_wfx_confirmations_ids_e = 75;
#[doc = "< \\b STOP_SCAN confirmation Id. Returns body SL_WFX_STOP_SCAN_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_STOP_SCAN_CNF_ID: sl_wfx_confirmations_ids_e = 76;
#[doc = "< \\b GET_SIGNAL_STRENGTH confirmation Id. Returns body SL_WFX_GET_SIGNAL_STRENGTH_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_GET_SIGNAL_STRENGTH_CNF_ID: sl_wfx_confirmations_ids_e =
    78;
#[doc = "< \\b DISCONNECT_AP_CLIENT confirmation Id. Returns body SL_WFX_DISCONNECT_AP_CLIENT_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_DISCONNECT_AP_CLIENT_CNF_ID:
    sl_wfx_confirmations_ids_e = 79;
#[doc = "< \\b JOIN_IBSS confirmation Id. Returns body SL_WFX_JOIN_IBSS_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_JOIN_IBSS_CNF_ID: sl_wfx_confirmations_ids_e = 80;
#[doc = "< \\b LEAVE_IBSS confirmation Id. Returns body SL_WFX_LEAVE_IBSS_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_LEAVE_IBSS_CNF_ID: sl_wfx_confirmations_ids_e = 81;
#[doc = "< \\b SET_PM_MODE confirmation Id. Returns body SL_WFX_SET_PM_MODE_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_PM_MODE_CNF_ID: sl_wfx_confirmations_ids_e = 82;
#[doc = "< \\b ADD_MULTICAST_ADDR confirmation Id. Returns body SL_WFX_ADD_MULTICAST_ADDR_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_ADD_MULTICAST_ADDR_CNF_ID: sl_wfx_confirmations_ids_e =
    83;
#[doc = "< \\b REMOVE_MULTICAST_ADDR confirmation Id. Returns body SL_WFX_REMOVE_MULTICAST_ADDR_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_REMOVE_MULTICAST_ADDR_CNF_ID:
    sl_wfx_confirmations_ids_e = 84;
#[doc = "< \\b SET_MAX_AP_CLIENT_COUNT confirmation Id. Returns body SL_WFX_SET_MAX_AP_CLIENT_COUNT_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_MAX_AP_CLIENT_COUNT_CNF_ID:
    sl_wfx_confirmations_ids_e = 85;
#[doc = "< \\b SET_MAX_AP_CLIENT_INACTIVITY confirmation Id. Returns body SL_WFX_SET_MAX_AP_CLIENT_INACTIVITY_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_MAX_AP_CLIENT_INACTIVITY_CNF_ID:
    sl_wfx_confirmations_ids_e = 86;
#[doc = "< \\b SET_ROAM_PARAMETERS confirmation Id. Returns body SL_WFX_SET_ROAM_PARAMETERS_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_ROAM_PARAMETERS_CNF_ID: sl_wfx_confirmations_ids_e =
    87;
#[doc = "< \\b SET_TX_RATE_PARAMETERS confirmation Id. Returns body SL_WFX_SET_TX_RATE_PARAMETERS_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_TX_RATE_PARAMETERS_CNF_ID:
    sl_wfx_confirmations_ids_e = 88;
#[doc = "< \\b SET_ARP_IP_ADDRESS confirmation Id. Returns body SL_WFX_SET_ARP_IP_ADDRESS_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_ARP_IP_ADDRESS_CNF_ID: sl_wfx_confirmations_ids_e =
    89;
#[doc = "< \\b SET_NS_IP_ADDRESS confirmation Id. Returns body SL_WFX_SET_NS_IP_ADDRESS_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_NS_IP_ADDRESS_CNF_ID: sl_wfx_confirmations_ids_e =
    90;
#[doc = "< \\b SET_BROADCAST_FILTER confirmation Id. Returns body SL_WFX_SET_BROADCAST_FILTER_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_BROADCAST_FILTER_CNF_ID:
    sl_wfx_confirmations_ids_e = 91;
#[doc = "< \\b SET_SCAN_PARAMETERS confirmation Id. Returns body SL_WFX_SET_SCAN_PARAMETERS_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_SCAN_PARAMETERS_CNF_ID: sl_wfx_confirmations_ids_e =
    92;
#[doc = "< \\b SET_UNICAST_FILTER confirmation Id. Returns body SL_WFX_SET_UNICAST_FILTER_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_UNICAST_FILTER_CNF_ID: sl_wfx_confirmations_ids_e =
    93;
#[doc = "< \\b ADD_WHITELIST_ADDR confirmation Id. Returns body SL_WFX_ADD_WHITELIST_ADDR_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_ADD_WHITELIST_ADDR_CNF_ID: sl_wfx_confirmations_ids_e =
    94;
#[doc = "< \\b ADD_BLACKLIST_ADDR confirmation Id. Returns body SL_WFX_ADD_BLACKLIST_ADDR_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_ADD_BLACKLIST_ADDR_CNF_ID: sl_wfx_confirmations_ids_e =
    95;
#[doc = "< \\b SET_MAX_TX_POWER confirmation Id. Returns body SL_WFX_SET_MAX_TX_POWER_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_SET_MAX_TX_POWER_CNF_ID: sl_wfx_confirmations_ids_e =
    96;
#[doc = "< \\b GET_MAX_TX_POWER confirmation Id. Returns body SL_WFX_GET_MAX_TX_POWER_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_GET_MAX_TX_POWER_CNF_ID: sl_wfx_confirmations_ids_e =
    97;
#[doc = "< \\b GET_PMK confirmation Id. Returns body SL_WFX_GET_PMK_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_GET_PMK_CNF_ID: sl_wfx_confirmations_ids_e = 98;
#[doc = "< \\b GET_AP_CLIENT_SIGNAL_STRENGTH confirmation Id. Returns body SL_WFX_GET_AP_CLIENT_SIGNAL_STRENGTH_CNF_BODY"]
pub const sl_wfx_confirmations_ids_e_SL_WFX_GET_AP_CLIENT_SIGNAL_STRENGTH_CNF_ID:
    sl_wfx_confirmations_ids_e = 99;
#[doc = " @brief WFM API confirmation message IDs."]
pub type sl_wfx_confirmations_ids_e = u32;
pub use self::sl_wfx_confirmations_ids_e as sl_wfx_confirmations_ids_t;
#[doc = "< \\b CONNECT indication id. Content is SL_WFX_CONNECT_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_CONNECT_IND_ID: sl_wfx_indications_ids_e = 195;
#[doc = "< \\b DISCONNECT indication id. Content is SL_WFX_DISCONNECT_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_DISCONNECT_IND_ID: sl_wfx_indications_ids_e = 196;
#[doc = "< \\b START_AP indication id. Content is SL_WFX_START_AP_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_START_AP_IND_ID: sl_wfx_indications_ids_e = 197;
#[doc = "< \\b STOP_AP indication id. Content is SL_WFX_STOP_AP_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_STOP_AP_IND_ID: sl_wfx_indications_ids_e = 199;
#[doc = "< \\b RECEIVED indication id. Content is SL_WFX_RECEIVED_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_RECEIVED_IND_ID: sl_wfx_indications_ids_e = 202;
#[doc = "< \\b SCAN_RESULT indication id. Content is SL_WFX_SCAN_RESULT_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_SCAN_RESULT_IND_ID: sl_wfx_indications_ids_e = 203;
#[doc = "< \\b SCAN_COMPLETE indication id. Content is SL_WFX_SCAN_COMPLETE_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_SCAN_COMPLETE_IND_ID: sl_wfx_indications_ids_e = 204;
#[doc = "< \\b AP_CLIENT_CONNECTED indication id. Content is SL_WFX_AP_CLIENT_CONNECTED_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_AP_CLIENT_CONNECTED_IND_ID: sl_wfx_indications_ids_e =
    205;
#[doc = "< \\b AP_CLIENT_REJECTED indication id. Content is SL_WFX_AP_CLIENT_REJECTED_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_AP_CLIENT_REJECTED_IND_ID: sl_wfx_indications_ids_e = 206;
#[doc = "< \\b AP_CLIENT_DISCONNECTED indication id. Content is SL_WFX_AP_CLIENT_DISCONNECTED_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_AP_CLIENT_DISCONNECTED_IND_ID: sl_wfx_indications_ids_e =
    207;
#[doc = "< \\b JOIN_IBSS indication id. Content is SL_WFX_JOIN_IBSS_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_JOIN_IBSS_IND_ID: sl_wfx_indications_ids_e = 208;
#[doc = "< \\b LEAVE_IBSS indication id. Content is SL_WFX_LEAVE_IBSS_IND_BODY"]
pub const sl_wfx_indications_ids_e_SL_WFX_LEAVE_IBSS_IND_ID: sl_wfx_indications_ids_e = 209;
#[doc = " @brief WFM API indication message IDs."]
pub type sl_wfx_indications_ids_e = u32;
pub use self::sl_wfx_indications_ids_e as sl_wfx_indications_ids_t;
#[doc = " @brief WFM API message IDs."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union wfm_message_ids_u {
    #[doc = " Request messages sent from the host to the device."]
    pub requests: sl_wfx_requests_ids_t,
    #[doc = " Confirmation messages sent from the device to the host."]
    pub confirmations: sl_wfx_confirmations_ids_t,
    #[doc = " Indication messages sent from the device to the host."]
    pub indications: sl_wfx_indications_ids_t,
    _bindgen_union_align: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_wfm_message_ids_u() {
    assert_eq!(
        ::core::mem::size_of::<wfm_message_ids_u>(),
        4usize,
        concat!("Size of: ", stringify!(wfm_message_ids_u))
    );
    assert_eq!(
        ::core::mem::align_of::<wfm_message_ids_u>(),
        1usize,
        concat!("Alignment of ", stringify!(wfm_message_ids_u))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wfm_message_ids_u>())).requests as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wfm_message_ids_u),
            "::",
            stringify!(requests)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<wfm_message_ids_u>())).confirmations as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wfm_message_ids_u),
            "::",
            stringify!(confirmations)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wfm_message_ids_u>())).indications as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wfm_message_ids_u),
            "::",
            stringify!(indications)
        )
    );
}
pub type sl_wfx_message_ids_t = wfm_message_ids_u;
#[doc = "< Client isolation disabled"]
pub const sl_wfx_client_isolation_e_WFM_CLIENT_ISOLATION_DISABLED: sl_wfx_client_isolation_e = 0;
#[doc = "< Client isolation enabled"]
pub const sl_wfx_client_isolation_e_WFM_CLIENT_ISOLATION_ENABLED: sl_wfx_client_isolation_e = 1;
#[doc = " @brief Client Isolation toggling."]
pub type sl_wfx_client_isolation_e = u32;
pub use self::sl_wfx_client_isolation_e as sl_wfx_client_isolation_t;
#[doc = "< Management Frame"]
pub const sl_wfx_frame_type_e_WFM_FRAME_TYPE_MGMT: sl_wfx_frame_type_e = 0;
#[doc = "< Action Frame"]
pub const sl_wfx_frame_type_e_WFM_FRAME_TYPE_ACTION: sl_wfx_frame_type_e = 4;
#[doc = "< Data Frame"]
pub const sl_wfx_frame_type_e_WFM_FRAME_TYPE_DATA: sl_wfx_frame_type_e = 8;
#[doc = " @brief Type of frame to be sent."]
#[doc = ""]
#[doc = " Value unused, all frames are considered to be Data by default.@n"]
#[doc = " Support for the other types will be added later."]
pub type sl_wfx_frame_type_e = u32;
pub use self::sl_wfx_frame_type_e as sl_wfx_frame_type_t;
#[doc = "< SSID not hidden"]
pub const sl_wfx_hidden_ssid_e_WFM_HIDDEN_SSID_FALSE: sl_wfx_hidden_ssid_e = 0;
#[doc = "< SSID hidden"]
pub const sl_wfx_hidden_ssid_e_WFM_HIDDEN_SSID_TRUE: sl_wfx_hidden_ssid_e = 1;
#[doc = " @brief Hidden SSID toggling."]
pub type sl_wfx_hidden_ssid_e = u32;
pub use self::sl_wfx_hidden_ssid_e as sl_wfx_hidden_ssid_t;
#[doc = "< PMF disabled"]
pub const sl_wfx_mgmt_frame_protection_e_WFM_MGMT_FRAME_PROTECTION_DISABLED:
    sl_wfx_mgmt_frame_protection_e = 0;
#[doc = "< PMF optional"]
pub const sl_wfx_mgmt_frame_protection_e_WFM_MGMT_FRAME_PROTECTION_OPTIONAL:
    sl_wfx_mgmt_frame_protection_e = 1;
#[doc = "< PMF mandatory"]
pub const sl_wfx_mgmt_frame_protection_e_WFM_MGMT_FRAME_PROTECTION_MANDATORY:
    sl_wfx_mgmt_frame_protection_e = 2;
#[doc = " @brief Device Protected Management Frame mode."]
pub type sl_wfx_mgmt_frame_protection_e = u32;
pub use self::sl_wfx_mgmt_frame_protection_e as sl_wfx_mgmt_frame_protection_t;
#[doc = "< Always on"]
pub const sl_wfx_pm_mode_e_WFM_PM_MODE_ACTIVE: sl_wfx_pm_mode_e = 0;
#[doc = "< Use power_save and wake up on beacons"]
pub const sl_wfx_pm_mode_e_WFM_PM_MODE_PS: sl_wfx_pm_mode_e = 1;
#[doc = "< Use power_save and wake up on DTIM"]
pub const sl_wfx_pm_mode_e_WFM_PM_MODE_DTIM: sl_wfx_pm_mode_e = 2;
#[doc = " @brief Device power management mode."]
pub type sl_wfx_pm_mode_e = u32;
pub use self::sl_wfx_pm_mode_e as sl_wfx_pm_mode_t;
#[doc = "< Best Effort"]
pub const sl_wfx_priority_e_WFM_PRIORITY_BE0: sl_wfx_priority_e = 0;
#[doc = "< Background"]
pub const sl_wfx_priority_e_WFM_PRIORITY_BK1: sl_wfx_priority_e = 1;
#[doc = "< Background"]
pub const sl_wfx_priority_e_WFM_PRIORITY_BK2: sl_wfx_priority_e = 2;
#[doc = "< Best Effort"]
pub const sl_wfx_priority_e_WFM_PRIORITY_BE3: sl_wfx_priority_e = 3;
#[doc = "< Video"]
pub const sl_wfx_priority_e_WFM_PRIORITY_VI4: sl_wfx_priority_e = 4;
#[doc = "< Video"]
pub const sl_wfx_priority_e_WFM_PRIORITY_VI5: sl_wfx_priority_e = 5;
#[doc = "< Voice"]
pub const sl_wfx_priority_e_WFM_PRIORITY_VO6: sl_wfx_priority_e = 6;
#[doc = "< Voice"]
pub const sl_wfx_priority_e_WFM_PRIORITY_VO7: sl_wfx_priority_e = 7;
#[doc = " @brief Data priority level per 802.1D."]
pub type sl_wfx_priority_e = u32;
pub use self::sl_wfx_priority_e as sl_wfx_priority_t;
#[doc = "< Unspecified reason (unused)"]
pub const sl_wfx_reason_e_WFM_REASON_UNSPECIFIED: sl_wfx_reason_e = 0;
#[doc = "< Client timed out"]
pub const sl_wfx_reason_e_WFM_REASON_TIMEOUT: sl_wfx_reason_e = 1;
#[doc = "< Client left"]
pub const sl_wfx_reason_e_WFM_REASON_LEAVING_BSS: sl_wfx_reason_e = 2;
#[doc = "< Client not authenticated"]
pub const sl_wfx_reason_e_WFM_REASON_UNKNOWN_STA: sl_wfx_reason_e = 3;
#[doc = "< Too many clients already connected"]
pub const sl_wfx_reason_e_WFM_REASON_AP_FULL: sl_wfx_reason_e = 4;
#[doc = "< WPA authentication failed"]
pub const sl_wfx_reason_e_WFM_REASON_AUTHENTICATION_FAILURE: sl_wfx_reason_e = 5;
#[doc = " @brief Reasons for AP to reject or disconnect a client."]
pub type sl_wfx_reason_e = u32;
pub use self::sl_wfx_reason_e as sl_wfx_reason_t;
#[doc = "< Passive scan: listen for beacons only"]
pub const sl_wfx_scan_mode_e_WFM_SCAN_MODE_PASSIVE: sl_wfx_scan_mode_e = 0;
#[doc = "< Active scan: send probe requests"]
pub const sl_wfx_scan_mode_e_WFM_SCAN_MODE_ACTIVE: sl_wfx_scan_mode_e = 1;
#[doc = " @brief Scan mode to be used."]
pub type sl_wfx_scan_mode_e = u32;
pub use self::sl_wfx_scan_mode_e as sl_wfx_scan_mode_t;
#[doc = "< No security"]
pub const sl_wfx_security_mode_e_WFM_SECURITY_MODE_OPEN: sl_wfx_security_mode_e = 0;
#[doc = "< Use WEP"]
pub const sl_wfx_security_mode_e_WFM_SECURITY_MODE_WEP: sl_wfx_security_mode_e = 1;
#[doc = "< Use WPA1 or WPA2"]
pub const sl_wfx_security_mode_e_WFM_SECURITY_MODE_WPA2_WPA1_PSK: sl_wfx_security_mode_e = 2;
#[doc = "< Use only WPA2"]
pub const sl_wfx_security_mode_e_WFM_SECURITY_MODE_WPA2_PSK: sl_wfx_security_mode_e = 4;
#[doc = " @brief Security mode of a network."]
pub type sl_wfx_security_mode_e = u32;
pub use self::sl_wfx_security_mode_e as sl_wfx_security_mode_t;
#[doc = "< The device has successfully completed a request."]
pub const sl_wfx_fmac_status_e_WFM_STATUS_SUCCESS: sl_wfx_fmac_status_e = 0;
#[doc = "< A request contains one or more invalid parameters."]
pub const sl_wfx_fmac_status_e_WFM_STATUS_INVALID_PARAMETER: sl_wfx_fmac_status_e = 1;
#[doc = "< The request cannot be performed because the device is in an inappropriate state."]
pub const sl_wfx_fmac_status_e_WFM_STATUS_WRONG_STATE: sl_wfx_fmac_status_e = 2;
#[doc = "< The request failed due to an error."]
pub const sl_wfx_fmac_status_e_WFM_STATUS_GENERAL_FAILURE: sl_wfx_fmac_status_e = 3;
#[doc = "< The request failed due to regulatory limitations."]
pub const sl_wfx_fmac_status_e_WFM_STATUS_CHANNEL_NOT_ALLOWED: sl_wfx_fmac_status_e = 4;
#[doc = "< The request is successful but some parameters have been ignored."]
pub const sl_wfx_fmac_status_e_WFM_STATUS_WARNING: sl_wfx_fmac_status_e = 5;
#[doc = "< The request failed because no suitable AP was found for the connection"]
pub const sl_wfx_fmac_status_e_WFM_STATUS_NO_MATCHING_AP: sl_wfx_fmac_status_e = 6;
#[doc = "< The request failed because the user issued a WFM_HI_DISCONNECT_REQ before completing the connection"]
pub const sl_wfx_fmac_status_e_WFM_STATUS_CONNECTION_ABORTED: sl_wfx_fmac_status_e = 7;
#[doc = "< The request failed because a timeout occurred during connection"]
pub const sl_wfx_fmac_status_e_WFM_STATUS_CONNECTION_TIMEOUT: sl_wfx_fmac_status_e = 8;
#[doc = "< The request failed because the AP rejected the connection"]
pub const sl_wfx_fmac_status_e_WFM_STATUS_CONNECTION_REJECTED_BY_AP: sl_wfx_fmac_status_e = 9;
#[doc = "< The request failed because the WPA handshake did not complete successfully"]
pub const sl_wfx_fmac_status_e_WFM_STATUS_CONNECTION_AUTH_FAILURE: sl_wfx_fmac_status_e = 10;
#[doc = "< The request failed because the retry limit was exceeded."]
pub const sl_wfx_fmac_status_e_WFM_STATUS_RETRY_EXCEEDED: sl_wfx_fmac_status_e = 19;
#[doc = "< The request failed because the MSDU life time was exceeded."]
pub const sl_wfx_fmac_status_e_WFM_STATUS_TX_LIFETIME_EXCEEDED: sl_wfx_fmac_status_e = 20;
#[doc = " @brief Full MAC (UMAC) confirmation possible values for a returned 'status' field."]
#[doc = ""]
#[doc = " All Full MAC (UMAC) confirmation messages have a field 'status' just after the message header.@n"]
#[doc = " A value of zero indicates the request has completed successfully."]
pub type sl_wfx_fmac_status_e = u32;
pub use self::sl_wfx_fmac_status_e as sl_wfx_fmac_status_t;
#[doc = " @brief Service Set Identifier (SSID) of a network."]
#[doc = " @details Note that the Ssid element must always contain SL_WFX_SSID_SIZE bytes."]
#[doc = "          Only the bytes up to SsidLength are considered to be valid, the rest should be set to zero."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_ssid_def_s {
    #[doc = " @brief Length of SSID data."]
    #[doc = " @details <B>0 - 32</B>: The amount of bytes."]
    pub ssid_length: u32,
    #[doc = " SSID data."]
    pub ssid: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_ssid_def_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ssid_def_s>(),
        36usize,
        concat!("Size of: ", stringify!(sl_wfx_ssid_def_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ssid_def_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_ssid_def_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_ssid_def_s>())).ssid_length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ssid_def_s),
            "::",
            stringify!(ssid_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_ssid_def_s>())).ssid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ssid_def_s),
            "::",
            stringify!(ssid)
        )
    );
}
pub type sl_wfx_ssid_def_t = sl_wfx_ssid_def_s;
#[doc = " @brief Security mode bitmask for scan results. Empty if Open network."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_security_mode_bitmask_s {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_security_mode_bitmask_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_security_mode_bitmask_s>(),
        1usize,
        concat!("Size of: ", stringify!(sl_wfx_security_mode_bitmask_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_security_mode_bitmask_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_security_mode_bitmask_s))
    );
}
impl sl_wfx_security_mode_bitmask_s {
    #[inline]
    pub fn wep(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wep(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wpa(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wpa(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wpa2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wpa2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wpa3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wpa3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pmf(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pmf(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn psk(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_psk(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn eap(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_eap(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wep: u8,
        wpa: u8,
        wpa2: u8,
        wpa3: u8,
        pmf: u8,
        unused: u8,
        psk: u8,
        eap: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wep: u8 = unsafe { ::core::mem::transmute(wep) };
            wep as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let wpa: u8 = unsafe { ::core::mem::transmute(wpa) };
            wpa as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let wpa2: u8 = unsafe { ::core::mem::transmute(wpa2) };
            wpa2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wpa3: u8 = unsafe { ::core::mem::transmute(wpa3) };
            wpa3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let pmf: u8 = unsafe { ::core::mem::transmute(pmf) };
            pmf as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let unused: u8 = unsafe { ::core::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let psk: u8 = unsafe { ::core::mem::transmute(psk) };
            psk as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let eap: u8 = unsafe { ::core::mem::transmute(eap) };
            eap as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type sl_wfx_security_mode_bitmask_t = sl_wfx_security_mode_bitmask_s;
#[doc = " @brief Device TX rate set bitmask used in sl_wfx_set_tx_rate_parameters_req_body_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_rate_set_bitmask_s {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    #[doc = "< Reserved, set to zero"]
    pub unused2: u8,
}
#[test]
fn bindgen_test_layout_sl_wfx_rate_set_bitmask_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_rate_set_bitmask_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_rate_set_bitmask_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_rate_set_bitmask_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_rate_set_bitmask_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_rate_set_bitmask_s>())).unused2 as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_rate_set_bitmask_s),
            "::",
            stringify!(unused2)
        )
    );
}
impl sl_wfx_rate_set_bitmask_s {
    #[inline]
    pub fn b1Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_b1Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn b2Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_b2Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn b5P5Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_b5P5Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn b11Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_b11Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn g6Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_g6Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn g9Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_g9Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn g12Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_g12Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn g18Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_g18Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn g24Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_g24Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn g36Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_g36Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn g48Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_g48Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn g54Mbps(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_g54Mbps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mcs0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mcs1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mcs2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mcs3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mcs4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mcs5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mcs6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mcs7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        b1Mbps: u8,
        b2Mbps: u8,
        b5P5Mbps: u8,
        b11Mbps: u8,
        unused: u8,
        g6Mbps: u8,
        g9Mbps: u8,
        g12Mbps: u8,
        g18Mbps: u8,
        g24Mbps: u8,
        g36Mbps: u8,
        g48Mbps: u8,
        g54Mbps: u8,
        mcs0: u8,
        mcs1: u8,
        mcs2: u8,
        mcs3: u8,
        mcs4: u8,
        mcs5: u8,
        mcs6: u8,
        mcs7: u8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let b1Mbps: u8 = unsafe { ::core::mem::transmute(b1Mbps) };
            b1Mbps as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let b2Mbps: u8 = unsafe { ::core::mem::transmute(b2Mbps) };
            b2Mbps as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let b5P5Mbps: u8 = unsafe { ::core::mem::transmute(b5P5Mbps) };
            b5P5Mbps as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let b11Mbps: u8 = unsafe { ::core::mem::transmute(b11Mbps) };
            b11Mbps as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let unused: u8 = unsafe { ::core::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let g6Mbps: u8 = unsafe { ::core::mem::transmute(g6Mbps) };
            g6Mbps as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let g9Mbps: u8 = unsafe { ::core::mem::transmute(g9Mbps) };
            g9Mbps as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let g12Mbps: u8 = unsafe { ::core::mem::transmute(g12Mbps) };
            g12Mbps as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let g18Mbps: u8 = unsafe { ::core::mem::transmute(g18Mbps) };
            g18Mbps as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let g24Mbps: u8 = unsafe { ::core::mem::transmute(g24Mbps) };
            g24Mbps as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let g36Mbps: u8 = unsafe { ::core::mem::transmute(g36Mbps) };
            g36Mbps as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let g48Mbps: u8 = unsafe { ::core::mem::transmute(g48Mbps) };
            g48Mbps as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let g54Mbps: u8 = unsafe { ::core::mem::transmute(g54Mbps) };
            g54Mbps as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let mcs0: u8 = unsafe { ::core::mem::transmute(mcs0) };
            mcs0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let mcs1: u8 = unsafe { ::core::mem::transmute(mcs1) };
            mcs1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let mcs2: u8 = unsafe { ::core::mem::transmute(mcs2) };
            mcs2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let mcs3: u8 = unsafe { ::core::mem::transmute(mcs3) };
            mcs3 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let mcs4: u8 = unsafe { ::core::mem::transmute(mcs4) };
            mcs4 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let mcs5: u8 = unsafe { ::core::mem::transmute(mcs5) };
            mcs5 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let mcs6: u8 = unsafe { ::core::mem::transmute(mcs6) };
            mcs6 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let mcs7: u8 = unsafe { ::core::mem::transmute(mcs7) };
            mcs7 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type sl_wfx_rate_set_bitmask_t = sl_wfx_rate_set_bitmask_s;
#[doc = " @brief NS IP address element."]
#[doc = " @details Note that the IP element must always contain SL_WFX_IPV6_ADDR_SIZE bytes."]
#[doc = "          Only the bytes up to SsidLength are considered to be valid, the rest should be set to zero."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_ns_ip_addr_s {
    #[doc = " NS IP address."]
    pub ipv6_addr: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_ns_ip_addr_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ns_ip_addr_s>(),
        16usize,
        concat!("Size of: ", stringify!(sl_wfx_ns_ip_addr_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ns_ip_addr_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_ns_ip_addr_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_ns_ip_addr_s>())).ipv6_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ns_ip_addr_s),
            "::",
            stringify!(ipv6_addr)
        )
    );
}
pub type sl_wfx_ns_ip_addr_t = sl_wfx_ns_ip_addr_s;
#[doc = " @brief Request message body for sl_wfx_set_mac_address_req_t."]
#[doc = " @details"]
#[doc = "          | Field       | Default value    | Reset to default value |"]
#[doc = "          |:------------|:-----------------|:-----------------------|"]
#[doc = "          | MAC address | device dependent | when device reset      |"]
#[doc = "          <BR>"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_mac_address_req_body_s {
    #[doc = " MAC address of the interface."]
    pub mac_addr: [u8; 6usize],
    #[doc = " Reserved, set to zero."]
    pub reserved: u16,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_mac_address_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_mac_address_req_body_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_mac_address_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_mac_address_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_mac_address_req_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_mac_address_req_body_s>())).mac_addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_mac_address_req_body_s),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_mac_address_req_body_s>())).reserved as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_mac_address_req_body_s),
            "::",
            stringify!(reserved)
        )
    );
}
pub type sl_wfx_set_mac_address_req_body_t = sl_wfx_set_mac_address_req_body_s;
#[doc = " @brief Request message to set MAC address of the interface."]
#[doc = " @details The host can use this request to set the MAC address of an interface."]
#[doc = "          If not set, the device will use a built-in MAC address. Note that"]
#[doc = "          if multiple interfaces are used, the MAC address MUST be different"]
#[doc = "          on each interface."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | Yes             |"]
#[doc = "          | station        | No              |"]
#[doc = "          | AP             | No              |"]
#[doc = "          | IBSS           | No              |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_mac_address_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_set_mac_address_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_mac_address_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_mac_address_req_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_set_mac_address_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_mac_address_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_mac_address_req_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_mac_address_req_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_mac_address_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_mac_address_req_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_mac_address_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_mac_address_req_t = sl_wfx_set_mac_address_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_mac_address_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_mac_address_cnf_body_s {
    #[doc = " @brief Status of the set request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the set request was completed successfully."]
    #[doc = "          <BR><B>any other value</B>: the set request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_mac_address_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_mac_address_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_set_mac_address_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_mac_address_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_mac_address_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_mac_address_cnf_body_s>())).status as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_mac_address_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_set_mac_address_cnf_body_t = sl_wfx_set_mac_address_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_mac_address_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_mac_address_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_set_mac_address_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_mac_address_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_mac_address_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_mac_address_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_mac_address_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_mac_address_cnf_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_mac_address_cnf_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_mac_address_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_mac_address_cnf_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_mac_address_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_mac_address_cnf_t = sl_wfx_set_mac_address_cnf_s;
#[doc = " @brief Request message body for sl_wfx_connect_req_t."]
#[repr(C, packed)]
pub struct sl_wfx_connect_req_body_s {
    #[doc = " @brief Service Set Identifier (SSID) of the network."]
    pub ssid_def: sl_wfx_ssid_def_t,
    #[doc = " @brief Basic Service Set Identifier (BSSID) of the Access Point."]
    #[doc = " @details <B>broadcast address</B>: The device will connect to any matching access point."]
    #[doc = "          <BR><B>unicast address</B>: The device will only connect to the given Access Point."]
    #[doc = "          <BR>See @ref WFM_CONCEPT_BSSID for further details."]
    pub bssid: [u8; 6usize],
    #[doc = " @brief Channel of the Access Point."]
    #[doc = " @details <B>0</B>: The device will connect to a matching Access Point on any channel."]
    #[doc = "          <BR><B>1 - 13</B>: The device will only connect to a matching Access Point on the given channel."]
    pub channel: u16,
    #[doc = " @brief Security mode of the network."]
    #[doc = " @details <B>WFM_SECURITY_MODE_OPEN</B>: The device will only connect to an unsecured Access Point."]
    #[doc = "          <BR><B>WFM_SECURITY_MODE_WEP</B>: The device will only connect to a WEP Access Point."]
    #[doc = "          <BR><B>WFM_SECURITY_MODE_WPA2_WPA1_PSK</B>: The device will only connect to a WPA-Personal or a WPA2-Personal Access Point."]
    #[doc = "          <BR><B>WFM_SECURITY_MODE_WPA2_PSK</B>: The device will only connect to a WPA2-Personal access point."]
    #[doc = "          <BR>See wfm_security_mode for enumeration values."]
    pub security_mode: u8,
    #[doc = " @brief Boolean option to prevent roaming between access points."]
    #[doc = " @details <B>0</B>: The device may roam to any matching access point within the same network."]
    #[doc = "          <BR><B>1</B>: The device will not roam to any other access point."]
    pub prevent_roaming: u8,
    #[doc = " @brief Protected Management Frames (PMF) mode."]
    #[doc = " @details <B>WFM_MGMT_FRAME_PROTECTION_DISABLED</B>: The device will not use PMF even if supported by the access point."]
    #[doc = "          <BR><B>WFM_MGMT_FRAME_PROTECTION_OPTIONAL</B>: The device will use PMF if supported by the access point."]
    #[doc = "          <BR><B>WFM_MGMT_FRAME_PROTECTION_MANDATORY</B>: The device will only connect to an access point supporting PMF."]
    #[doc = "          <BR>See wfm_mgmt_frame_protection for enumeration values."]
    pub mgmt_frame_protection: u16,
    #[doc = " @brief Length of the network password."]
    #[doc = " @details <B>0 - 64</B>: The amount of bytes."]
    pub password_length: u16,
    #[doc = " @brief Password of the network."]
    #[doc = " @details <B>64-bit WEP key</B>: 5 bytes in ASCII format or 10 bytes in HEX format."]
    #[doc = "          <BR><B>128-bit WEP key</B>: 13 bytes in ASCII format or 26 bytes in HEX format."]
    #[doc = "          <BR><B>WPA pass phrase</B>: 8 - 63 bytes in ASCII format."]
    #[doc = "          <BR><B>WPA PMK</B>: 64 bytes in HEX format."]
    #[doc = "          <BR>See @ref WFM_CONCEPT_PASSWORD for further details."]
    pub password: [u8; 64usize],
    #[doc = " @brief Length of vendor-specific Information Element (IE) data."]
    #[doc = " @details <B>0 - 255</B>: The amount of bytes."]
    pub ie_data_length: u16,
    #[doc = " @brief Vendor-specific IE data added to the 802.11 Association Request frames."]
    #[doc = " @details The IE data must be in 802.11 Vendor-Specific Element format."]
    #[doc = "          It may contain multiple concatenated IEs, up to the maximum length."]
    #[doc = "          <BR>See @ref WFM_CONCEPT_VENDOR_IE for further details."]
    pub ie_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_connect_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_connect_req_body_s>(),
        116usize,
        concat!("Size of: ", stringify!(sl_wfx_connect_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_connect_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_connect_req_body_s))
    );
}
pub type sl_wfx_connect_req_body_t = sl_wfx_connect_req_body_s;
#[doc = " @brief Request message for connecting to a Wi-Fi network."]
#[doc = " @details The host can use this request to initiate a connection to a Wi-Fi network."]
#[doc = "          An ongoing connection attempt can be canceled by sending sl_wfx_disconnect_req_t"]
#[doc = "          message. Completion of the connection request will be signaled by sl_wfx_connect_ind_t"]
#[doc = "          message. It may take up to 10 seconds to receive the message."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | Yes             |"]
#[doc = "          | station        | No              |"]
#[doc = "          | AP             | No              |"]
#[doc = "          | IBSS           | No              |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[repr(C, packed)]
pub struct sl_wfx_connect_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_connect_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_connect_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_connect_req_s>(),
        120usize,
        concat!("Size of: ", stringify!(sl_wfx_connect_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_connect_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_connect_req_s))
    );
}
pub type sl_wfx_connect_req_t = sl_wfx_connect_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_connect_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_connect_cnf_body_s {
    #[doc = " @brief Status of the connection request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the connection request was accepted. It will be completed by sl_wfx_connect_ind_t."]
    #[doc = "          <BR><B>any other value</B>: the connection request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_connect_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_connect_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_connect_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_connect_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_connect_cnf_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_connect_cnf_body_s>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_connect_cnf_body_t = sl_wfx_connect_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_connect_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_connect_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_connect_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_connect_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_connect_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_connect_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_connect_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_connect_cnf_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_connect_cnf_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_connect_cnf_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_connect_cnf_t = sl_wfx_connect_cnf_s;
#[doc = " @brief Indication message body for sl_wfx_connect_ind_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_connect_ind_body_s {
    #[doc = " @brief Status of the connection request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the connection request was completed successfully."]
    #[doc = "          <BR><B>any other value</B>: the connection request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
    #[doc = " @brief MAC address of the connected access point."]
    pub mac: [u8; 6usize],
    #[doc = " @brief Channel of the connected access point."]
    #[doc = " @details <B>1 - 13</B>: Channel number."]
    pub channel: u16,
    #[doc = " @brief Beacon Interval of the connected access point."]
    pub beacon_interval: u8,
    #[doc = " @brief DTIM period of the connected access point."]
    #[doc = " @details <B>1 - 255</B>: DTIM period."]
    pub dtim_period: u8,
    #[doc = " @brief Maximum PHY data rate supported by the connection."]
    #[doc = " @details See sl_wfx_rate_index_t for enumeration values."]
    pub max_phy_rate: u16,
}
#[test]
fn bindgen_test_layout_sl_wfx_connect_ind_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_connect_ind_body_s>(),
        16usize,
        concat!("Size of: ", stringify!(sl_wfx_connect_ind_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_connect_ind_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_connect_ind_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_connect_ind_body_s>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_ind_body_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_connect_ind_body_s>())).mac as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_ind_body_s),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_connect_ind_body_s>())).channel as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_ind_body_s),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_connect_ind_body_s>())).beacon_interval as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_ind_body_s),
            "::",
            stringify!(beacon_interval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_connect_ind_body_s>())).dtim_period as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_ind_body_s),
            "::",
            stringify!(dtim_period)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_connect_ind_body_s>())).max_phy_rate as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_ind_body_s),
            "::",
            stringify!(max_phy_rate)
        )
    );
}
pub type sl_wfx_connect_ind_body_t = sl_wfx_connect_ind_body_s;
#[doc = " @brief Indication message used to signal the completion of a connection operation."]
#[doc = " @details The device will send this indication to signal the connection request initiated"]
#[doc = "          with sl_wfx_connect_req_t has been completed. The indication is also sent when"]
#[doc = "          the device autonomously roams to another access point."]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_connect_ind_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Indication message body."]
    pub body: sl_wfx_connect_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_connect_ind_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_connect_ind_s>(),
        20usize,
        concat!("Size of: ", stringify!(sl_wfx_connect_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_connect_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_connect_ind_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_connect_ind_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_connect_ind_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_connect_ind_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_connect_ind_t = sl_wfx_connect_ind_s;
#[doc = " @struct sl_wfx_disconnect_req_t"]
#[doc = " @brief Request message for disconnecting from a Wi-Fi network."]
#[doc = " @details The host can use this request to initiate a disconnection from a Wi-Fi network."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | No              |"]
#[doc = "          | station        | Yes             |"]
#[doc = "          | AP             | No              |"]
#[doc = "          | IBSS           | No              |"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_disconnect_req_t = sl_wfx_header_t;
#[doc = " @brief Confirmation message body for sl_wfx_disconnect_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_disconnect_cnf_body_s {
    #[doc = " @brief Status of the disconnection request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the disconnection request was accepted. It will be completed by sl_wfx_disconnect_ind_t."]
    #[doc = "          <BR><B>any other value</B>: the disconnection request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_disconnect_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_disconnect_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_disconnect_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_disconnect_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_disconnect_cnf_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_disconnect_cnf_body_s>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_disconnect_cnf_body_t = sl_wfx_disconnect_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_disconnect_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_disconnect_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_disconnect_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_disconnect_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_disconnect_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_disconnect_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_disconnect_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_disconnect_cnf_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_disconnect_cnf_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_disconnect_cnf_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_disconnect_cnf_t = sl_wfx_disconnect_cnf_s;
#[doc = " @brief Indication message body for sl_wfx_disconnect_ind_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_disconnect_ind_body_s {
    #[doc = " @brief MAC address of the access point."]
    pub mac: [u8; 6usize],
    #[doc = " @brief Reason for disconnection."]
    #[doc = " @details <B>WFM_REASON_UNSPECIFIED</B>: The device was disconnected or it disconnected on its own."]
    #[doc = "          <BR>See wfm_reason for enumeration values."]
    pub reason: u16,
}
#[test]
fn bindgen_test_layout_sl_wfx_disconnect_ind_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_disconnect_ind_body_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_disconnect_ind_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_disconnect_ind_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_disconnect_ind_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_disconnect_ind_body_s>())).mac as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_ind_body_s),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_disconnect_ind_body_s>())).reason as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_ind_body_s),
            "::",
            stringify!(reason)
        )
    );
}
pub type sl_wfx_disconnect_ind_body_t = sl_wfx_disconnect_ind_body_s;
#[doc = " @brief Indication message used to signal the completion of a disconnection operation."]
#[doc = " @details The device will send this indication to signal the disconnection request initiated"]
#[doc = "          with sl_wfx_disconnect_req_t has been completed. The indication is also sent when"]
#[doc = "          the device has lost the connection to an access point and has been unable to regain it."]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_disconnect_ind_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Indication message body."]
    pub body: sl_wfx_disconnect_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_disconnect_ind_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_disconnect_ind_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_disconnect_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_disconnect_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_disconnect_ind_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_disconnect_ind_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_disconnect_ind_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_ind_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_disconnect_ind_t = sl_wfx_disconnect_ind_s;
#[doc = " @struct sl_wfx_get_signal_strength_req_t"]
#[doc = " @brief Request message for retrieving the signal strength of connection."]
#[doc = " @details The host can use this request to retrieve the signal strength of the connection."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | No              |"]
#[doc = "          | station        | Yes             |"]
#[doc = "          | AP             | No              |"]
#[doc = "          | IBSS           | No              |"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_get_signal_strength_req_t = sl_wfx_header_t;
#[doc = " @brief Confirmation message body for sl_wfx_get_signal_strength_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_get_signal_strength_cnf_body_s {
    #[doc = " @brief Status of the get request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the get request was completed."]
    #[doc = "          <BR><B>any other value</B>: the get request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
    #[doc = " @brief Received Channel Power Indicator (RCPI) of the connection."]
    #[doc = " @details See @ref WFM_CONCEPT_RCPI for further details."]
    pub rcpi: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_get_signal_strength_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_get_signal_strength_cnf_body_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_get_signal_strength_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_get_signal_strength_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_get_signal_strength_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_get_signal_strength_cnf_body_s>())).status as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_signal_strength_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_get_signal_strength_cnf_body_s>())).rcpi as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_signal_strength_cnf_body_s),
            "::",
            stringify!(rcpi)
        )
    );
}
pub type sl_wfx_get_signal_strength_cnf_body_t = sl_wfx_get_signal_strength_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_get_signal_strength_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_get_signal_strength_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_get_signal_strength_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_get_signal_strength_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_get_signal_strength_cnf_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_get_signal_strength_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_get_signal_strength_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_get_signal_strength_cnf_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_get_signal_strength_cnf_s>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_signal_strength_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_get_signal_strength_cnf_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_signal_strength_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_get_signal_strength_cnf_t = sl_wfx_get_signal_strength_cnf_s;
#[doc = " @brief Request message body for sl_wfx_set_pm_mode_req_t."]
#[doc = " @details"]
#[doc = "          | Field          | Default value      | Reset to default value |"]
#[doc = "          |:---------------|:-------------------|:-----------------------|"]
#[doc = "          | power_mode      | WFM_PM_MODE_ACTIVE | when interface stopped |"]
#[doc = "          | listen_interval | 0                  | when interface stopped |"]
#[doc = "          <BR>"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_pm_mode_req_body_s {
    #[doc = " @brief Power management mode."]
    #[doc = " @details <B>WFM_PM_MODE_ACTIVE</B>: the device will not use Wi-Fi power management mechanisms."]
    #[doc = "          <BR><B>WFM_PM_MODE_BEACON</B>: the device will wake-up on beacons."]
    #[doc = "          <BR><B>WFM_PM_MODE_DTIM</B>: the device will wake-up on DTIMs."]
    #[doc = "          <BR>See wfm_pm_mode for enumeration values."]
    pub power_mode: u16,
    #[doc = " @brief Number of beacons/DTIMs to skip while sleeping."]
    #[doc = " @details <B>0</B>: wake-up on every beacon/DTIM."]
    #[doc = "          <BR><B>1 - 600</B>: the number of beacon/DTIMs to skip."]
    #[doc = "          <BR>See @ref WFM_CONCEPT_PM for further details."]
    pub listen_interval: u16,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_pm_mode_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_pm_mode_req_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_set_pm_mode_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_pm_mode_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_pm_mode_req_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_pm_mode_req_body_s>())).power_mode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_pm_mode_req_body_s),
            "::",
            stringify!(power_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_pm_mode_req_body_s>())).listen_interval as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_pm_mode_req_body_s),
            "::",
            stringify!(listen_interval)
        )
    );
}
pub type sl_wfx_set_pm_mode_req_body_t = sl_wfx_set_pm_mode_req_body_s;
#[doc = " @brief Request message for setting the power management mode of the device."]
#[doc = " @details The host can use this request to enable or disable Wi-Fi power management mechanisms."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | No              |"]
#[doc = "          | station        | Yes             |"]
#[doc = "          | AP             | No              |"]
#[doc = "          | IBSS           | No              |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_pm_mode_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_set_pm_mode_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_pm_mode_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_pm_mode_req_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_pm_mode_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_pm_mode_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_pm_mode_req_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_pm_mode_req_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_pm_mode_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_set_pm_mode_req_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_pm_mode_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_pm_mode_req_t = sl_wfx_set_pm_mode_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_pm_mode_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_pm_mode_cnf_body_s {
    #[doc = " @brief Status of the power management request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the power management request was completed."]
    #[doc = "          <BR><B>any other value</B>: the power management request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_pm_mode_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_pm_mode_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_set_pm_mode_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_pm_mode_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_pm_mode_cnf_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_pm_mode_cnf_body_s>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_pm_mode_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_set_pm_mode_cnf_body_t = sl_wfx_set_pm_mode_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_pm_mode_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_pm_mode_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_set_pm_mode_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_pm_mode_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_pm_mode_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_pm_mode_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_pm_mode_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_pm_mode_cnf_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_pm_mode_cnf_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_pm_mode_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_set_pm_mode_cnf_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_pm_mode_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_pm_mode_cnf_t = sl_wfx_set_pm_mode_cnf_s;
#[doc = " @brief Request message body for sl_wfx_start_ap_req_t."]
#[repr(C, packed)]
pub struct sl_wfx_start_ap_req_body_s {
    #[doc = " @brief Service Set Identifier (SSID) of the network."]
    pub ssid_def: sl_wfx_ssid_def_t,
    #[doc = " @brief Boolean option to hide the network."]
    #[doc = " @details <B>0</B>: The device will advertise the SSID of the network to any near-by stations."]
    #[doc = "          <BR><B>1</B>: The device will hide the SSID of the network and will only respond"]
    #[doc = "                        to stations that specify the SSID."]
    #[doc = "          <BR>See @ref WFM_CONCEPT_HIDDEN for further details."]
    pub hidden_ssid: u8,
    #[doc = " @brief Boolean option to isolate connected clients from each other."]
    #[doc = " @details <B>0</B>: The device will allow connected clients to communicate with each other."]
    #[doc = "          <BR><B>1</B>: The device will prevent multiple connected clients from communicating."]
    #[doc = "          <BR>Regardless of the value, the connected stations will always be able to communicate with the device."]
    #[doc = "          <BR>See @ref WFM_CONCEPT_ISOLATION for further details."]
    pub client_isolation: u8,
    #[doc = " @brief Security mode of the Access Point."]
    #[doc = " @details <B>WFM_SECURITY_MODE_OPEN</B>: The device will only allow unsecured connections."]
    #[doc = "          <BR><B>WFM_SECURITY_MODE_WEP</B>: The device will only allow WEP connections."]
    #[doc = "          <BR><B>WFM_SECURITY_MODE_WPA2_WPA1_PSK</B>: The device will only allow WPA-Personal and WPA2-Personal connections."]
    #[doc = "          <BR><B>WFM_SECURITY_MODE_WPA2_PSK</B>: The device will only allow WPA2-Personal connections."]
    #[doc = "          <BR>See wfm_security_mode for enumeration values."]
    pub security_mode: u8,
    #[doc = " @brief Protected Management Frames (PMF) mode."]
    #[doc = " @details <B>WFM_MGMT_FRAME_PROTECTION_DISABLED</B>: The device will not use PMF even if supported by the connecting station."]
    #[doc = "          <BR><B>WFM_MGMT_FRAME_PROTECTION_OPTIONAL</B>: The device will use PMF if supported by the connecting station."]
    #[doc = "          <BR><B>WFM_MGMT_FRAME_PROTECTION_MANDATORY</B>: The device will only allow connecting stations that support PMF."]
    #[doc = "          <BR>See wfm_mgmt_frame_protection for enumeration values."]
    pub mgmt_frame_protection: u8,
    #[doc = " @brief Channel of the Access Point."]
    #[doc = " @details <B>1 - 13</B>: The device will create the access point on the given channel."]
    pub channel: u16,
    #[doc = " @brief Length of the network password."]
    #[doc = " @details <B>0 - 64</B>: The amount of bytes."]
    pub password_length: u16,
    #[doc = " @brief Password of the network."]
    #[doc = " @details <B>64-bit WEP key</B>: 5 bytes in ASCII format or 10 bytes in HEX format."]
    #[doc = "          <BR><B>128-bit WEP key</B>: 13 bytes in ASCII format or 26 bytes in HEX format."]
    #[doc = "          <BR><B>WPA pass phrase</B>: 8 - 63 bytes in ASCII format."]
    #[doc = "          <BR><B>WPA PMK</B>: 64 bytes in HEX format."]
    #[doc = "          <BR>See @ref WFM_CONCEPT_PASSWORD for further details."]
    pub password: [u8; 64usize],
    #[doc = " @brief Length of vendor-specific Information Element (IE) data in 802.11 Beacon frames."]
    #[doc = " @details <B>0 - 255</B>: The amount of bytes."]
    pub beacon_ie_data_length: u16,
    #[doc = " @brief Length of vendor-specific Information Element (IE) data in 802.11 Probe Response frames."]
    #[doc = " @details <B>0 - 255</B>: The amount of bytes."]
    pub probe_resp_ie_data_length: u16,
    #[doc = " @brief Vendor-specific IE data added to the 802.11 Beacon frames and Probe Response frames."]
    #[doc = " @details The IE data must be in 802.11 Vendor-Specific Element format. It may contain"]
    #[doc = "          multiple concatenated IEs, up to the maximum length. First part of the IE data,"]
    #[doc = "          up to the amount of bytes specified in BeaconIeDataLength, is added to the Beacon"]
    #[doc = "          frames. The remaining part whose length is defined in ProbeRespIeDataLength is added"]
    #[doc = "          to the Probe Response frames."]
    #[doc = "          <BR>See @ref WFM_CONCEPT_VENDOR_IE for further details."]
    pub ie_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_start_ap_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_start_ap_req_body_s>(),
        112usize,
        concat!("Size of: ", stringify!(sl_wfx_start_ap_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_start_ap_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_start_ap_req_body_s))
    );
}
pub type sl_wfx_start_ap_req_body_t = sl_wfx_start_ap_req_body_s;
#[doc = " @brief Request message for starting a Wi-Fi network."]
#[doc = " @details The host can use this request to initiate a Wi-Fi network."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | Yes             |"]
#[doc = "          | station        | No              |"]
#[doc = "          | AP             | No              |"]
#[doc = "          | IBSS           | No              |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[repr(C, packed)]
pub struct sl_wfx_start_ap_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_start_ap_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_start_ap_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_start_ap_req_s>(),
        116usize,
        concat!("Size of: ", stringify!(sl_wfx_start_ap_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_start_ap_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_start_ap_req_s))
    );
}
pub type sl_wfx_start_ap_req_t = sl_wfx_start_ap_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_start_ap_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_start_ap_cnf_body_s {
    #[doc = " @brief Status of the start request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the start request was accepted. It will be completed by sl_wfx_start_ap_ind_t."]
    #[doc = "          <BR><B>any other value</B>: the start request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_start_ap_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_start_ap_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_start_ap_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_start_ap_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_start_ap_cnf_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_start_ap_cnf_body_s>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_start_ap_cnf_body_t = sl_wfx_start_ap_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_start_ap_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_start_ap_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_start_ap_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_start_ap_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_start_ap_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_start_ap_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_start_ap_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_start_ap_cnf_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_start_ap_cnf_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_start_ap_cnf_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_start_ap_cnf_t = sl_wfx_start_ap_cnf_s;
#[doc = " @brief Indication message body for sl_wfx_start_ap_ind_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_start_ap_ind_body_s {
    #[doc = " @brief Status of the start request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the start request was completed successfully."]
    #[doc = "          <BR><B>any other value</B>: the start request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_start_ap_ind_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_start_ap_ind_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_start_ap_ind_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_start_ap_ind_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_start_ap_ind_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_start_ap_ind_body_s>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_ind_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_start_ap_ind_body_t = sl_wfx_start_ap_ind_body_s;
#[doc = " @brief Indication message used to signal the completion of a start request."]
#[doc = " @details The device will send this indication to signal the start request initiated"]
#[doc = "          with sl_wfx_start_ap_req_t has been completed."]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_start_ap_ind_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Indication message body."]
    pub body: sl_wfx_start_ap_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_start_ap_ind_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_start_ap_ind_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_start_ap_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_start_ap_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_start_ap_ind_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_start_ap_ind_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_start_ap_ind_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_ap_ind_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_start_ap_ind_t = sl_wfx_start_ap_ind_s;
#[doc = " @brief Request message body for sl_wfx_update_ap_req_t."]
#[repr(C, packed)]
pub struct sl_wfx_update_ap_req_body_s {
    #[doc = " @brief Length of vendor-specific Information Element (IE) data in 802.11 Beacon frames."]
    #[doc = " @details <B>0 - 255</B>: The amount of bytes."]
    pub beacon_ie_data_length: u16,
    #[doc = " @brief Length of vendor-specific Information Element (IE) data in 802.11 Probe Response frames."]
    #[doc = " @details <B>0 - 255</B>: The amount of bytes."]
    pub probe_resp_ie_data_length: u16,
    #[doc = " @brief Vendor-specific IE data added to the 802.11 Beacon frames and Probe Response frames."]
    #[doc = " @details The IE data must be in 802.11 Vendor-Specific Element format. It may contain"]
    #[doc = "          multiple concatenated IEs, up to the maximum length. First part of the IE data,"]
    #[doc = "          up to the amount of bytes specified in BeaconIeDataLength, is added to the Beacon"]
    #[doc = "          frames. The remaining part whose length is defined in ProbeRespIeDataLength is added"]
    #[doc = "          to the Probe Response frames."]
    #[doc = "          <BR>See @ref WFM_CONCEPT_VENDOR_IE for further details."]
    pub ie_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_update_ap_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_update_ap_req_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_update_ap_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_update_ap_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_update_ap_req_body_s))
    );
}
pub type sl_wfx_update_ap_req_body_t = sl_wfx_update_ap_req_body_s;
#[doc = " @brief Request message for updating parameters of the started Wi-Fi network."]
#[doc = " @details The host can use this request to update parameters of the started Wi-Fi network."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | No              |"]
#[doc = "          | station        | No              |"]
#[doc = "          | AP             | Yes             |"]
#[doc = "          | IBSS           | No              |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
pub struct sl_wfx_update_ap_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_update_ap_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_update_ap_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_update_ap_req_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_update_ap_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_update_ap_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_update_ap_req_s))
    );
}
pub type sl_wfx_update_ap_req_t = sl_wfx_update_ap_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_update_ap_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_update_ap_cnf_body_s {
    #[doc = " @brief Status of the update request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the update request was completed."]
    #[doc = "          <BR><B>any other value</B>: the update request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_update_ap_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_update_ap_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_update_ap_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_update_ap_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_update_ap_cnf_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_update_ap_cnf_body_s>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_update_ap_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_update_ap_cnf_body_t = sl_wfx_update_ap_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_update_ap_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_update_ap_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_update_ap_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_update_ap_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_update_ap_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_update_ap_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_update_ap_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_update_ap_cnf_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_update_ap_cnf_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_update_ap_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_update_ap_cnf_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_update_ap_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_update_ap_cnf_t = sl_wfx_update_ap_cnf_s;
#[doc = " @struct sl_wfx_stop_ap_req_t"]
#[doc = " @brief Request message for stopping the started Wi-Fi network."]
#[doc = " @details The host can use this request to stop the started Wi-Fi network."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | No              |"]
#[doc = "          | station        | No              |"]
#[doc = "          | AP             | Yes             |"]
#[doc = "          | IBSS           | No              |"]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_stop_ap_req_t = sl_wfx_header_t;
#[doc = " @brief Confirmation message body for sl_wfx_stop_ap_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_stop_ap_cnf_body_s {
    #[doc = " @brief Status of the stop request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the stop request was accepted. It will be completed by sl_wfx_stop_ap_ind_t."]
    #[doc = "          <BR><B>any other value</B>: the stop request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_stop_ap_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_stop_ap_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_stop_ap_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_stop_ap_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_stop_ap_cnf_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_stop_ap_cnf_body_s>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_stop_ap_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_stop_ap_cnf_body_t = sl_wfx_stop_ap_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_stop_ap_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_stop_ap_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_stop_ap_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_stop_ap_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_stop_ap_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_stop_ap_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_stop_ap_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_stop_ap_cnf_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_stop_ap_cnf_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_stop_ap_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_stop_ap_cnf_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_stop_ap_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_stop_ap_cnf_t = sl_wfx_stop_ap_cnf_s;
#[doc = " @struct sl_wfx_stop_ap_ind_t"]
#[doc = " @brief Indication message used to signal the completion of a stop operation."]
#[doc = " @details The device will send this indication to signal the stop request initiated"]
#[doc = "          with sl_wfx_stop_ap_req_t has been completed. The indication is also sent when"]
#[doc = "          the started network has encountered a fatal error."]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_stop_ap_ind_t = sl_wfx_header_t;
#[doc = " @brief Indication message body for sl_wfx_ap_client_connected_ind_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_ap_client_connected_ind_body_s {
    #[doc = " @brief MAC address of the station."]
    pub mac: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_ap_client_connected_ind_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ap_client_connected_ind_body_s>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_ap_client_connected_ind_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ap_client_connected_ind_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_ap_client_connected_ind_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_ap_client_connected_ind_body_s>())).mac as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_client_connected_ind_body_s),
            "::",
            stringify!(mac)
        )
    );
}
pub type sl_wfx_ap_client_connected_ind_body_t = sl_wfx_ap_client_connected_ind_body_s;
#[doc = " @brief Indication message used to signal a connected station."]
#[doc = " @details The device will send this indication to signal a station has connected"]
#[doc = "          to the started network."]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_ap_client_connected_ind_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Indication message body."]
    pub body: sl_wfx_ap_client_connected_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_ap_client_connected_ind_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ap_client_connected_ind_s>(),
        10usize,
        concat!("Size of: ", stringify!(sl_wfx_ap_client_connected_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ap_client_connected_ind_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_ap_client_connected_ind_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_ap_client_connected_ind_s>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_client_connected_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_ap_client_connected_ind_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_client_connected_ind_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_ap_client_connected_ind_t = sl_wfx_ap_client_connected_ind_s;
#[doc = " @brief Indication message body for sl_wfx_ap_client_rejected_ind_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_ap_client_rejected_ind_body_s {
    #[doc = " @brief MAC address of the station."]
    pub mac: [u8; 6usize],
    #[doc = " @brief Reason for rejection."]
    #[doc = " @details <B>WFM_REASON_TIMEOUT</B>: A timeout occurred during a station connection attempt."]
    #[doc = "          <BR><B>WFM_REASON_LEAVING_BSS</B>: The device sent a deauth before completing the connection."]
    #[doc = "          <BR><B>WFM_REASON_UNKNOWN_STA</B>: The device received data from a non-connected station."]
    #[doc = "          <BR><B>WFM_REASON_AP_FULL</B>: The device was not able to accommodate any more stations."]
    #[doc = "          <BR><B>WFM_REASON_AUTHENTICATION_FAILURE</B>: The device did not complete the WPA authentication successfully."]
    #[doc = "          <BR>See wfm_reason for enumeration values."]
    pub reason: u16,
}
#[test]
fn bindgen_test_layout_sl_wfx_ap_client_rejected_ind_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ap_client_rejected_ind_body_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_ap_client_rejected_ind_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ap_client_rejected_ind_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_ap_client_rejected_ind_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_ap_client_rejected_ind_body_s>())).mac as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_client_rejected_ind_body_s),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_ap_client_rejected_ind_body_s>())).reason as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_client_rejected_ind_body_s),
            "::",
            stringify!(reason)
        )
    );
}
pub type sl_wfx_ap_client_rejected_ind_body_t = sl_wfx_ap_client_rejected_ind_body_s;
#[doc = " @brief Indication message used to signal a rejected connection attempt from a station."]
#[doc = " @details The device will send this indication to signal a station has attempted"]
#[doc = "          connection to the started network and was rejected by the device."]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_ap_client_rejected_ind_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Indication message body."]
    pub body: sl_wfx_ap_client_rejected_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_ap_client_rejected_ind_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ap_client_rejected_ind_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_ap_client_rejected_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ap_client_rejected_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_ap_client_rejected_ind_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_ap_client_rejected_ind_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_client_rejected_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_ap_client_rejected_ind_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_client_rejected_ind_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_ap_client_rejected_ind_t = sl_wfx_ap_client_rejected_ind_s;
#[doc = " @brief Request message body for sl_wfx_disconnect_ap_client_req_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_disconnect_ap_client_req_body_s {
    #[doc = " @brief MAC address of the station."]
    pub mac: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_disconnect_ap_client_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_disconnect_ap_client_req_body_s>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_disconnect_ap_client_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_disconnect_ap_client_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_disconnect_ap_client_req_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_disconnect_ap_client_req_body_s>())).mac as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_ap_client_req_body_s),
            "::",
            stringify!(mac)
        )
    );
}
pub type sl_wfx_disconnect_ap_client_req_body_t = sl_wfx_disconnect_ap_client_req_body_s;
#[doc = " @brief Request message for disconnecting a client from the started Wi-Fi network."]
#[doc = " @details The host can use this request to disconnect a client from the started Wi-Fi network."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | No              |"]
#[doc = "          | station        | No              |"]
#[doc = "          | AP             | Yes             |"]
#[doc = "          | IBSS           | No              |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_disconnect_ap_client_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_disconnect_ap_client_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_disconnect_ap_client_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_disconnect_ap_client_req_s>(),
        10usize,
        concat!("Size of: ", stringify!(sl_wfx_disconnect_ap_client_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_disconnect_ap_client_req_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_disconnect_ap_client_req_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_disconnect_ap_client_req_s>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_ap_client_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_disconnect_ap_client_req_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_ap_client_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_disconnect_ap_client_req_t = sl_wfx_disconnect_ap_client_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_disconnect_ap_client_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_disconnect_ap_client_cnf_body_s {
    #[doc = " @brief Status of the disconnect request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the disconnect request was completed."]
    #[doc = "          <BR><B>any other value</B>: the disconnect request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_disconnect_ap_client_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_disconnect_ap_client_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_disconnect_ap_client_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_disconnect_ap_client_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_disconnect_ap_client_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_disconnect_ap_client_cnf_body_s>())).status as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_ap_client_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_disconnect_ap_client_cnf_body_t = sl_wfx_disconnect_ap_client_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_disconnect_ap_client_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_disconnect_ap_client_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_disconnect_ap_client_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_disconnect_ap_client_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_disconnect_ap_client_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_disconnect_ap_client_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_disconnect_ap_client_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_disconnect_ap_client_cnf_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_disconnect_ap_client_cnf_s>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_ap_client_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_disconnect_ap_client_cnf_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_disconnect_ap_client_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_disconnect_ap_client_cnf_t = sl_wfx_disconnect_ap_client_cnf_s;
#[doc = " @brief Indication message body for sl_wfx_ap_client_disconnected_ind_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_ap_client_disconnected_ind_body_s {
    #[doc = " @brief MAC address of the station."]
    pub mac: [u8; 6usize],
    #[doc = " @brief Reason for disconnection."]
    #[doc = " @details <B>WFM_REASON_LEAVING_BSS</B>: The station was disconnected or it disconnected on its own."]
    #[doc = "          <BR>See wfm_reason for enumeration values."]
    pub reason: u16,
}
#[test]
fn bindgen_test_layout_sl_wfx_ap_client_disconnected_ind_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ap_client_disconnected_ind_body_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_ap_client_disconnected_ind_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ap_client_disconnected_ind_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_ap_client_disconnected_ind_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_ap_client_disconnected_ind_body_s>())).mac as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_client_disconnected_ind_body_s),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_ap_client_disconnected_ind_body_s>())).reason as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_client_disconnected_ind_body_s),
            "::",
            stringify!(reason)
        )
    );
}
pub type sl_wfx_ap_client_disconnected_ind_body_t = sl_wfx_ap_client_disconnected_ind_body_s;
#[doc = " @brief Indication message used to signal a disconnected station."]
#[doc = " @details The device will send this indication to signal a station has left"]
#[doc = "          the started network."]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_ap_client_disconnected_ind_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Indication message body."]
    pub body: sl_wfx_ap_client_disconnected_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_ap_client_disconnected_ind_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_ap_client_disconnected_ind_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_ap_client_disconnected_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_ap_client_disconnected_ind_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_ap_client_disconnected_ind_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_ap_client_disconnected_ind_s>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_client_disconnected_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_ap_client_disconnected_ind_s>())).body as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_ap_client_disconnected_ind_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_ap_client_disconnected_ind_t = sl_wfx_ap_client_disconnected_ind_s;
#[doc = " @brief Request message body for sl_wfx_send_frame_req_t."]
#[repr(C, packed)]
pub struct sl_wfx_send_frame_req_body_s {
    #[doc = " @brief Packet type."]
    #[doc = " @details <B>0</B>: Data packet with Ethernet II frame header."]
    pub frame_type: u8,
    #[doc = " @brief User Priority level."]
    #[doc = " @details <B>0 - 7</B>: 802.1D Priority field value."]
    pub priority: u8,
    #[doc = " @brief Packet ID number."]
    #[doc = " @details <B>0 - 65535</B>: Host-assigned unique number for the packet."]
    #[doc = "          <BR>The number is returned in the corresponding confirmation message."]
    pub packet_id: u16,
    #[doc = " @brief Length of packet data."]
    #[doc = " @details <B>1 - 1604</B>: The amount of bytes."]
    pub packet_data_length: u32,
    #[doc = " @brief Data of the packet."]
    #[doc = " @details See @ref WFM_CONCEPT_PACKET for further details."]
    pub packet_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_send_frame_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_send_frame_req_body_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_send_frame_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_send_frame_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_send_frame_req_body_s))
    );
}
pub type sl_wfx_send_frame_req_body_t = sl_wfx_send_frame_req_body_s;
#[doc = " @brief Request message for sending a packet to the network."]
#[doc = " @details The host can use this request to send a packet to the network."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | No              |"]
#[doc = "          | station        | Yes             |"]
#[doc = "          | AP             | Yes             |"]
#[doc = "          | IBSS           | Yes             |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[doc = " @ingroup WFM_GROUP_MODE_IBSS"]
#[repr(C, packed)]
pub struct sl_wfx_send_frame_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_send_frame_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_send_frame_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_send_frame_req_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_send_frame_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_send_frame_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_send_frame_req_s))
    );
}
pub type sl_wfx_send_frame_req_t = sl_wfx_send_frame_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_send_frame_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_send_frame_cnf_body_s {
    #[doc = " @brief Status of the send request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the send request was completed."]
    #[doc = "          <BR><B>any other value</B>: the send request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
    #[doc = " @brief Packet ID number from the corresponding request."]
    pub packet_id: u16,
    #[doc = " @brief Reserved."]
    pub reserved: u16,
}
#[test]
fn bindgen_test_layout_sl_wfx_send_frame_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_send_frame_cnf_body_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_send_frame_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_send_frame_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_send_frame_cnf_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_send_frame_cnf_body_s>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_send_frame_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_send_frame_cnf_body_s>())).packet_id as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_send_frame_cnf_body_s),
            "::",
            stringify!(packet_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_send_frame_cnf_body_s>())).reserved as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_send_frame_cnf_body_s),
            "::",
            stringify!(reserved)
        )
    );
}
pub type sl_wfx_send_frame_cnf_body_t = sl_wfx_send_frame_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_send_frame_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[doc = " @ingroup WFM_GROUP_MODE_IBSS"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_send_frame_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_send_frame_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_send_frame_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_send_frame_cnf_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_send_frame_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_send_frame_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_send_frame_cnf_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_send_frame_cnf_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_send_frame_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_send_frame_cnf_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_send_frame_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_send_frame_cnf_t = sl_wfx_send_frame_cnf_s;
#[doc = " @brief Indication message body for sl_wfx_received_ind_t."]
#[repr(C, packed)]
pub struct sl_wfx_received_ind_body_s {
    #[doc = " @brief Packet type."]
    #[doc = " @details <B>0</B>: Data packet with Ethernet II frame header."]
    pub frame_type: u8,
    #[doc = " @brief The amount of padding bytes before the packet data."]
    #[doc = " @details <B>0 - 3</B>: The amount of bytes."]
    pub frame_padding: u8,
    #[doc = " @brief Length of packet data excluding the padding bytes."]
    #[doc = " @details <B>1 - 2310</B>: The amount of bytes."]
    pub frame_length: u16,
    #[doc = " @brief Packet data, including the padding bytes before the packet data."]
    #[doc = " @details See @ref WFM_CONCEPT_PACKET for further details."]
    pub frame: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_received_ind_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_received_ind_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_received_ind_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_received_ind_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_received_ind_body_s))
    );
}
pub type sl_wfx_received_ind_body_t = sl_wfx_received_ind_body_s;
#[doc = " @brief Indication message used to signal a received packet."]
#[doc = " @details The device will send this indication to signal a packet"]
#[doc = "          has been received."]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[doc = " @ingroup WFM_GROUP_MODE_IBSS"]
#[repr(C, packed)]
pub struct sl_wfx_received_ind_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Indication message body."]
    pub body: sl_wfx_received_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_received_ind_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_received_ind_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_received_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_received_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_received_ind_s))
    );
}
pub type sl_wfx_received_ind_t = sl_wfx_received_ind_s;
#[doc = " @brief Request message body for sl_wfx_start_scan_req_t."]
#[repr(C, packed)]
pub struct sl_wfx_start_scan_req_body_s {
    #[doc = " @brief Scan mode."]
    #[doc = " @details <B>WFM_SCAN_MODE_PASSIVE</B>: The device will perform a passive scan."]
    #[doc = "          <BR><B>WFM_SCAN_MODE_ACTIVE</B>: The device will perform an active scan."]
    #[doc = "          <BR>See wfm_scan_mode for enumeration values."]
    #[doc = "          <BR>See @ref WFM_CONCEPT_SCAN for further details."]
    pub scan_mode: u16,
    #[doc = " @brief The amount of specific channels to scan."]
    #[doc = " @details <B>0</B>: The device will scan all channels"]
    #[doc = "          <BR><B>1 - 13</B>: The amount of specific channels to scan."]
    pub channel_list_count: u16,
    #[doc = " @brief The amount of specific SSIDs to scan."]
    #[doc = " @details <B>0</B>: The device will perform a broadcast scan"]
    #[doc = "          <BR><B>1 - 2</B>: The amount of specific SSIDs to scan."]
    pub ssid_list_count: u16,
    #[doc = " @brief Length of vendor-specific Information Element (IE) data in 802.11 Probe Request frames."]
    #[doc = " @details <B>0 - 255</B>: The amount of bytes."]
    pub ie_data_length: u16,
    #[doc = " @brief Data for the variable-length scan parameters."]
    #[doc = " @details The variable-length scan parameters are concatenated together without any"]
    #[doc = "          padding between the different parameters."]
    #[doc = " @par 1. List of specific channels to scan."]
    #[doc = " @details <B>1 - 13</B>: The channel number to scan per byte."]
    #[doc = "          <BR>Must contain the same number of channels as specified in ChannelListCount."]
    #[doc = "          <BR>See @ref WFM_CONCEPT_SCAN for further details."]
    #[doc = " @par 2. List of specific SSIDs to scan."]
    #[doc = " @details Must contain the same number of WfmHiSsidDef_t elements as specified in SsidListCount."]
    #[doc = "          <BR>This parameter is applicable only for an active scan. See @ref WFM_CONCEPT_SCAN for further details."]
    #[doc = " @par 3. Vendor-specific IE data added to the 802.11 Probe Request frames."]
    #[doc = " @details The IE data must be in 802.11 Vendor-Specific Element format."]
    #[doc = "          It may contain multiple concatenated IEs, up to the maximum length."]
    #[doc = "          <BR>This parameter is applicable only for an active scan. See @ref WFM_CONCEPT_VENDOR_IE for further details."]
    #[doc = " @par 4. Basic Service Set Identifier (BSSID) to scan."]
    #[doc = " @details <B>broadcast address</B>: The device will send Probe Request frames to all devices."]
    #[doc = "          <BR><B>unicast address</B>: The device will send Probe Request frames to a specific device."]
    #[doc = "          <BR>This parameter is applicable only for an active scan. If not specified, broadcast address is assumed."]
    #[doc = "          <BR>Note that an SSID list must be specified when using the unicast address, otherwise the received"]
    #[doc = "          scan results may contain unexpected additional networks."]
    #[doc = "          <BR>See @ref WFM_CONCEPT_BSSID for further details."]
    pub data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_start_scan_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_start_scan_req_body_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_start_scan_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_start_scan_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_start_scan_req_body_s))
    );
}
pub type sl_wfx_start_scan_req_body_t = sl_wfx_start_scan_req_body_s;
#[doc = " @brief Request message for starting a scan to detect near-by access points."]
#[doc = " @details The host can use this request to start a scan operation to detect near-by access points."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | Yes             |"]
#[doc = "          | station        | Yes             |"]
#[doc = "          | AP             | No              |"]
#[doc = "          | IBSS           | No              |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
pub struct sl_wfx_start_scan_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_start_scan_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_start_scan_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_start_scan_req_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_start_scan_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_start_scan_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_start_scan_req_s))
    );
}
pub type sl_wfx_start_scan_req_t = sl_wfx_start_scan_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_start_scan_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_start_scan_cnf_body_s {
    #[doc = " @brief Status of the scan request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the scan request was accepted. It will be completed by sl_wfx_scan_complete_ind_t."]
    #[doc = "          <BR><B>any other value</B>: the scan request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_start_scan_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_start_scan_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_start_scan_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_start_scan_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_start_scan_cnf_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_start_scan_cnf_body_s>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_scan_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_start_scan_cnf_body_t = sl_wfx_start_scan_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_start_scan_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_start_scan_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_start_scan_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_start_scan_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_start_scan_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_start_scan_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_start_scan_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_start_scan_cnf_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_start_scan_cnf_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_scan_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_start_scan_cnf_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_start_scan_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_start_scan_cnf_t = sl_wfx_start_scan_cnf_s;
#[doc = " @struct sl_wfx_stop_scan_req_t"]
#[doc = " @brief Request message for stopping an ongoing scan."]
#[doc = " @details The host can use this request to stop an ongoing scan operation."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | Yes             |"]
#[doc = "          | station        | Yes             |"]
#[doc = "          | AP             | No              |"]
#[doc = "          | IBSS           | No              |"]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
pub type sl_wfx_stop_scan_req_t = sl_wfx_header_t;
#[doc = " @brief Confirmation message body for sl_wfx_stop_scan_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_stop_scan_cnf_body_s {
    #[doc = " @brief Status of the stop request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the stop request was accepted. It will be completed by WFM_HI_SCAN_COMPLETE_IND."]
    #[doc = "          <BR><B>any other value</B>: the stop request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_stop_scan_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_stop_scan_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_stop_scan_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_stop_scan_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_stop_scan_cnf_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_stop_scan_cnf_body_s>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_stop_scan_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_stop_scan_cnf_body_t = sl_wfx_stop_scan_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_stop_scan_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_stop_scan_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_stop_scan_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_stop_scan_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_stop_scan_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_stop_scan_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_stop_scan_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_stop_scan_cnf_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_stop_scan_cnf_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_stop_scan_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_stop_scan_cnf_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_stop_scan_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_stop_scan_cnf_t = sl_wfx_stop_scan_cnf_s;
#[doc = " @brief Indication message body for sl_wfx_scan_result_ind_t."]
#[repr(C, packed)]
pub struct sl_wfx_scan_result_ind_body_s {
    #[doc = " @brief Service Set Identifier (SSID) of the network."]
    pub ssid_def: sl_wfx_ssid_def_t,
    #[doc = " @brief MAC address of the access point."]
    pub mac: [u8; 6usize],
    #[doc = " @brief Channel of the access point."]
    #[doc = " @details <B>1 - 13</B>: Channel number."]
    pub channel: u16,
    #[doc = " @brief Security Capabilities of the network."]
    pub security_mode: sl_wfx_security_mode_bitmask_t,
    #[doc = " @brief Reserved."]
    pub reserved1: u8,
    #[doc = " @brief Reserved."]
    pub reserved2: u16,
    #[doc = " @brief Received Channel Power Indicator (RCPI) of the access point."]
    #[doc = " @details See @ref WFM_CONCEPT_RCPI for further details."]
    pub rcpi: u16,
    #[doc = " @brief Length of access point Information Element (IE) data in bytes."]
    pub ie_data_length: u16,
    #[doc = " @brief Access point IE data from the 802.11 Beacon or Probe Response frame."]
    pub ie_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_scan_result_ind_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_scan_result_ind_body_s>(),
        52usize,
        concat!("Size of: ", stringify!(sl_wfx_scan_result_ind_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_scan_result_ind_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_scan_result_ind_body_s))
    );
}
pub type sl_wfx_scan_result_ind_body_t = sl_wfx_scan_result_ind_body_s;
#[doc = " @brief Indication message used to signal an access point has been detected."]
#[doc = " @details The device will send this indication to signal an access point has"]
#[doc = "          has been detected during the scan operation."]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
pub struct sl_wfx_scan_result_ind_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Indication message body."]
    pub body: sl_wfx_scan_result_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_scan_result_ind_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_scan_result_ind_s>(),
        56usize,
        concat!("Size of: ", stringify!(sl_wfx_scan_result_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_scan_result_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_scan_result_ind_s))
    );
}
pub type sl_wfx_scan_result_ind_t = sl_wfx_scan_result_ind_s;
#[doc = " @brief Indication message body for sl_wfx_scan_complete_ind_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_scan_complete_ind_body_s {
    #[doc = " @brief Status of the scan request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the scan request was completed."]
    #[doc = "          <BR><B>any other value</B>: the scan request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_scan_complete_ind_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_scan_complete_ind_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_scan_complete_ind_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_scan_complete_ind_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_scan_complete_ind_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_scan_complete_ind_body_s>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_scan_complete_ind_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_scan_complete_ind_body_t = sl_wfx_scan_complete_ind_body_s;
#[doc = " @brief Indication message used to signal a scan was completed."]
#[doc = " @details The device will send this indication to signal a scan operation"]
#[doc = "          has been completed."]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_scan_complete_ind_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Indication message body."]
    pub body: sl_wfx_scan_complete_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_scan_complete_ind_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_scan_complete_ind_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_scan_complete_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_scan_complete_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_scan_complete_ind_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_scan_complete_ind_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_scan_complete_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_scan_complete_ind_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_scan_complete_ind_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_scan_complete_ind_t = sl_wfx_scan_complete_ind_s;
#[doc = " @brief Request message body for sl_wfx_join_ibss_req_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_join_ibss_req_body_s {
    #[doc = " @brief Service Set Identifier (SSID) of the network."]
    pub ssid_def: sl_wfx_ssid_def_t,
    #[doc = " @brief Channel of the network."]
    #[doc = " @details <B>0</B>: The device will connect to a matching network on any channel."]
    #[doc = "          <BR><B>1 - 13</B>: The device will only connect to a matching network on the given channel."]
    pub channel: u32,
    #[doc = " @brief Security mode of the network."]
    #[doc = " @details <B>WFM_SECURITY_MODE_OPEN</B>: The device will only use unsecured connections."]
    #[doc = "          <BR><B>WFM_SECURITY_MODE_WEP</B>: The device will only use WEP connections."]
    #[doc = "          <BR>See wfm_security_mode for enumeration values."]
    pub security_mode: u16,
    #[doc = " @brief Length of the network password."]
    #[doc = " @details <B>0 - 26</B>: The amount of bytes."]
    pub password_length: u16,
    #[doc = " @brief Password of the network."]
    #[doc = " @details <B>64-bit WEP key</B>: 5 bytes in ASCII format or 10 bytes in HEX format."]
    #[doc = "          <BR><B>128-bit WEP key</B>: 13 bytes in ASCII format or 26 bytes in HEX format."]
    #[doc = "          <BR>See @ref WFM_CONCEPT_PASSWORD for further details."]
    pub password: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_join_ibss_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_join_ibss_req_body_s>(),
        108usize,
        concat!("Size of: ", stringify!(sl_wfx_join_ibss_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_join_ibss_req_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_join_ibss_req_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_join_ibss_req_body_s>())).ssid_def as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_join_ibss_req_body_s),
            "::",
            stringify!(ssid_def)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_join_ibss_req_body_s>())).channel as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_join_ibss_req_body_s),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_join_ibss_req_body_s>())).security_mode as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_join_ibss_req_body_s),
            "::",
            stringify!(security_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_join_ibss_req_body_s>())).password_length as *const _
                as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_join_ibss_req_body_s),
            "::",
            stringify!(password_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_join_ibss_req_body_s>())).password as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_join_ibss_req_body_s),
            "::",
            stringify!(password)
        )
    );
}
pub type sl_wfx_join_ibss_req_body_t = sl_wfx_join_ibss_req_body_s;
#[doc = " @brief Request message for connecting to or starting an IBSS network."]
#[doc = " @details The host can use this request to connect to an IBSS network. If no existing network"]
#[doc = "          is found, the device will start a new network."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | Yes             |"]
#[doc = "          | station        | No              |"]
#[doc = "          | AP             | No              |"]
#[doc = "          | IBSS           | No              |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_join_ibss_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_join_ibss_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_join_ibss_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_join_ibss_req_s>(),
        112usize,
        concat!("Size of: ", stringify!(sl_wfx_join_ibss_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_join_ibss_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_join_ibss_req_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_join_ibss_req_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_join_ibss_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_join_ibss_req_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_join_ibss_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_join_ibss_req_t = sl_wfx_join_ibss_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_join_ibss_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_join_ibss_cnf_body_s {
    #[doc = " @brief Status of the join request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the join request was accepted. It will be completed by sl_wfx_join_ibss_ind_t."]
    #[doc = "          <BR><B>any other value</B>: the join request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_join_ibss_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_join_ibss_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_join_ibss_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_join_ibss_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_join_ibss_cnf_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_join_ibss_cnf_body_s>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_join_ibss_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_join_ibss_cnf_body_t = sl_wfx_join_ibss_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_join_ibss_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_join_ibss_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_join_ibss_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_join_ibss_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_join_ibss_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_join_ibss_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_join_ibss_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_join_ibss_cnf_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_join_ibss_cnf_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_join_ibss_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_join_ibss_cnf_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_join_ibss_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_join_ibss_cnf_t = sl_wfx_join_ibss_cnf_s;
#[doc = " @brief Indication message body for sl_wfx_join_ibss_ind_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_join_ibss_ind_body_s {
    #[doc = " @brief Status of the join request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the join request was completed successfully."]
    #[doc = "          <BR><B>any other value</B>: the join request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
    #[doc = " @brief Basic Service Set Identifier (BSSID) of the network."]
    #[doc = " @details <BR>See @ref WFM_CONCEPT_BSSID for further details."]
    pub bssid: [u8; 6usize],
    #[doc = " @brief Reserved."]
    pub reserved: u16,
}
#[test]
fn bindgen_test_layout_sl_wfx_join_ibss_ind_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_join_ibss_ind_body_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_join_ibss_ind_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_join_ibss_ind_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_join_ibss_ind_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_join_ibss_ind_body_s>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_join_ibss_ind_body_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_join_ibss_ind_body_s>())).bssid as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_join_ibss_ind_body_s),
            "::",
            stringify!(bssid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_join_ibss_ind_body_s>())).reserved as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_join_ibss_ind_body_s),
            "::",
            stringify!(reserved)
        )
    );
}
pub type sl_wfx_join_ibss_ind_body_t = sl_wfx_join_ibss_ind_body_s;
#[doc = " @brief Indication message used to signal the completion of a join request."]
#[doc = " @details The device will send this indication to signal the join request initiated"]
#[doc = "          with sl_wfx_join_ibss_req_t has been completed."]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_join_ibss_ind_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Indication message body."]
    pub body: sl_wfx_join_ibss_ind_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_join_ibss_ind_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_join_ibss_ind_s>(),
        16usize,
        concat!("Size of: ", stringify!(sl_wfx_join_ibss_ind_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_join_ibss_ind_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_join_ibss_ind_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_join_ibss_ind_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_join_ibss_ind_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_join_ibss_ind_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_join_ibss_ind_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_join_ibss_ind_t = sl_wfx_join_ibss_ind_s;
#[doc = " @struct sl_wfx_leave_ibss_req_t"]
#[doc = " @brief Request message for disconnecting from an IBSS network."]
#[doc = " @details The host can use this request to disconnect from an IBSS network."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | No              |"]
#[doc = "          | station        | No              |"]
#[doc = "          | AP             | No              |"]
#[doc = "          | IBSS           | Yes             |"]
#[doc = " @ingroup WFM_GROUP_MODE_IBSS"]
pub type sl_wfx_leave_ibss_req_t = sl_wfx_header_t;
#[doc = " @brief Confirmation message body for sl_wfx_leave_ibss_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_leave_ibss_cnf_body_s {
    #[doc = " @brief Status of the disconnect request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the disconnect request was accepted. It will be completed by sl_wfx_leave_ibss_ind_t."]
    #[doc = "          <BR><B>any other value</B>: the disconnect request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_leave_ibss_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_leave_ibss_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_leave_ibss_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_leave_ibss_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_leave_ibss_cnf_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_leave_ibss_cnf_body_s>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_leave_ibss_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_leave_ibss_cnf_body_t = sl_wfx_leave_ibss_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_leave_ibss_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_IBSS"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_leave_ibss_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_leave_ibss_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_leave_ibss_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_leave_ibss_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_leave_ibss_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_leave_ibss_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_leave_ibss_cnf_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_leave_ibss_cnf_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_leave_ibss_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_leave_ibss_cnf_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_leave_ibss_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_leave_ibss_cnf_t = sl_wfx_leave_ibss_cnf_s;
#[doc = " @struct sl_wfx_leave_ibss_ind_t"]
#[doc = " @brief Indication message used to signal the completion of a disconnect operation."]
#[doc = " @details The device will send this indication to signal the disconnect request initiated"]
#[doc = "          with sl_wfx_leave_ibss_req_t has been completed. The indication is also sent when"]
#[doc = "          the network has encountered a fatal error."]
#[doc = " @ingroup WFM_GROUP_MODE_IBSS"]
pub type sl_wfx_leave_ibss_ind_t = sl_wfx_header_t;
#[doc = " @brief Request message body for sl_wfx_add_multicast_addr_req_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_multicast_addr_req_body_s {
    #[doc = " @brief MAC address to add."]
    #[doc = " @details <B>broadcast address</B>: The device will empty the whitelist and allow all multicast addresses."]
    #[doc = "          <BR><B>zero address</B>: The device will empty the whitelist and deny all multicast addresses."]
    #[doc = "          <BR><B>multicast address</B>: The device will add the given address to the whitelist."]
    #[doc = "          <BR>See @ref WFM_CONCEPT_BSSID for further details."]
    pub mac: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_add_multicast_addr_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_multicast_addr_req_body_s>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_add_multicast_addr_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_multicast_addr_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_add_multicast_addr_req_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_add_multicast_addr_req_body_s>())).mac as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_multicast_addr_req_body_s),
            "::",
            stringify!(mac)
        )
    );
}
pub type sl_wfx_add_multicast_addr_req_body_t = sl_wfx_add_multicast_addr_req_body_s;
#[doc = " @brief Request message for adding a multicast address to the multicast filter whitelist."]
#[doc = " @details The host can use this request to add a multicast address to the multicast filter"]
#[doc = "          whitelist. When the first address is added the whitelist, the device will discard"]
#[doc = "          all multicast frames whose destination address does not match any of the addresses"]
#[doc = "          on the list. The default state is to allow all multicast addresses. The whitelist"]
#[doc = "          is reset to the default state when the interface is reset. Up to 8 multicast addresses"]
#[doc = "          may be added."]
#[doc = "          <BR>See @ref WFM_CONCEPT_FILTERING for further details."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | No              |"]
#[doc = "          | station        | Yes             |"]
#[doc = "          | AP             | Yes             |"]
#[doc = "          | IBSS           | No              |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_multicast_addr_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_add_multicast_addr_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_add_multicast_addr_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_multicast_addr_req_s>(),
        10usize,
        concat!("Size of: ", stringify!(sl_wfx_add_multicast_addr_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_multicast_addr_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_add_multicast_addr_req_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_add_multicast_addr_req_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_multicast_addr_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_add_multicast_addr_req_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_multicast_addr_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_add_multicast_addr_req_t = sl_wfx_add_multicast_addr_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_add_multicast_addr_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_multicast_addr_cnf_body_s {
    #[doc = " @brief Status of the add request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the add request was completed successfully."]
    #[doc = "          <BR><B>any other value</B>: the add request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_add_multicast_addr_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_multicast_addr_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_add_multicast_addr_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_multicast_addr_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_add_multicast_addr_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_add_multicast_addr_cnf_body_s>())).status as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_multicast_addr_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_add_multicast_addr_cnf_body_t = sl_wfx_add_multicast_addr_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_add_multicast_addr_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_multicast_addr_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_add_multicast_addr_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_add_multicast_addr_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_multicast_addr_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_add_multicast_addr_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_multicast_addr_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_add_multicast_addr_cnf_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_add_multicast_addr_cnf_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_multicast_addr_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_add_multicast_addr_cnf_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_multicast_addr_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_add_multicast_addr_cnf_t = sl_wfx_add_multicast_addr_cnf_s;
#[doc = " @brief Request message body for sl_wfx_remove_multicast_addr_req_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_remove_multicast_addr_req_body_s {
    #[doc = " @brief MAC address to remove."]
    #[doc = " @details <B>multicast address</B>: The device will remove the given address from the whitelist."]
    #[doc = "          <BR>See @ref WFM_CONCEPT_BSSID for further details."]
    pub mac: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_remove_multicast_addr_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_remove_multicast_addr_req_body_s>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_remove_multicast_addr_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_remove_multicast_addr_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_remove_multicast_addr_req_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_remove_multicast_addr_req_body_s>())).mac as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_remove_multicast_addr_req_body_s),
            "::",
            stringify!(mac)
        )
    );
}
pub type sl_wfx_remove_multicast_addr_req_body_t = sl_wfx_remove_multicast_addr_req_body_s;
#[doc = " @brief Request message for removing a multicast address from the multicast filter whitelist."]
#[doc = " @details The host can use this request to remove a multicast address from the multicast filter"]
#[doc = "          whitelist."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | No              |"]
#[doc = "          | station        | Yes             |"]
#[doc = "          | AP             | Yes             |"]
#[doc = "          | IBSS           | No              |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_remove_multicast_addr_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_remove_multicast_addr_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_remove_multicast_addr_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_remove_multicast_addr_req_s>(),
        10usize,
        concat!("Size of: ", stringify!(sl_wfx_remove_multicast_addr_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_remove_multicast_addr_req_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_remove_multicast_addr_req_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_remove_multicast_addr_req_s>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_remove_multicast_addr_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_remove_multicast_addr_req_s>())).body as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_remove_multicast_addr_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_remove_multicast_addr_req_t = sl_wfx_remove_multicast_addr_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_remove_multicast_addr_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_remove_multicast_addr_cnf_body_s {
    #[doc = " @brief Status of the remove request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the remove request was completed successfully."]
    #[doc = "          <BR><B>any other value</B>: the remove request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_remove_multicast_addr_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_remove_multicast_addr_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_remove_multicast_addr_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_remove_multicast_addr_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_remove_multicast_addr_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_remove_multicast_addr_cnf_body_s>())).status as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_remove_multicast_addr_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_remove_multicast_addr_cnf_body_t = sl_wfx_remove_multicast_addr_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_remove_multicast_addr_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_remove_multicast_addr_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_remove_multicast_addr_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_remove_multicast_addr_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_remove_multicast_addr_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_remove_multicast_addr_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_remove_multicast_addr_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_remove_multicast_addr_cnf_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_remove_multicast_addr_cnf_s>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_remove_multicast_addr_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_remove_multicast_addr_cnf_s>())).body as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_remove_multicast_addr_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_remove_multicast_addr_cnf_t = sl_wfx_remove_multicast_addr_cnf_s;
#[doc = " @brief Request message body for sl_wfx_set_max_ap_client_count_req_t."]
#[doc = " @details"]
#[doc = "          | Field     | Default value | Reset to default value |"]
#[doc = "          |:----------|:--------------|:-----------------------|"]
#[doc = "          | Count     | 8             | when interface stopped |"]
#[doc = "          <BR>"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_ap_client_count_req_body_s {
    #[doc = " @brief Maximum number of connected clients."]
    #[doc = " @details <B>0</B>: The device will set the limit value to the device default."]
    #[doc = "          <BR><B>1 - 8</B>: The maximum number of connected clients."]
    pub count: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_ap_client_count_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_ap_client_count_req_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_max_ap_client_count_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_ap_client_count_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_max_ap_client_count_req_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_max_ap_client_count_req_body_s>())).count as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_count_req_body_s),
            "::",
            stringify!(count)
        )
    );
}
pub type sl_wfx_set_max_ap_client_count_req_body_t = sl_wfx_set_max_ap_client_count_req_body_s;
#[doc = " @brief Request message for setting the maximum number of connected clients."]
#[doc = " @details The host can use this request to limit the number of stations that"]
#[doc = "          can connect the started Wi-Fi network."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | No              |"]
#[doc = "          | station        | No              |"]
#[doc = "          | AP             | Yes             |"]
#[doc = "          | IBSS           | No              |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_ap_client_count_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_set_max_ap_client_count_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_ap_client_count_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_ap_client_count_req_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_max_ap_client_count_req_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_ap_client_count_req_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_max_ap_client_count_req_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_max_ap_client_count_req_s>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_count_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_max_ap_client_count_req_s>())).body as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_count_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_max_ap_client_count_req_t = sl_wfx_set_max_ap_client_count_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_max_ap_client_count_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_ap_client_count_cnf_body_s {
    #[doc = " @brief Status of the set request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the set request was completed successfully."]
    #[doc = "          <BR><B>any other value</B>: the set request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_ap_client_count_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_ap_client_count_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_max_ap_client_count_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_ap_client_count_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_max_ap_client_count_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_max_ap_client_count_cnf_body_s>())).status
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_count_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_set_max_ap_client_count_cnf_body_t = sl_wfx_set_max_ap_client_count_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_max_ap_client_count_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_ap_client_count_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_set_max_ap_client_count_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_ap_client_count_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_ap_client_count_cnf_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_max_ap_client_count_cnf_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_ap_client_count_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_max_ap_client_count_cnf_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_max_ap_client_count_cnf_s>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_count_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_max_ap_client_count_cnf_s>())).body as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_count_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_max_ap_client_count_cnf_t = sl_wfx_set_max_ap_client_count_cnf_s;
#[doc = " @brief Request message body for sl_wfx_set_max_ap_client_inactivity_req_t."]
#[doc = " @details"]
#[doc = "          | Field             | Default value | Reset to default value |"]
#[doc = "          |:------------------|:--------------|:-----------------------|"]
#[doc = "          | inactivity_timeout | 65            | when interface stopped |"]
#[doc = "          <BR>"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_ap_client_inactivity_req_body_s {
    #[doc = " @brief Maximum amount of client idle time."]
    #[doc = " @details <B>0</B>: The device will set the limit value to the device default."]
    #[doc = "          <BR><B>1 - 240</B>: The maximum number of seconds."]
    pub inactivity_timeout: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_ap_client_inactivity_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_ap_client_inactivity_req_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_ap_client_inactivity_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_req_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_max_ap_client_inactivity_req_body_s>()))
                .inactivity_timeout as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_req_body_s),
            "::",
            stringify!(inactivity_timeout)
        )
    );
}
pub type sl_wfx_set_max_ap_client_inactivity_req_body_t =
    sl_wfx_set_max_ap_client_inactivity_req_body_s;
#[doc = " @brief Request message for setting the maximum number of connected clients."]
#[doc = " @details The host can use this request to limit the number of stations that"]
#[doc = "          can connect the started Wi-Fi network."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | No              |"]
#[doc = "          | station        | No              |"]
#[doc = "          | AP             | Yes             |"]
#[doc = "          | IBSS           | No              |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_ap_client_inactivity_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_set_max_ap_client_inactivity_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_ap_client_inactivity_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_ap_client_inactivity_req_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_req_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_ap_client_inactivity_req_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_req_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_max_ap_client_inactivity_req_s>())).header
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_max_ap_client_inactivity_req_s>())).body as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_max_ap_client_inactivity_req_t = sl_wfx_set_max_ap_client_inactivity_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_max_ap_client_count_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_ap_client_inactivity_cnf_body_s {
    #[doc = " @brief Status of the set request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the set request was completed successfully."]
    #[doc = "          <BR><B>any other value</B>: the set request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_ap_client_inactivity_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_ap_client_inactivity_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_ap_client_inactivity_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_max_ap_client_inactivity_cnf_body_s>())).status
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_set_max_ap_client_inactivity_cnf_body_t =
    sl_wfx_set_max_ap_client_inactivity_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_max_ap_client_inactivity_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_ap_client_inactivity_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_set_max_ap_client_inactivity_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_ap_client_inactivity_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_ap_client_inactivity_cnf_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_cnf_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_ap_client_inactivity_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_cnf_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_max_ap_client_inactivity_cnf_s>())).header
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_max_ap_client_inactivity_cnf_s>())).body as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_ap_client_inactivity_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_max_ap_client_inactivity_cnf_t = sl_wfx_set_max_ap_client_inactivity_cnf_s;
#[doc = " @brief Request message body for sl_wfx_set_roam_parameters_req_t."]
#[doc = " @details"]
#[doc = "          | Field            | Default value    | Reset to default value |"]
#[doc = "          |:-----------------|:-----------------|:-----------------------|"]
#[doc = "          | rcpi_threshold    | 60               | when device reset      |"]
#[doc = "          | rcpi_hysteresis   | 120              | when device reset      |"]
#[doc = "          | beacon_lost_count  | 10               | when device reset      |"]
#[doc = "          | channel_list_count | 13               | when device reset      |"]
#[doc = "          | channel_number    | 1 to 13          | when device reset      |"]
#[doc = "          <BR>"]
#[repr(C, packed)]
pub struct sl_wfx_set_roam_parameters_req_body_s {
    #[doc = " @brief Received Channel Power Indicator (RCPI) limit for a roaming attempt."]
    #[doc = " @details <B>0</B>: The device will set the limit value to the device default."]
    #[doc = "          <BR><B>1 - 220</B>: RCPI limit for a roaming attempt."]
    #[doc = "          <BR>See @ref WFM_CONCEPT_RCPI for further details."]
    pub rcpi_threshold: u8,
    #[doc = " @brief Upper RCPI limit that must be attained before triggering roaming again."]
    #[doc = " @details <B>0</B>: The device will set the limit value to the device default."]
    #[doc = "          <BR><B>1 - 220</B>: RCPI limit to re-enable automatic roaming based on RCPI."]
    #[doc = "          This value is used to prevent automatic roaming from triggering again and again"]
    #[doc = "          while the signal strength stays close to the rcpi_threshold value."]
    #[doc = "          rcpi_hysteresis should be set to a value grater than rcpi_threshold."]
    #[doc = "          <BR>See @ref WFM_CONCEPT_RCPI for further details."]
    pub rcpi_hysteresis: u8,
    #[doc = " @brief Beacon loss limit for a roaming attempt."]
    #[doc = " @details <B>0</B>: The device will set the limit value to the device default."]
    #[doc = "          <BR><B>1 - 255</B>: Beacon loss limit for a roaming attempt."]
    pub beacon_lost_count: u8,
    #[doc = " @brief The amount of specific channels to scan."]
    #[doc = " @details <B>0</B>: The device will set the channel list to the device default."]
    #[doc = "          <BR><B>1 - 13</B>: The amount of specific channels to scan."]
    pub channel_list_count: u8,
    #[doc = " @brief List of specific channels to scan."]
    #[doc = " @details <B>1 - 13</B>: The channel number to scan per byte."]
    #[doc = "          <BR>Must contain the same number of channels as specified in channel_list_count."]
    #[doc = "          <BR>See @ref WFM_CONCEPT_SCAN for further details."]
    pub channel_number: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_roam_parameters_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_roam_parameters_req_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_roam_parameters_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_roam_parameters_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_roam_parameters_req_body_s)
        )
    );
}
pub type sl_wfx_set_roam_parameters_req_body_t = sl_wfx_set_roam_parameters_req_body_s;
#[doc = " @brief Request message for setting the roaming parameters."]
#[doc = " @details The host can use this request to configure the roaming parameters"]
#[doc = "          used by the device."]
#[doc = "          <BR>See @ref WFM_CONCEPT_ROAM for further details."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | Yes             |"]
#[doc = "          | station        | Yes             |"]
#[doc = "          | AP             | No              |"]
#[doc = "          | IBSS           | No              |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
pub struct sl_wfx_set_roam_parameters_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_set_roam_parameters_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_roam_parameters_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_roam_parameters_req_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_roam_parameters_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_roam_parameters_req_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_roam_parameters_req_s)
        )
    );
}
pub type sl_wfx_set_roam_parameters_req_t = sl_wfx_set_roam_parameters_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_roam_parameters_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_roam_parameters_cnf_body_s {
    #[doc = " @brief Status of the set request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the set request was completed successfully."]
    #[doc = "          <BR><B>any other value</B>: the set request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_roam_parameters_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_roam_parameters_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_roam_parameters_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_roam_parameters_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_roam_parameters_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_roam_parameters_cnf_body_s>())).status as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_roam_parameters_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_set_roam_parameters_cnf_body_t = sl_wfx_set_roam_parameters_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_roam_parameters_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_roam_parameters_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_set_roam_parameters_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_roam_parameters_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_roam_parameters_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_roam_parameters_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_roam_parameters_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_roam_parameters_cnf_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_roam_parameters_cnf_s>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_roam_parameters_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_roam_parameters_cnf_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_roam_parameters_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_roam_parameters_cnf_t = sl_wfx_set_roam_parameters_cnf_s;
#[doc = " @brief Request message body for sl_wfx_set_tx_rate_parameters_req_t."]
#[doc = " @details"]
#[doc = "          | Field          | Default value                 | Reset to default value |"]
#[doc = "          |:---------------|:------------------------------|:-----------------------|"]
#[doc = "          | rate_set_bitmask | all 802.11bg rates, MCS 0 - 7 | when device reset      |"]
#[doc = "          <BR>"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_tx_rate_parameters_req_body_s {
    #[doc = " @brief Reserved, set to zero."]
    pub reserved: u32,
    #[doc = " @brief TX rate set parameters."]
    pub rate_set_bitmask: sl_wfx_rate_set_bitmask_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_tx_rate_parameters_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_tx_rate_parameters_req_body_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_tx_rate_parameters_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_tx_rate_parameters_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_tx_rate_parameters_req_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_tx_rate_parameters_req_body_s>())).reserved
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_tx_rate_parameters_req_body_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_tx_rate_parameters_req_body_s>())).rate_set_bitmask
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_tx_rate_parameters_req_body_s),
            "::",
            stringify!(rate_set_bitmask)
        )
    );
}
pub type sl_wfx_set_tx_rate_parameters_req_body_t = sl_wfx_set_tx_rate_parameters_req_body_s;
#[doc = " @brief Request message for setting the TX rate set parameters."]
#[doc = " @details The host can use this request to configure the TX rate"]
#[doc = "          set parameters of the device. The rate set determines"]
#[doc = "          what data rates will be used by the device to transmit data"]
#[doc = "          frames."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | Yes             |"]
#[doc = "          | station        | Yes             |"]
#[doc = "          | AP             | No              |"]
#[doc = "          | IBSS           | No              |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_tx_rate_parameters_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_set_tx_rate_parameters_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_tx_rate_parameters_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_tx_rate_parameters_req_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_set_tx_rate_parameters_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_tx_rate_parameters_req_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_tx_rate_parameters_req_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_tx_rate_parameters_req_s>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_tx_rate_parameters_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_tx_rate_parameters_req_s>())).body as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_tx_rate_parameters_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_tx_rate_parameters_req_t = sl_wfx_set_tx_rate_parameters_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_tx_rate_parameters_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_tx_rate_parameters_cnf_body_s {
    #[doc = " @brief Status of the set request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the set request was completed successfully."]
    #[doc = "          <BR><B>any other value</B>: the set request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_tx_rate_parameters_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_tx_rate_parameters_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_tx_rate_parameters_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_tx_rate_parameters_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_tx_rate_parameters_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_tx_rate_parameters_cnf_body_s>())).status as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_tx_rate_parameters_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_set_tx_rate_parameters_cnf_body_t = sl_wfx_set_tx_rate_parameters_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_tx_rate_parameters_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_tx_rate_parameters_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_set_tx_rate_parameters_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_tx_rate_parameters_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_tx_rate_parameters_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_tx_rate_parameters_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_tx_rate_parameters_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_tx_rate_parameters_cnf_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_tx_rate_parameters_cnf_s>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_tx_rate_parameters_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_tx_rate_parameters_cnf_s>())).body as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_tx_rate_parameters_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_tx_rate_parameters_cnf_t = sl_wfx_set_tx_rate_parameters_cnf_s;
#[doc = " @brief Request message body for sl_wfx_set_arp_ip_address_req_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_arp_ip_address_req_body_s {
    #[doc = " @brief List of offloaded ARP IP addresses."]
    #[doc = " @details The device will automatically reply to an ARP request that matches"]
    #[doc = "          one the addresses on the list. Note that addresses not in use must"]
    #[doc = "          be set to zero. Offloading is disabled by setting all addresses to"]
    #[doc = "          zero."]
    #[doc = "          <BR>See @ref WFM_CONCEPT_OFFLOADING for further details."]
    pub arp_ip_addr: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_set_arp_ip_address_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_arp_ip_address_req_body_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_arp_ip_address_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_arp_ip_address_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_arp_ip_address_req_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_arp_ip_address_req_body_s>())).arp_ip_addr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_arp_ip_address_req_body_s),
            "::",
            stringify!(arp_ip_addr)
        )
    );
}
pub type sl_wfx_set_arp_ip_address_req_body_t = sl_wfx_set_arp_ip_address_req_body_s;
#[doc = " @brief Request message for setting the Address Resolution Protocol (ARP) offloading state."]
#[doc = " @details The host can use this request to offload handling of ARP requests to the device."]
#[doc = "          When offloading is enabled, the device will automatically respond to ARP requests"]
#[doc = "          with an ARP reply. By default offloading is disabled. Offloading is reset to"]
#[doc = "          the default state when the interface is reset."]
#[doc = "          <BR>See @ref WFM_CONCEPT_OFFLOADING for further details."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | No              |"]
#[doc = "          | station        | Yes             |"]
#[doc = "          | AP             | No              |"]
#[doc = "          | IBSS           | No              |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_arp_ip_address_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_set_arp_ip_address_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_arp_ip_address_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_arp_ip_address_req_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_set_arp_ip_address_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_arp_ip_address_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_arp_ip_address_req_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_arp_ip_address_req_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_arp_ip_address_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_arp_ip_address_req_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_arp_ip_address_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_arp_ip_address_req_t = sl_wfx_set_arp_ip_address_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_arp_ip_address_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_arp_ip_address_cnf_body_s {
    #[doc = " @brief Status of the set request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the set request was completed successfully."]
    #[doc = "          <BR><B>any other value</B>: the set request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_arp_ip_address_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_arp_ip_address_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_arp_ip_address_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_arp_ip_address_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_arp_ip_address_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_arp_ip_address_cnf_body_s>())).status as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_arp_ip_address_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_set_arp_ip_address_cnf_body_t = sl_wfx_set_arp_ip_address_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_arp_ip_address_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_arp_ip_address_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_set_arp_ip_address_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_arp_ip_address_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_arp_ip_address_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_arp_ip_address_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_arp_ip_address_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_arp_ip_address_cnf_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_arp_ip_address_cnf_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_arp_ip_address_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_arp_ip_address_cnf_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_arp_ip_address_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_arp_ip_address_cnf_t = sl_wfx_set_arp_ip_address_cnf_s;
#[doc = " @brief Request message body for sl_wfx_set_ns_ip_address_req_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_ns_ip_address_req_body_s {
    #[doc = " @brief List of offloaded NS IP addresses."]
    #[doc = " @details The device will automatically reply to a NS that matches one the"]
    #[doc = "          addresses on the list. Note that addresses not in use must be set"]
    #[doc = "          to zero. Offloading is disabled by setting all addresses to zero."]
    #[doc = "          <BR>See @ref WFM_CONCEPT_OFFLOADING for further details."]
    pub ns_ip_addr: [sl_wfx_ns_ip_addr_t; 2usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_set_ns_ip_address_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_ns_ip_address_req_body_s>(),
        32usize,
        concat!("Size of: ", stringify!(sl_wfx_set_ns_ip_address_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_ns_ip_address_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_ns_ip_address_req_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_ns_ip_address_req_body_s>())).ns_ip_addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_ns_ip_address_req_body_s),
            "::",
            stringify!(ns_ip_addr)
        )
    );
}
pub type sl_wfx_set_ns_ip_address_req_body_t = sl_wfx_set_ns_ip_address_req_body_s;
#[doc = " @brief Request message for setting the Neighbor Discovery Protocol (NDP) offloading state."]
#[doc = " @details The host can use this request to offload handling of IPv6 Neighbor Solicitations"]
#[doc = "          to the device. When offloading is enabled, the device will automatically respond"]
#[doc = "          to a solicitation with a Neighbor Advertisement.  By default offloading is disabled."]
#[doc = "          Offloading is reset to the default state when the interface is reset."]
#[doc = "          <BR>See @ref WFM_CONCEPT_OFFLOADING for further details."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | No              |"]
#[doc = "          | station        | Yes             |"]
#[doc = "          | AP             | No              |"]
#[doc = "          | IBSS           | No              |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_ns_ip_address_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_set_ns_ip_address_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_ns_ip_address_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_ns_ip_address_req_s>(),
        36usize,
        concat!("Size of: ", stringify!(sl_wfx_set_ns_ip_address_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_ns_ip_address_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_ns_ip_address_req_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_ns_ip_address_req_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_ns_ip_address_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_ns_ip_address_req_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_ns_ip_address_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_ns_ip_address_req_t = sl_wfx_set_ns_ip_address_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_ns_ip_address_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_ns_ip_address_cnf_body_s {
    #[doc = " @brief Status of the set request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the set request was completed successfully."]
    #[doc = "          <BR><B>any other value</B>: the set request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_ns_ip_address_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_ns_ip_address_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_set_ns_ip_address_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_ns_ip_address_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_ns_ip_address_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_ns_ip_address_cnf_body_s>())).status as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_ns_ip_address_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_set_ns_ip_address_cnf_body_t = sl_wfx_set_ns_ip_address_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_ns_ip_address_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_ns_ip_address_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_set_ns_ip_address_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_ns_ip_address_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_ns_ip_address_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_ns_ip_address_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_ns_ip_address_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_ns_ip_address_cnf_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_ns_ip_address_cnf_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_ns_ip_address_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_ns_ip_address_cnf_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_ns_ip_address_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_ns_ip_address_cnf_t = sl_wfx_set_ns_ip_address_cnf_s;
#[doc = " @brief Request message body for sl_wfx_set_broadcast_filter_req_t."]
#[doc = " @details"]
#[doc = "          | Field  | Default value | Reset to default value |"]
#[doc = "          |:-------|:--------------|:-----------------------|"]
#[doc = "          | Filter | 0             | when interface stopped |"]
#[doc = "          <BR>"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_broadcast_filter_req_body_s {
    #[doc = " @brief Boolean option for broadcast filtering."]
    #[doc = " @details <B>0</B>: The device will forward all received broadcast frames to the host."]
    #[doc = "          <BR><B>1</B>: The device will only forward ARP and DHCP frames to the host,"]
    #[doc = "                        other broadcast frames are discarded."]
    #[doc = "          <BR>See @ref WFM_CONCEPT_FILTERING for further details."]
    pub filter: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_broadcast_filter_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_broadcast_filter_req_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_broadcast_filter_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_broadcast_filter_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_broadcast_filter_req_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_broadcast_filter_req_body_s>())).filter as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_broadcast_filter_req_body_s),
            "::",
            stringify!(filter)
        )
    );
}
pub type sl_wfx_set_broadcast_filter_req_body_t = sl_wfx_set_broadcast_filter_req_body_s;
#[doc = " @brief Request message for setting broadcast filter state."]
#[doc = " @details The host can use this request to configure the state of the broadcast filter."]
#[doc = "          When enabled, the device will only forward certain broadcast frames to the"]
#[doc = "          host and automatically discard the rest."]
#[doc = "          <BR>See @ref WFM_CONCEPT_FILTERING for further details."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | No              |"]
#[doc = "          | station        | Yes             |"]
#[doc = "          | AP             | No              |"]
#[doc = "          | IBSS           | No              |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_broadcast_filter_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_set_broadcast_filter_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_broadcast_filter_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_broadcast_filter_req_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_broadcast_filter_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_broadcast_filter_req_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_broadcast_filter_req_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_broadcast_filter_req_s>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_broadcast_filter_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_broadcast_filter_req_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_broadcast_filter_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_broadcast_filter_req_t = sl_wfx_set_broadcast_filter_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_broadcast_filter_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_broadcast_filter_cnf_body_s {
    #[doc = " @brief Status of the set request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the set request was completed successfully."]
    #[doc = "          <BR><B>any other value</B>: the set request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_broadcast_filter_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_broadcast_filter_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_broadcast_filter_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_broadcast_filter_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_broadcast_filter_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_broadcast_filter_cnf_body_s>())).status as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_broadcast_filter_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_set_broadcast_filter_cnf_body_t = sl_wfx_set_broadcast_filter_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_broadcast_filter_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_broadcast_filter_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_set_broadcast_filter_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_broadcast_filter_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_broadcast_filter_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_broadcast_filter_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_broadcast_filter_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_broadcast_filter_cnf_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_broadcast_filter_cnf_s>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_broadcast_filter_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_broadcast_filter_cnf_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_broadcast_filter_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_broadcast_filter_cnf_t = sl_wfx_set_broadcast_filter_cnf_s;
#[doc = " @brief Request message body for sl_wfx_set_scan_parameters_req_t."]
#[doc = " @details"]
#[doc = "          | Field              | Default value    | Reset to default value |"]
#[doc = "          |:-------------------|:-----------------|:-----------------------|"]
#[doc = "          | active_channel_time  | 50               | when device reset      |"]
#[doc = "          | passive_channel_time | 110              | when device reset      |"]
#[doc = "          | num_of_probe_requests | 1                | when device reset      |"]
#[doc = "          <BR>"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_scan_parameters_req_body_s {
    #[doc = " @brief Set to 0 for device default, 1 - 550 TUs"]
    pub active_channel_time: u16,
    #[doc = " @brief Set to 0 for device default, 1 - 550 TUs"]
    pub passive_channel_time: u16,
    #[doc = " @brief Set to 0 for device default, 1 - 2"]
    pub num_of_probe_requests: u16,
    #[doc = " @brief Reserved, set to zero."]
    pub reserved: u16,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_scan_parameters_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_scan_parameters_req_body_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_scan_parameters_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_scan_parameters_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_scan_parameters_req_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_scan_parameters_req_body_s>())).active_channel_time
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_scan_parameters_req_body_s),
            "::",
            stringify!(active_channel_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_scan_parameters_req_body_s>())).passive_channel_time
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_scan_parameters_req_body_s),
            "::",
            stringify!(passive_channel_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_scan_parameters_req_body_s>())).num_of_probe_requests
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_scan_parameters_req_body_s),
            "::",
            stringify!(num_of_probe_requests)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_scan_parameters_req_body_s>())).reserved as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_scan_parameters_req_body_s),
            "::",
            stringify!(reserved)
        )
    );
}
pub type sl_wfx_set_scan_parameters_req_body_t = sl_wfx_set_scan_parameters_req_body_s;
#[doc = " @brief Request message for setting scan parameters."]
#[doc = " @details The host can use this request to configure the scan parameters"]
#[doc = "          used by the device."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | Yes             |"]
#[doc = "          | station        | Yes             |"]
#[doc = "          | AP             | No              |"]
#[doc = "          | IBSS           | No              |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_scan_parameters_req_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_set_scan_parameters_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_scan_parameters_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_scan_parameters_req_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_set_scan_parameters_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_scan_parameters_req_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_scan_parameters_req_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_scan_parameters_req_s>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_scan_parameters_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_scan_parameters_req_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_scan_parameters_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_scan_parameters_req_t = sl_wfx_set_scan_parameters_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_scan_parameters_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_scan_parameters_cnf_body_s {
    #[doc = " @brief Status of the set request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the set request was completed successfully."]
    #[doc = "          <BR><B>any other value</B>: the set request failed."]
    #[doc = "          <BR>See sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_scan_parameters_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_scan_parameters_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_scan_parameters_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_scan_parameters_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_scan_parameters_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_scan_parameters_cnf_body_s>())).status as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_scan_parameters_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_set_scan_parameters_cnf_body_t = sl_wfx_set_scan_parameters_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_scan_parameters_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_scan_parameters_cnf_s {
    pub header: sl_wfx_header_t,
    pub body: sl_wfx_set_scan_parameters_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_scan_parameters_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_scan_parameters_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_scan_parameters_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_scan_parameters_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_scan_parameters_cnf_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_scan_parameters_cnf_s>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_scan_parameters_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_scan_parameters_cnf_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_scan_parameters_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_scan_parameters_cnf_t = sl_wfx_set_scan_parameters_cnf_s;
#[doc = " @brief Request message body for sl_wfx_set_unicast_filter_req_t."]
#[doc = " @details"]
#[doc = "          | Field  | Default value | Reset to default value |"]
#[doc = "          |:-------|:--------------|:-----------------------|"]
#[doc = "          | Filter | 1             | when interface stopped |"]
#[doc = "          <BR>"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_unicast_filter_req_body_s {
    #[doc = " @brief Boolean option for unicast filtering."]
    #[doc = " @details <B>0</B>: The device will forward all received unicast frames to the host."]
    #[doc = "          <BR><B>1</B>: The device will only forward unicast frames whose destination"]
    #[doc = "                        address matches the device MAC address."]
    #[doc = "          <BR>See @ref WFM_CONCEPT_FILTERING for further details."]
    pub filter: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_unicast_filter_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_unicast_filter_req_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_unicast_filter_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_unicast_filter_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_unicast_filter_req_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_unicast_filter_req_body_s>())).filter as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_unicast_filter_req_body_s),
            "::",
            stringify!(filter)
        )
    );
}
pub type sl_wfx_set_unicast_filter_req_body_t = sl_wfx_set_unicast_filter_req_body_s;
#[doc = " @brief Request message for setting unicast filter state."]
#[doc = " @details The host can use this request to configure the state of the unicast filter."]
#[doc = "          When enabled, the device will only forward certain unicast frames to the"]
#[doc = "          host and automatically discard the rest."]
#[doc = "          <BR>See @ref WFM_CONCEPT_FILTERING for further details."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | No              |"]
#[doc = "          | station        | No              |"]
#[doc = "          | AP             | Yes             |"]
#[doc = "          | IBSS           | No              |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_unicast_filter_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_set_unicast_filter_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_unicast_filter_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_unicast_filter_req_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_unicast_filter_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_unicast_filter_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_unicast_filter_req_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_unicast_filter_req_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_unicast_filter_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_unicast_filter_req_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_unicast_filter_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_unicast_filter_req_t = sl_wfx_set_unicast_filter_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_unicast_filter_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_unicast_filter_cnf_body_s {
    #[doc = " @brief Status of the set request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the set request was completed successfully."]
    #[doc = "          <BR><B>any other value</B>: the set request failed."]
    #[doc = "          <BR>See ::sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_unicast_filter_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_unicast_filter_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_set_unicast_filter_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_unicast_filter_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_unicast_filter_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_unicast_filter_cnf_body_s>())).status as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_unicast_filter_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_set_unicast_filter_cnf_body_t = sl_wfx_set_unicast_filter_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_unicast_filter_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_unicast_filter_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_set_unicast_filter_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_unicast_filter_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_unicast_filter_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_unicast_filter_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_unicast_filter_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_unicast_filter_cnf_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_unicast_filter_cnf_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_unicast_filter_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_unicast_filter_cnf_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_unicast_filter_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_unicast_filter_cnf_t = sl_wfx_set_unicast_filter_cnf_s;
#[doc = " @brief Request message body for sl_wfx_add_whitelist_addr_req_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_whitelist_addr_req_body_s {
    #[doc = " @brief MAC address to add."]
    #[doc = " @details <B>broadcast address</B>: The device will allow all MAC addresses."]
    #[doc = "          <BR><B>unicast address</B>: The device will add the given address to the whitelist."]
    pub mac: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_add_whitelist_addr_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_whitelist_addr_req_body_s>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_add_whitelist_addr_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_whitelist_addr_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_add_whitelist_addr_req_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_add_whitelist_addr_req_body_s>())).mac as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_whitelist_addr_req_body_s),
            "::",
            stringify!(mac)
        )
    );
}
pub type sl_wfx_add_whitelist_addr_req_body_t = sl_wfx_add_whitelist_addr_req_body_s;
#[doc = " @brief Request message for adding a MAC address to the device whitelist."]
#[doc = " @details The host can use this request to add a MAC address to the list of allowed MAC addresses."]
#[doc = "          When the first address is added the whitelist, the device will prevent communication with"]
#[doc = "          any devices whose MAC address does not match any of the addresses on the list. Setting a"]
#[doc = "          whitelist will clear all entries from the device blacklist. The default state is to allow"]
#[doc = "          all MAC addresses. The whitelist is reset to the default state when the interface is reset."]
#[doc = "          Up to 8 MAC addresses may be added."]
#[doc = "          <BR>See @ref WFM_CONCEPT_FILTERING for further details."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | No              |"]
#[doc = "          | station        | No              |"]
#[doc = "          | AP             | Yes             |"]
#[doc = "          | IBSS           | No              |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_whitelist_addr_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_add_whitelist_addr_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_add_whitelist_addr_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_whitelist_addr_req_s>(),
        10usize,
        concat!("Size of: ", stringify!(sl_wfx_add_whitelist_addr_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_whitelist_addr_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_add_whitelist_addr_req_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_add_whitelist_addr_req_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_whitelist_addr_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_add_whitelist_addr_req_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_whitelist_addr_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_add_whitelist_addr_req_t = sl_wfx_add_whitelist_addr_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_add_whitelist_addr_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_whitelist_addr_cnf_body_s {
    #[doc = " @brief Status of the add request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the add request was completed successfully."]
    #[doc = "          <BR><B>any other value</B>: the add request failed."]
    #[doc = "          <BR>See ::sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_add_whitelist_addr_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_whitelist_addr_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_add_whitelist_addr_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_whitelist_addr_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_add_whitelist_addr_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_add_whitelist_addr_cnf_body_s>())).status as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_whitelist_addr_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_add_whitelist_addr_cnf_body_t = sl_wfx_add_whitelist_addr_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_add_whitelist_addr_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_whitelist_addr_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_add_whitelist_addr_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_add_whitelist_addr_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_whitelist_addr_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_add_whitelist_addr_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_whitelist_addr_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_add_whitelist_addr_cnf_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_add_whitelist_addr_cnf_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_whitelist_addr_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_add_whitelist_addr_cnf_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_whitelist_addr_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_add_whitelist_addr_cnf_t = sl_wfx_add_whitelist_addr_cnf_s;
#[doc = " @brief Request message body for sl_wfx_add_blacklist_addr_req_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_blacklist_addr_req_body_s {
    #[doc = " @brief MAC address to add."]
    #[doc = " @details <B>broadcast address</B>: The device will deny all MAC addresses."]
    #[doc = "          <BR><B>unicast address</B>: The device will add the given address to the blacklist."]
    pub mac: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_add_blacklist_addr_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_blacklist_addr_req_body_s>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_add_blacklist_addr_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_blacklist_addr_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_add_blacklist_addr_req_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_add_blacklist_addr_req_body_s>())).mac as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_blacklist_addr_req_body_s),
            "::",
            stringify!(mac)
        )
    );
}
pub type sl_wfx_add_blacklist_addr_req_body_t = sl_wfx_add_blacklist_addr_req_body_s;
#[doc = " @brief Request message for adding a MAC address to the device blacklist."]
#[doc = " @details The host can use this request to add a MAC address to the list of denied MAC addresses."]
#[doc = "          When the first address is added the blacklist, the device will prevent communication with"]
#[doc = "          any device whose MAC address matches any of the addresses on the list. Setting a blacklist"]
#[doc = "          will clear all entries from the device whitelist. The default state is to allow all MAC"]
#[doc = "          addresses. The blacklist is reset to the default state when the interface is reset."]
#[doc = "          Up to 8 MAC addresses may be added."]
#[doc = "          <BR>See @ref WFM_CONCEPT_FILTERING for further details."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | No              |"]
#[doc = "          | station        | No              |"]
#[doc = "          | AP             | Yes             |"]
#[doc = "          | IBSS           | No              |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_blacklist_addr_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_add_blacklist_addr_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_add_blacklist_addr_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_blacklist_addr_req_s>(),
        10usize,
        concat!("Size of: ", stringify!(sl_wfx_add_blacklist_addr_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_blacklist_addr_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_add_blacklist_addr_req_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_add_blacklist_addr_req_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_blacklist_addr_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_add_blacklist_addr_req_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_blacklist_addr_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_add_blacklist_addr_req_t = sl_wfx_add_blacklist_addr_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_add_blacklist_addr_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_blacklist_addr_cnf_body_s {
    #[doc = " @brief Status of the add request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the add request was completed successfully."]
    #[doc = "          <BR><B>any other value</B>: the add request failed."]
    #[doc = "          <BR>See ::sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_add_blacklist_addr_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_blacklist_addr_cnf_body_s>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_add_blacklist_addr_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_blacklist_addr_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_add_blacklist_addr_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_add_blacklist_addr_cnf_body_s>())).status as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_blacklist_addr_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_add_blacklist_addr_cnf_body_t = sl_wfx_add_blacklist_addr_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_add_blacklist_addr_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_add_blacklist_addr_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_add_blacklist_addr_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_add_blacklist_addr_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_add_blacklist_addr_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_add_blacklist_addr_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_add_blacklist_addr_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_add_blacklist_addr_cnf_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_add_blacklist_addr_cnf_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_blacklist_addr_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_add_blacklist_addr_cnf_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_add_blacklist_addr_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_add_blacklist_addr_cnf_t = sl_wfx_add_blacklist_addr_cnf_s;
#[doc = " @brief Request message body for sl_wfx_set_max_tx_power_req_t."]
#[doc = " @details"]
#[doc = "          | Field      | Default value    | Reset to default value |"]
#[doc = "          |:-----------|:-----------------|:-----------------------|"]
#[doc = "          | max_tx_power | device dependent | when device reset      |"]
#[doc = "          <BR>"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_tx_power_req_body_s {
    #[doc = " @brief Maximum transmit power to set"]
    #[doc = " @details Expressed in units of 0.1d_bm."]
    pub max_tx_power: i32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_tx_power_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_tx_power_req_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_set_max_tx_power_req_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_tx_power_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_max_tx_power_req_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_max_tx_power_req_body_s>())).max_tx_power as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_tx_power_req_body_s),
            "::",
            stringify!(max_tx_power)
        )
    );
}
pub type sl_wfx_set_max_tx_power_req_body_t = sl_wfx_set_max_tx_power_req_body_s;
#[doc = " @brief Request message for setting the maximum transmit power of the device."]
#[doc = " @details The host can use this request to set a maximum transmit power."]
#[doc = "          The device can still use a lower transmit power depending on regulatory rules"]
#[doc = "          or internal limitations."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | Yes             |"]
#[doc = "          | station        | Yes             |"]
#[doc = "          | AP             | Yes             |"]
#[doc = "          | IBSS           | Yes             |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[doc = " @ingroup WFM_GROUP_MODE_IBSS"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_tx_power_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_set_max_tx_power_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_tx_power_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_tx_power_req_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_max_tx_power_req_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_tx_power_req_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_max_tx_power_req_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_max_tx_power_req_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_tx_power_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_max_tx_power_req_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_tx_power_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_max_tx_power_req_t = sl_wfx_set_max_tx_power_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_set_max_tx_power_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_tx_power_cnf_body_s {
    #[doc = " @brief Status of the add request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the add request was completed successfully."]
    #[doc = "          <BR><B>any other value</B>: the add request failed."]
    #[doc = "          <BR>See ::sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_tx_power_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_tx_power_cnf_body_s>(),
        4usize,
        concat!("Size of: ", stringify!(sl_wfx_set_max_tx_power_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_tx_power_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_set_max_tx_power_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_max_tx_power_cnf_body_s>())).status as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_tx_power_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
}
pub type sl_wfx_set_max_tx_power_cnf_body_t = sl_wfx_set_max_tx_power_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_set_max_tx_power_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[doc = " @ingroup WFM_GROUP_MODE_IBSS"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_set_max_tx_power_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_set_max_tx_power_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_set_max_tx_power_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_set_max_tx_power_cnf_s>(),
        8usize,
        concat!("Size of: ", stringify!(sl_wfx_set_max_tx_power_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_set_max_tx_power_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_set_max_tx_power_cnf_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_max_tx_power_cnf_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_tx_power_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_set_max_tx_power_cnf_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_set_max_tx_power_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_set_max_tx_power_cnf_t = sl_wfx_set_max_tx_power_cnf_s;
#[doc = " @struct sl_wfx_get_max_tx_power_req_t"]
#[doc = " @brief Request message for getting the maximum transmit power"]
#[doc = " @details The host can use this request to get the current value of maximum transmit power."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | Yes             |"]
#[doc = "          | station        | Yes             |"]
#[doc = "          | AP             | Yes             |"]
#[doc = "          | IBSS           | Yes             |"]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[doc = " @ingroup WFM_GROUP_MODE_IBSS"]
pub type sl_wfx_get_max_tx_power_req_t = sl_wfx_header_t;
#[doc = " @brief Confirmation message body for sl_wfx_get_max_tx_power_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_get_max_tx_power_cnf_body_s {
    #[doc = " @brief Status of the add request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the add request was completed successfully."]
    #[doc = "          <BR><B>any other value</B>: the add request failed."]
    #[doc = "          <BR>See ::sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
    #[doc = " @brief Maximum transmit power for RF port 1."]
    #[doc = " @details Expressed in units of 0.1d_bm."]
    pub max_tx_power_rf_port1: i32,
    #[doc = " @brief Maximum transmit power for RF port 2."]
    #[doc = " @details Expressed in units of 0.1d_bm."]
    pub max_tx_power_rf_port2: i32,
}
#[test]
fn bindgen_test_layout_sl_wfx_get_max_tx_power_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_get_max_tx_power_cnf_body_s>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_get_max_tx_power_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_get_max_tx_power_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_get_max_tx_power_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_get_max_tx_power_cnf_body_s>())).status as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_max_tx_power_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_get_max_tx_power_cnf_body_s>())).max_tx_power_rf_port1
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_max_tx_power_cnf_body_s),
            "::",
            stringify!(max_tx_power_rf_port1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_get_max_tx_power_cnf_body_s>())).max_tx_power_rf_port2
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_max_tx_power_cnf_body_s),
            "::",
            stringify!(max_tx_power_rf_port2)
        )
    );
}
pub type sl_wfx_get_max_tx_power_cnf_body_t = sl_wfx_get_max_tx_power_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_get_max_tx_power_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_IDLE"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[doc = " @ingroup WFM_GROUP_MODE_IBSS"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_get_max_tx_power_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_get_max_tx_power_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_get_max_tx_power_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_get_max_tx_power_cnf_s>(),
        16usize,
        concat!("Size of: ", stringify!(sl_wfx_get_max_tx_power_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_get_max_tx_power_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_get_max_tx_power_cnf_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_get_max_tx_power_cnf_s>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_max_tx_power_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_get_max_tx_power_cnf_s>())).body as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_max_tx_power_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_get_max_tx_power_cnf_t = sl_wfx_get_max_tx_power_cnf_s;
#[doc = " @struct sl_wfx_get_pmk_req_t"]
#[doc = " @brief Request message for getting the Pairwise Master Key (PMK)."]
#[doc = " @details The host can use this request to retrieve the Pairwise Master Key (PMK)"]
#[doc = "          used to connect to the current secure network. PMK can be given"]
#[doc = "          in the next sl_wfx_connect_req_t message to speed up connection"]
#[doc = "          process. See @ref WFM_CONCEPT_PASSWORD for further details."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | No              |"]
#[doc = "          | station        | Yes             |"]
#[doc = "          | AP             | Yes             |"]
#[doc = "          | IBSS           | No              |"]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
pub type sl_wfx_get_pmk_req_t = sl_wfx_header_t;
#[doc = " @brief Confirmation message body for sl_wfx_get_pmk_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_get_pmk_cnf_body_s {
    #[doc = " @brief Status of the add request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the get request was completed successfully."]
    #[doc = "          <BR><B>any other value</B>: the get request failed."]
    #[doc = "          <BR>See ::sl_wfx_fmac_status_t for enumeration values."]
    pub status: u32,
    #[doc = " @brief Length of the Pairwise Master Key."]
    #[doc = " @details <B>0 - 64</B>: The amount of bytes."]
    pub password_length: u32,
    #[doc = " @brief PMK of the network."]
    #[doc = " @details <B>WPA PMK</B>: 64 bytes in HEX format."]
    #[doc = "          <BR>See @ref WFM_CONCEPT_PASSWORD for further details."]
    pub password: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_get_pmk_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_get_pmk_cnf_body_s>(),
        72usize,
        concat!("Size of: ", stringify!(sl_wfx_get_pmk_cnf_body_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_get_pmk_cnf_body_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_get_pmk_cnf_body_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_get_pmk_cnf_body_s>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_pmk_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_get_pmk_cnf_body_s>())).password_length as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_pmk_cnf_body_s),
            "::",
            stringify!(password_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_get_pmk_cnf_body_s>())).password as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_pmk_cnf_body_s),
            "::",
            stringify!(password)
        )
    );
}
pub type sl_wfx_get_pmk_cnf_body_t = sl_wfx_get_pmk_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_get_pmk_req_t."]
#[doc = " @ingroup WFM_GROUP_MODE_STA"]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_get_pmk_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_get_pmk_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_get_pmk_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_get_pmk_cnf_s>(),
        76usize,
        concat!("Size of: ", stringify!(sl_wfx_get_pmk_cnf_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_get_pmk_cnf_s>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_get_pmk_cnf_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_get_pmk_cnf_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_pmk_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_get_pmk_cnf_s>())).body as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_pmk_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_get_pmk_cnf_t = sl_wfx_get_pmk_cnf_s;
#[doc = " @brief Request message body for sl_wfx_get_ap_client_signal_strength_req_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_get_ap_client_signal_strength_req_body_s {
    #[doc = " @brief MAC address of the station."]
    pub mac: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_get_ap_client_signal_strength_req_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_get_ap_client_signal_strength_req_body_s>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_get_ap_client_signal_strength_req_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_get_ap_client_signal_strength_req_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_get_ap_client_signal_strength_req_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_get_ap_client_signal_strength_req_body_s>())).mac
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_ap_client_signal_strength_req_body_s),
            "::",
            stringify!(mac)
        )
    );
}
pub type sl_wfx_get_ap_client_signal_strength_req_body_t =
    sl_wfx_get_ap_client_signal_strength_req_body_s;
#[doc = " @brief Request message for retrieving the signal strength of a client of the started Wi-Fi network."]
#[doc = " @details The host can use this request to retrieve the signal strength of a client of the started Wi-Fi network."]
#[doc = "          | Interface mode | Request allowed |"]
#[doc = "          |:---------------|:----------------|"]
#[doc = "          | idle           | No              |"]
#[doc = "          | station        | No              |"]
#[doc = "          | AP             | Yes             |"]
#[doc = "          | IBSS           | No              |"]
#[doc = "          <BR>"]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_get_ap_client_signal_strength_req_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Request message body."]
    pub body: sl_wfx_get_ap_client_signal_strength_req_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_get_ap_client_signal_strength_req_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_get_ap_client_signal_strength_req_s>(),
        10usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_get_ap_client_signal_strength_req_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_get_ap_client_signal_strength_req_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_get_ap_client_signal_strength_req_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_get_ap_client_signal_strength_req_s>())).header
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_ap_client_signal_strength_req_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_get_ap_client_signal_strength_req_s>())).body as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_ap_client_signal_strength_req_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_get_ap_client_signal_strength_req_t = sl_wfx_get_ap_client_signal_strength_req_s;
#[doc = " @brief Confirmation message body for sl_wfx_get_ap_client_signal_strength_cnf_t."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_get_ap_client_signal_strength_cnf_body_s {
    #[doc = " @brief Status of the get request."]
    #[doc = " @details <B>WFM_STATUS_SUCCESS</B>: the get request was completed."]
    #[doc = "          <BR><B>any other value</B>: the get request failed."]
    #[doc = "          <BR>See WFM_STATUS for enumeration values."]
    pub status: u32,
    #[doc = " @brief Received Channel Power Indicator (RCPI) of the client."]
    #[doc = " @details See @ref WFM_CONCEPT_RCPI for further details."]
    pub rcpi: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_get_ap_client_signal_strength_cnf_body_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_get_ap_client_signal_strength_cnf_body_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_get_ap_client_signal_strength_cnf_body_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_get_ap_client_signal_strength_cnf_body_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_get_ap_client_signal_strength_cnf_body_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_get_ap_client_signal_strength_cnf_body_s>())).status
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_ap_client_signal_strength_cnf_body_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_get_ap_client_signal_strength_cnf_body_s>())).rcpi
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_ap_client_signal_strength_cnf_body_s),
            "::",
            stringify!(rcpi)
        )
    );
}
pub type sl_wfx_get_ap_client_signal_strength_cnf_body_t =
    sl_wfx_get_ap_client_signal_strength_cnf_body_s;
#[doc = " @brief Confirmation message for sl_wfx_get_ap_client_signal_strength_cnf_t."]
#[doc = " @ingroup WFM_GROUP_MODE_AP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sl_wfx_get_ap_client_signal_strength_cnf_s {
    #[doc = " Common message header."]
    pub header: sl_wfx_header_t,
    #[doc = " Confirmation message body."]
    pub body: sl_wfx_get_ap_client_signal_strength_cnf_body_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_get_ap_client_signal_strength_cnf_s() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_get_ap_client_signal_strength_cnf_s>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(sl_wfx_get_ap_client_signal_strength_cnf_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_get_ap_client_signal_strength_cnf_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sl_wfx_get_ap_client_signal_strength_cnf_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_get_ap_client_signal_strength_cnf_s>())).header
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_ap_client_signal_strength_cnf_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_get_ap_client_signal_strength_cnf_s>())).body as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_get_ap_client_signal_strength_cnf_s),
            "::",
            stringify!(body)
        )
    );
}
pub type sl_wfx_get_ap_client_signal_strength_cnf_t = sl_wfx_get_ap_client_signal_strength_cnf_s;
extern "C" {
    pub static mut sl_wfx_firmware: [u8; 291920usize];
}
pub const sl_wfx_firmware_size: u32 = 291920;
pub const sl_wfx_register_address_t_SL_WFX_CONFIG_REG_ID: sl_wfx_register_address_t = 0;
pub const sl_wfx_register_address_t_SL_WFX_CONTROL_REG_ID: sl_wfx_register_address_t = 1;
pub const sl_wfx_register_address_t_SL_WFX_IN_OUT_QUEUE_REG_ID: sl_wfx_register_address_t = 2;
pub const sl_wfx_register_address_t_SL_WFX_AHB_DPORT_REG_ID: sl_wfx_register_address_t = 3;
pub const sl_wfx_register_address_t_SL_WFX_SRAM_BASE_ADDR_REG_ID: sl_wfx_register_address_t = 4;
pub const sl_wfx_register_address_t_SL_WFX_SRAM_DPORT_REG_ID: sl_wfx_register_address_t = 5;
pub const sl_wfx_register_address_t_SL_WFX_TSET_GEN_R_W_REG_ID: sl_wfx_register_address_t = 6;
pub const sl_wfx_register_address_t_SL_WFX_FRAME_OUT_REG_ID: sl_wfx_register_address_t = 7;
#[doc = " @enum sl_wfx_register_address_t"]
#[doc = " @brief Enum listing the registers of the WFx solution"]
pub type sl_wfx_register_address_t = u32;
pub const sl_wfx_state_t_SL_WFX_STARTED: sl_wfx_state_t = 1;
pub const sl_wfx_state_t_SL_WFX_STA_INTERFACE_CONNECTED: sl_wfx_state_t = 2;
pub const sl_wfx_state_t_SL_WFX_AP_INTERFACE_UP: sl_wfx_state_t = 4;
pub const sl_wfx_state_t_SL_WFX_SLEEPING: sl_wfx_state_t = 8;
pub const sl_wfx_state_t_SL_WFX_POWER_SAVE_ACTIVE: sl_wfx_state_t = 16;
#[doc = " @enum sl_wfx_state_t"]
#[doc = " @brief Enum listing the different state of the WFx chip"]
pub type sl_wfx_state_t = u32;
#[doc = "< Interface 0, linked to the station"]
pub const sl_wfx_interface_t_SL_WFX_STA_INTERFACE: sl_wfx_interface_t = 0;
#[doc = "< Interface 1, linked to the softap"]
pub const sl_wfx_interface_t_SL_WFX_SOFTAP_INTERFACE: sl_wfx_interface_t = 1;
#[doc = " @enum sl_wfx_interface_t"]
#[doc = " @brief Enum listing available interfaces in WFx Wi-Fi solution"]
#[doc = " @details For convenience, interface 0 is associated with the station"]
#[doc = " interface and interface 1 is associated with the softap interface."]
pub type sl_wfx_interface_t = u32;
#[doc = "< RF output 1 is used"]
pub const sl_wfx_antenna_config_t_SL_WFX_ANTENNA_1_ONLY: sl_wfx_antenna_config_t = 0;
#[doc = "< RF output 2 is used"]
pub const sl_wfx_antenna_config_t_SL_WFX_ANTENNA_2_ONLY: sl_wfx_antenna_config_t = 1;
#[doc = "< RF output 1 is used for TX, RF 2 for RX"]
pub const sl_wfx_antenna_config_t_SL_WFX_ANTENNA_TX1_RX2: sl_wfx_antenna_config_t = 2;
#[doc = "< RF output 2 is used for TX, RF 1 for RX"]
pub const sl_wfx_antenna_config_t_SL_WFX_ANTENNA_TX2_RX1: sl_wfx_antenna_config_t = 3;
#[doc = "< WF200 uses an antenna diversity algorithm"]
pub const sl_wfx_antenna_config_t_SL_WFX_ANTENNA_DIVERSITY: sl_wfx_antenna_config_t = 4;
#[doc = " @enum sl_wfx_antenna_config_t"]
#[doc = " @brief Enum listing the different antenna configurations"]
pub type sl_wfx_antenna_config_t = u32;
#[doc = "< Frame type indicating a confirmation message is available"]
pub const sl_wfx_received_message_type_t_SL_WFX_CONFIRMATION_MESSAGE:
    sl_wfx_received_message_type_t = 0;
#[doc = "< Frame type indicating an indication message is available"]
pub const sl_wfx_received_message_type_t_SL_WFX_INDICATION_MESSAGE: sl_wfx_received_message_type_t =
    1;
#[doc = "< Reserved from Low MAC interface"]
pub const sl_wfx_received_message_type_t_SL_WFX_MANAGEMENT_MESSAGE: sl_wfx_received_message_type_t =
    2;
#[doc = "< Frame type indicating message encapsulating a data frame is available"]
pub const sl_wfx_received_message_type_t_SL_WFX_ETHERNET_DATA_MESSAGE:
    sl_wfx_received_message_type_t = 3;
#[doc = " @enum sl_wfx_received_message_type_t"]
#[doc = " @brief Enum listing different message types received from WFx. The"]
#[doc = " information is found in the control register using"]
#[doc = " SL_WFX_CONT_FRAME_TYPE_INFO mask."]
pub type sl_wfx_received_message_type_t = u32;
pub const sl_wfx_buffer_type_t_SL_WFX_TX_FRAME_BUFFER: sl_wfx_buffer_type_t = 0;
pub const sl_wfx_buffer_type_t_SL_WFX_RX_FRAME_BUFFER: sl_wfx_buffer_type_t = 1;
pub const sl_wfx_buffer_type_t_SL_WFX_CONTROL_BUFFER: sl_wfx_buffer_type_t = 2;
#[doc = " @enum sl_wfx_buffer_type_t"]
#[doc = " @brief Enumerates the different types of buffer"]
pub type sl_wfx_buffer_type_t = u32;
pub const sl_wfx_host_bus_transfer_type_t_SL_WFX_BUS_WRITE: sl_wfx_host_bus_transfer_type_t = 1;
pub const sl_wfx_host_bus_transfer_type_t_SL_WFX_BUS_READ: sl_wfx_host_bus_transfer_type_t = 2;
pub const sl_wfx_host_bus_transfer_type_t_SL_WFX_BUS_WRITE_AND_READ:
    sl_wfx_host_bus_transfer_type_t = 3;
#[doc = " @enum sl_wfx_host_bus_transfer_type_t"]
#[doc = " @brief Enumerates the different types of bus transfers"]
pub type sl_wfx_host_bus_transfer_type_t = u32;
#[doc = " @struct sl_wfx_mac_address_t"]
#[doc = " @brief Structure to handle MAC address format"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sl_wfx_mac_address_t {
    #[doc = "< Table to store a MAC address"]
    pub octet: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_sl_wfx_mac_address_t() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_mac_address_t>(),
        6usize,
        concat!("Size of: ", stringify!(sl_wfx_mac_address_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_mac_address_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sl_wfx_mac_address_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_mac_address_t>())).octet as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_mac_address_t),
            "::",
            stringify!(octet)
        )
    );
}
#[doc = " @struct sl_wfx_nonce_t"]
#[doc = " @brief Structure to maintain secure link counters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sl_wfx_nonce_t {
    #[doc = "< High priority packet counter"]
    pub hp_packet_count: u32,
    #[doc = "< Received packet counter"]
    pub rx_packet_count: u32,
    #[doc = "< Sent packet counter"]
    pub tx_packet_count: u32,
}
#[test]
fn bindgen_test_layout_sl_wfx_nonce_t() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_nonce_t>(),
        12usize,
        concat!("Size of: ", stringify!(sl_wfx_nonce_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_nonce_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sl_wfx_nonce_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_nonce_t>())).hp_packet_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_nonce_t),
            "::",
            stringify!(hp_packet_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_nonce_t>())).rx_packet_count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_nonce_t),
            "::",
            stringify!(rx_packet_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_nonce_t>())).tx_packet_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_nonce_t),
            "::",
            stringify!(tx_packet_count)
        )
    );
}
#[doc = " @struct sl_wfx_context_t"]
#[doc = " @brief Structure used to maintain the Wi-Fi solution context on the host"]
#[doc = " side"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sl_wfx_context_t {
    #[doc = "< Event payload associated with the last posted event"]
    pub event_payload_buffer: [u8; 512usize],
    #[doc = "< Firmware build version"]
    pub firmware_build: u8,
    #[doc = "< Firmware minor version"]
    pub firmware_minor: u8,
    #[doc = "< Firmware major version"]
    pub firmware_major: u8,
    #[doc = "< Frame ID incremented by ::sl_wfx_send_ethernet_frame"]
    pub data_frame_id: u16,
    #[doc = "< Number of buffers currently in use by the WFx chip"]
    pub used_buffers: u16,
    #[doc = "< OPN of the part"]
    pub wfx_opn: [u8; 14usize],
    #[doc = "< Mac address used by WFx interface 0, station"]
    pub mac_addr_0: sl_wfx_mac_address_t,
    #[doc = "< Mac address used by WFx interface 1, softap"]
    pub mac_addr_1: sl_wfx_mac_address_t,
    #[doc = "< State of the WFx Wi-Fi chip"]
    pub state: sl_wfx_state_t,
}
#[test]
fn bindgen_test_layout_sl_wfx_context_t() {
    assert_eq!(
        ::core::mem::size_of::<sl_wfx_context_t>(),
        552usize,
        concat!("Size of: ", stringify!(sl_wfx_context_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sl_wfx_context_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sl_wfx_context_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_context_t>())).event_payload_buffer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_context_t),
            "::",
            stringify!(event_payload_buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_context_t>())).firmware_build as *const _ as usize
        },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_context_t),
            "::",
            stringify!(firmware_build)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_context_t>())).firmware_minor as *const _ as usize
        },
        513usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_context_t),
            "::",
            stringify!(firmware_minor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sl_wfx_context_t>())).firmware_major as *const _ as usize
        },
        514usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_context_t),
            "::",
            stringify!(firmware_major)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_context_t>())).data_frame_id as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_context_t),
            "::",
            stringify!(data_frame_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_context_t>())).used_buffers as *const _ as usize },
        518usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_context_t),
            "::",
            stringify!(used_buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_context_t>())).wfx_opn as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_context_t),
            "::",
            stringify!(wfx_opn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_context_t>())).mac_addr_0 as *const _ as usize },
        534usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_context_t),
            "::",
            stringify!(mac_addr_0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_context_t>())).mac_addr_1 as *const _ as usize },
        540usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_context_t),
            "::",
            stringify!(mac_addr_1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sl_wfx_context_t>())).state as *const _ as usize },
        548usize,
        concat!(
            "Offset of field: ",
            stringify!(sl_wfx_context_t),
            "::",
            stringify!(state)
        )
    );
}
extern "C" {
    pub static mut sl_wfx_context: *mut sl_wfx_context_t;
}
extern "C" {
    #[doc = " @brief Driver hook to initialize the host resources"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    #[doc = ""]
    #[doc = " @note Called once during the driver initialization phase"]
    pub fn sl_wfx_host_init() -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Driver hook to retrieve a firmware chunk"]
    #[doc = ""]
    #[doc = " @param data is a pointer to the firmware data"]
    #[doc = " @param data_size is the size of data requested by the driver"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    #[doc = ""]
    #[doc = " @note Called multiple times during the driver initialization phase"]
    pub fn sl_wfx_host_get_firmware_data(data: *mut *const u8, data_size: u32) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Driver hook to retrieve the firmware size"]
    #[doc = ""]
    #[doc = " @param firmware_size is a pointer to the firmware size value"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    #[doc = ""]
    #[doc = " @note Called once during the driver initialization phase"]
    pub fn sl_wfx_host_get_firmware_size(firmware_size: *mut u32) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Driver hook to retrieve a PDS line"]
    #[doc = ""]
    #[doc = " @param pds_data is a pointer to the PDS data"]
    #[doc = " @param index is the index of the line requested by the driver"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    #[doc = ""]
    #[doc = " @note Called multiple times during the driver initialization phase"]
    pub fn sl_wfx_host_get_pds_data(
        pds_data: *mut *const c_types::c_char,
        index: u16,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Driver hook to get the number of lines of the PDS"]
    #[doc = ""]
    #[doc = " @param pds_size is a pointer to the PDS size value"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    #[doc = ""]
    #[doc = " @note Called once during the driver initialization phase"]
    pub fn sl_wfx_host_get_pds_size(pds_size: *mut u16) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Driver hook to deinitialize the host resources"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    #[doc = ""]
    #[doc = " @note Called if an error occurs during the initialization phase"]
    pub fn sl_wfx_host_deinit() -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Implement the reset of the WFx chip"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    #[doc = ""]
    #[doc = " @note This function asserts the reset pin of the WFx chip for a while before"]
    #[doc = " returning"]
    pub fn sl_wfx_host_reset_chip() -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Drive the wake up pin in the requested state"]
    #[doc = ""]
    #[doc = " @param state to be applied to the wake up pin"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    #[doc = ""]
    #[doc = " @note Called if the sleep mode is enabled"]
    pub fn sl_wfx_host_set_wake_up_pin(state: u8) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Called once the WFx chip is waking up"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    #[doc = ""]
    #[doc = " @note Called if the sleep mode is enabled. The function waits for the WFx"]
    #[doc = " interruption"]
    pub fn sl_wfx_host_wait_for_wake_up() -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Called when the driver is considering putting the WFx in"]
    #[doc = " sleep mode"]
    #[doc = ""]
    #[doc = " @param type is the type of the message sent"]
    #[doc = " @param address is the address of the message sent"]
    #[doc = " @param length is the length of the message to be sent"]
    #[doc = " @returns Returns SL_STATUS_WIFI_SLEEP_GRANTED to let the WFx go to sleep,"]
    #[doc = " SL_STATUS_WIFI_SLEEP_NOT_GRANTED otherwise"]
    #[doc = ""]
    #[doc = " @note The parameters are given as information for the host to take a decision"]
    #[doc = " on whether or not the WFx is put back to sleep mode."]
    pub fn sl_wfx_host_sleep_grant(
        type_: sl_wfx_host_bus_transfer_type_t,
        address: sl_wfx_register_address_t,
        length: u32,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Hold the WFx chip in reset mode"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    #[doc = ""]
    #[doc = " @note The reset pin is asserted by the host to keep the WFx chip in reset"]
    pub fn sl_wfx_host_hold_in_reset() -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Set up the next event that the driver will wait"]
    #[doc = ""]
    #[doc = " @param event_id is the ID to be waited"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    #[doc = ""]
    #[doc = " @note Called every time a API command is called"]
    pub fn sl_wfx_host_setup_waited_event(event_id: u8) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Called when the driver is waiting for a confirmation"]
    #[doc = ""]
    #[doc = " @param confirmation_id is the ID to be waited"]
    #[doc = " @param timeout_ms is the time before the command times out"]
    #[doc = " @param event_payload_out is a pointer to the data returned by the"]
    #[doc = " confirmation"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    #[doc = ""]
    #[doc = " @note Called every time a API command is called"]
    pub fn sl_wfx_host_wait_for_confirmation(
        confirmation_id: u8,
        timeout_ms: u32,
        event_payload_out: *mut *mut c_types::c_void,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Called when the FMAC driver wants to add a delay"]
    #[doc = ""]
    #[doc = " @param wait_ms is the time to wait"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    #[doc = ""]
    #[doc = " @note Can be a passive wait or in a RTOS context a task sleep"]
    pub fn sl_wfx_host_wait(wait_ms: u32) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Called when a message is received from the WFx chip"]
    #[doc = ""]
    #[doc = " @param event_payload is a pointer to the data received"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    #[doc = ""]
    #[doc = " @note Called by ::sl_wfx_receive_frame function"]
    pub fn sl_wfx_host_post_event(event_payload: *mut sl_wfx_generic_message_t) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Called when the driver wants to allocate memory"]
    #[doc = ""]
    #[doc = " @param buffer is a pointer to the data"]
    #[doc = " @param type is the type of buffer to allocate (see ::sl_wfx_buffer_type_t)"]
    #[doc = " @param buffer_size represents the amount of memory to allocate"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    #[doc = ""]
    #[doc = " @note Called by the driver every time it needs memory"]
    pub fn sl_wfx_host_allocate_buffer(
        buffer: *mut *mut c_types::c_void,
        type_: sl_wfx_buffer_type_t,
        buffer_size: u32,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Called when the driver wants to free memory"]
    #[doc = ""]
    #[doc = " @param buffer is the pointer to the memory to free"]
    #[doc = " @param type is the type of buffer to free (see ::sl_wfx_buffer_type_t)"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    pub fn sl_wfx_host_free_buffer(
        buffer: *mut c_types::c_void,
        type_: sl_wfx_buffer_type_t,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Called when the driver sends a frame to the WFx chip"]
    #[doc = ""]
    #[doc = " @param frame is a pointer to the frame data"]
    #[doc = " @param frame_len is size of the frame"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    pub fn sl_wfx_host_transmit_frame(frame: *mut c_types::c_void, frame_len: u32) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Called when the driver needs to lock its access"]
    #[doc = ""]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    pub fn sl_wfx_host_lock() -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Called when the driver needs to unlock its access"]
    #[doc = ""]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    pub fn sl_wfx_host_unlock() -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Initialize the host bus"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    #[doc = ""]
    #[doc = " @note Called once during the driver initialization phase"]
    pub fn sl_wfx_host_init_bus() -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Deinitialize the host bus"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    #[doc = ""]
    #[doc = " @note Called if an error occurs during the initialization phase"]
    pub fn sl_wfx_host_deinit_bus() -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Enable the bus interrupt"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    pub fn sl_wfx_host_enable_platform_interrupt() -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Disable the bus interrupt"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    pub fn sl_wfx_host_disable_platform_interrupt() -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Assert the SPI Chip Select pin"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    pub fn sl_wfx_host_spi_cs_assert() -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Deassert the SPI Chip Select pin"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    pub fn sl_wfx_host_spi_cs_deassert() -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Send data on the SPI bus"]
    #[doc = ""]
    #[doc = " @param type is the type of bus action (see ::sl_wfx_host_bus_transfer_type_t)"]
    #[doc = " @param header is a pointer to the header data"]
    #[doc = " @param header_length is the length of the header data"]
    #[doc = " @param buffer is a pointer to the buffer data"]
    #[doc = " @param buffer_length is the length of the buffer data"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    pub fn sl_wfx_host_spi_transfer_no_cs_assert(
        type_: sl_wfx_host_bus_transfer_type_t,
        header: *mut u8,
        host_bus_transfer_type_t: u16,
        buffer: *mut u8,
        buffer_length: u16,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Send command 52 on the SDIO bus"]
    #[doc = ""]
    #[doc = " @param type is the type of bus action (see ::sl_wfx_host_bus_transfer_type_t)"]
    #[doc = " @param function is the function to use in the SDIO command"]
    #[doc = " @param address is the address to use in the SDIO command"]
    #[doc = " @param buffer is a pointer to the buffer data"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    pub fn sl_wfx_host_sdio_transfer_cmd52(
        type_: sl_wfx_host_bus_transfer_type_t,
        function: u8,
        address: u32,
        buffer: *mut u8,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Send command 53 on the SDIO bus"]
    #[doc = ""]
    #[doc = " @param type is the type of bus action (see ::sl_wfx_host_bus_transfer_type_t)"]
    #[doc = " @param function is the function to use in the SDIO command"]
    #[doc = " @param address is the address to use in the SDIO command"]
    #[doc = " @param buffer is a pointer to the buffer data"]
    #[doc = " @param buffer_length is the length of the buffer data"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    pub fn sl_wfx_host_sdio_transfer_cmd53(
        type_: sl_wfx_host_bus_transfer_type_t,
        function: u8,
        address: u32,
        buffer: *mut u8,
        buffer_length: u16,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Enable the SDIO high-speed mode"]
    #[doc = " @returns Returns SL_STATUS_OK if successful, SL_STATUS_FAIL otherwise"]
    pub fn sl_wfx_host_sdio_enable_high_speed_mode() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_init_bus() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_deinit_bus() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_reg_read(
        address: sl_wfx_register_address_t,
        buffer: *mut c_types::c_void,
        length: u32,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_reg_write(
        address: sl_wfx_register_address_t,
        buffer: *const c_types::c_void,
        length: u32,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_notify_bus_thread() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_reg_read_16(
        address: sl_wfx_register_address_t,
        value_out: *mut u16,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_reg_write_16(address: sl_wfx_register_address_t, value_in: u16) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_reg_read_32(
        address: sl_wfx_register_address_t,
        value_out: *mut u32,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_reg_write_32(address: sl_wfx_register_address_t, value_in: u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_data_read(buffer: *mut c_types::c_void, length: u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_data_write(buffer: *const c_types::c_void, length: u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_apb_write_32(address: u32, value_in: u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_apb_read_32(address: u32, value_out: *mut u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_apb_write(
        address: u32,
        buffer: *const c_types::c_void,
        length: u32,
    ) -> sl_status_t;
}
pub type size_t = c_types::c_ulong;
pub type wchar_t = c_types::c_int;
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = u32;
pub type __u_char = c_types::c_uchar;
pub type __u_short = c_types::c_ushort;
pub type __u_int = c_types::c_uint;
pub type __u_long = c_types::c_ulong;
pub type __int8_t = c_types::c_schar;
pub type __uint8_t = c_types::c_uchar;
pub type __int16_t = c_types::c_short;
pub type __uint16_t = c_types::c_ushort;
pub type __int32_t = c_types::c_int;
pub type __uint32_t = c_types::c_uint;
pub type __int64_t = c_types::c_long;
pub type __uint64_t = c_types::c_ulong;
pub type __quad_t = c_types::c_long;
pub type __u_quad_t = c_types::c_ulong;
pub type __dev_t = c_types::c_ulong;
pub type __uid_t = c_types::c_uint;
pub type __gid_t = c_types::c_uint;
pub type __ino_t = c_types::c_ulong;
pub type __ino64_t = c_types::c_ulong;
pub type __mode_t = c_types::c_uint;
pub type __nlink_t = c_types::c_ulong;
pub type __off_t = c_types::c_long;
pub type __off64_t = c_types::c_long;
pub type __pid_t = c_types::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __fsid_t {
    pub __val: [c_types::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = c_types::c_long;
pub type __rlim_t = c_types::c_ulong;
pub type __rlim64_t = c_types::c_ulong;
pub type __id_t = c_types::c_uint;
pub type __time_t = c_types::c_long;
pub type __useconds_t = c_types::c_uint;
pub type __suseconds_t = c_types::c_long;
pub type __daddr_t = c_types::c_int;
pub type __key_t = c_types::c_int;
pub type __clockid_t = c_types::c_int;
pub type __timer_t = *mut c_types::c_void;
pub type __blksize_t = c_types::c_long;
pub type __blkcnt_t = c_types::c_long;
pub type __blkcnt64_t = c_types::c_long;
pub type __fsblkcnt_t = c_types::c_ulong;
pub type __fsblkcnt64_t = c_types::c_ulong;
pub type __fsfilcnt_t = c_types::c_ulong;
pub type __fsfilcnt64_t = c_types::c_ulong;
pub type __fsword_t = c_types::c_long;
pub type __ssize_t = c_types::c_long;
pub type __syscall_slong_t = c_types::c_long;
pub type __syscall_ulong_t = c_types::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut c_types::c_char;
pub type __intptr_t = c_types::c_long;
pub type __socklen_t = c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: c_types::c_int,
    pub __wait_terminated: wait__bindgen_ty_1,
    pub __wait_stopped: wait__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn __w_termsig(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set___w_termsig(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn __w_coredump(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___w_coredump(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __w_retcode(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___w_retcode(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __w_termsig: c_types::c_uint,
        __w_coredump: c_types::c_uint,
        __w_retcode: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let __w_termsig: u32 = unsafe { ::core::mem::transmute(__w_termsig) };
            __w_termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let __w_coredump: u32 = unsafe { ::core::mem::transmute(__w_coredump) };
            __w_coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let __w_retcode: u32 = unsafe { ::core::mem::transmute(__w_retcode) };
            __w_retcode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn __w_stopval(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___w_stopval(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __w_stopsig(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___w_stopsig(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __w_stopval: c_types::c_uint,
        __w_stopsig: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let __w_stopval: u32 = unsafe { ::core::mem::transmute(__w_stopval) };
            __w_stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let __w_stopsig: u32 = unsafe { ::core::mem::transmute(__w_stopsig) };
            __w_stopsig as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(
        ::core::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::core::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wait>())).w_status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(w_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wait>())).__wait_terminated as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(__wait_terminated)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wait>())).__wait_stopped as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(__wait_stopped)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __WAIT_STATUS {
    pub __uptr: *mut wait,
    pub __iptr: *mut c_types::c_int,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout___WAIT_STATUS() {
    assert_eq!(
        ::core::mem::size_of::<__WAIT_STATUS>(),
        8usize,
        concat!("Size of: ", stringify!(__WAIT_STATUS))
    );
    assert_eq!(
        ::core::mem::align_of::<__WAIT_STATUS>(),
        8usize,
        concat!("Alignment of ", stringify!(__WAIT_STATUS))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__WAIT_STATUS>())).__uptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__WAIT_STATUS),
            "::",
            stringify!(__uptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__WAIT_STATUS>())).__iptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__WAIT_STATUS),
            "::",
            stringify!(__iptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct div_t {
    pub quot: c_types::c_int,
    pub rem: c_types::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::core::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::core::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ldiv_t {
    pub quot: c_types::c_long,
    pub rem: c_types::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::core::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lldiv_t {
    pub quot: c_types::c_longlong,
    pub rem: c_types::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::core::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const c_types::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const c_types::c_char) -> c_types::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const c_types::c_char) -> c_types::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const c_types::c_char, __endptr: *mut *mut c_types::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const c_types::c_char, __endptr: *mut *mut c_types::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const c_types::c_char, __endptr: *mut *mut c_types::c_char) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const c_types::c_char,
        __endptr: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const c_types::c_char,
        __endptr: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const c_types::c_char,
        __endptr: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const c_types::c_char,
        __endptr: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const c_types::c_char,
        __endptr: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const c_types::c_char,
        __endptr: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: c_types::c_long) -> *mut c_types::c_char;
}
extern "C" {
    pub fn a64l(__s: *const c_types::c_char) -> c_types::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = c_types::c_ulong;
pub type ushort = c_types::c_ushort;
pub type uint = c_types::c_uint;
pub type u_int8_t = c_types::c_uchar;
pub type u_int16_t = c_types::c_ushort;
pub type u_int32_t = c_types::c_uint;
pub type u_int64_t = c_types::c_ulong;
pub type register_t = c_types::c_long;
pub type __sig_atomic_t = c_types::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigset_t {
    pub __val: [c_types::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::core::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = c_types::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::core::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: c_types::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: c_types::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: c_types::c_ulonglong) -> c_types::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: c_types::c_ulonglong) -> c_types::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(
        __major: c_types::c_uint,
        __minor: c_types::c_uint,
    ) -> c_types::c_ulonglong;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = c_types::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [c_types::c_char; 56usize],
    pub __align: c_types::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: pthread_mutex_t___pthread_mutex_s,
    pub __size: [c_types::c_char; 40usize],
    pub __align: c_types::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: c_types::c_int,
    pub __count: c_types::c_uint,
    pub __owner: c_types::c_int,
    pub __nusers: c_types::c_uint,
    pub __kind: c_types::c_int,
    pub __spins: c_types::c_short,
    pub __elision: c_types::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(
        ::core::mem::size_of::<pthread_mutex_t___pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t___pthread_mutex_s))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutex_t___pthread_mutex_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pthread_mutex_t___pthread_mutex_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__lock as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__count as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__owner as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__nusers as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__kind as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__spins as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__elision as *const _
                as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__list as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [c_types::c_char; 4usize],
    pub __align: c_types::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: pthread_cond_t__bindgen_ty_1,
    pub __size: [c_types::c_char; 48usize],
    pub __align: c_types::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: c_types::c_int,
    pub __futex: c_types::c_uint,
    pub __total_seq: c_types::c_ulonglong,
    pub __wakeup_seq: c_types::c_ulonglong,
    pub __woken_seq: c_types::c_ulonglong,
    pub __mutex: *mut c_types::c_void,
    pub __nwaiters: c_types::c_uint,
    pub __broadcast_seq: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<pthread_cond_t__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_cond_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__lock as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__futex as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__total_seq as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__total_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__wakeup_seq as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__wakeup_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__woken_seq as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__woken_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__mutex as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__mutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__nwaiters as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__nwaiters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__broadcast_seq as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__broadcast_seq)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [c_types::c_char; 4usize],
    pub __align: c_types::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = c_types::c_uint;
pub type pthread_once_t = c_types::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: pthread_rwlock_t__bindgen_ty_1,
    pub __size: [c_types::c_char; 56usize],
    pub __align: c_types::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __lock: c_types::c_int,
    pub __nr_readers: c_types::c_uint,
    pub __readers_wakeup: c_types::c_uint,
    pub __writer_wakeup: c_types::c_uint,
    pub __nr_readers_queued: c_types::c_uint,
    pub __nr_writers_queued: c_types::c_uint,
    pub __writer: c_types::c_int,
    pub __shared: c_types::c_int,
    pub __rwelision: c_types::c_schar,
    pub __pad1: [c_types::c_uchar; 7usize],
    pub __pad2: c_types::c_ulong,
    pub __flags: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__lock as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__nr_readers as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__nr_readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__readers_wakeup as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__readers_wakeup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__writer_wakeup as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__writer_wakeup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__nr_readers_queued
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__nr_readers_queued)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__nr_writers_queued
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__nr_writers_queued)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__writer as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__shared as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__rwelision as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__pad1 as *const _ as usize
        },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__pad2 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__flags as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__flags)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [c_types::c_char; 8usize],
    pub __align: c_types::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = c_types::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [c_types::c_char; 32usize],
    pub __align: c_types::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [c_types::c_char; 4usize],
    pub __align: c_types::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> c_types::c_long;
}
extern "C" {
    pub fn srandom(__seed: c_types::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: c_types::c_uint,
        __statebuf: *mut c_types::c_char,
        __statelen: size_t,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut c_types::c_char) -> *mut c_types::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: c_types::c_int,
    pub rand_deg: c_types::c_int,
    pub rand_sep: c_types::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::core::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::core::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> c_types::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: c_types::c_uint, __buf: *mut random_data) -> c_types::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: c_types::c_uint,
        __statebuf: *mut c_types::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut c_types::c_char, __buf: *mut random_data) -> c_types::c_int;
}
extern "C" {
    pub fn rand() -> c_types::c_int;
}
extern "C" {
    pub fn srand(__seed: c_types::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut c_types::c_uint) -> c_types::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut c_types::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> c_types::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut c_types::c_ushort) -> c_types::c_long;
}
extern "C" {
    pub fn mrand48() -> c_types::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut c_types::c_ushort) -> c_types::c_long;
}
extern "C" {
    pub fn srand48(__seedval: c_types::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut c_types::c_ushort) -> *mut c_types::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut c_types::c_ushort);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drand48_data {
    pub __x: [c_types::c_ushort; 3usize],
    pub __old_x: [c_types::c_ushort; 3usize],
    pub __c: c_types::c_ushort,
    pub __init: c_types::c_ushort,
    pub __a: c_types::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::core::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::core::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> c_types::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut c_types::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data, __result: *mut c_types::c_long)
        -> c_types::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut c_types::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut c_types::c_long,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data, __result: *mut c_types::c_long)
        -> c_types::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut c_types::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut c_types::c_long,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: c_types::c_long, __buffer: *mut drand48_data) -> c_types::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut c_types::c_ushort,
        __buffer: *mut drand48_data,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut c_types::c_ushort,
        __buffer: *mut drand48_data,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn malloc(__size: c_types::c_ulong) -> *mut c_types::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: c_types::c_ulong, __size: c_types::c_ulong) -> *mut c_types::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut c_types::c_void, __size: c_types::c_ulong) -> *mut c_types::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut c_types::c_void);
}
extern "C" {
    pub fn cfree(__ptr: *mut c_types::c_void);
}
extern "C" {
    pub fn alloca(__size: c_types::c_ulong) -> *mut c_types::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut c_types::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut c_types::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut c_types::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> c_types::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> c_types::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(__status: c_types::c_int, __arg: *mut c_types::c_void),
        >,
        __arg: *mut c_types::c_void,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn exit(__status: c_types::c_int);
}
extern "C" {
    pub fn quick_exit(__status: c_types::c_int);
}
extern "C" {
    pub fn _Exit(__status: c_types::c_int);
}
extern "C" {
    pub fn getenv(__name: *const c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const c_types::c_char,
        __value: *const c_types::c_char,
        __replace: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn clearenv() -> c_types::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut c_types::c_char,
        __suffixlen: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn system(__command: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const c_types::c_char,
        __resolved: *mut c_types::c_char,
    ) -> *mut c_types::c_char;
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const c_types::c_void,
        arg2: *const c_types::c_void,
    ) -> c_types::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const c_types::c_void,
        __base: *const c_types::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut c_types::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn labs(__x: c_types::c_long) -> c_types::c_long;
}
extern "C" {
    pub fn llabs(__x: c_types::c_longlong) -> c_types::c_longlong;
}
extern "C" {
    pub fn div(__numer: c_types::c_int, __denom: c_types::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: c_types::c_long, __denom: c_types::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: c_types::c_longlong, __denom: c_types::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: c_types::c_int,
        __decpt: *mut c_types::c_int,
        __sign: *mut c_types::c_int,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: c_types::c_int,
        __decpt: *mut c_types::c_int,
        __sign: *mut c_types::c_int,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: c_types::c_int,
        __buf: *mut c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: c_types::c_int,
        __decpt: *mut c_types::c_int,
        __sign: *mut c_types::c_int,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: c_types::c_int,
        __decpt: *mut c_types::c_int,
        __sign: *mut c_types::c_int,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: c_types::c_int,
        __buf: *mut c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: c_types::c_int,
        __decpt: *mut c_types::c_int,
        __sign: *mut c_types::c_int,
        __buf: *mut c_types::c_char,
        __len: size_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: c_types::c_int,
        __decpt: *mut c_types::c_int,
        __sign: *mut c_types::c_int,
        __buf: *mut c_types::c_char,
        __len: size_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: c_types::c_int,
        __decpt: *mut c_types::c_int,
        __sign: *mut c_types::c_int,
        __buf: *mut c_types::c_char,
        __len: size_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: c_types::c_int,
        __decpt: *mut c_types::c_int,
        __sign: *mut c_types::c_int,
        __buf: *mut c_types::c_char,
        __len: size_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn mblen(__s: *const c_types::c_char, __n: size_t) -> c_types::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const c_types::c_char, __n: size_t) -> c_types::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut c_types::c_char, __wchar: wchar_t) -> c_types::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const c_types::c_char, __n: size_t) -> size_t;
}
extern "C" {
    pub fn wcstombs(__s: *mut c_types::c_char, __pwcs: *const wchar_t, __n: size_t) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut c_types::c_char,
        __tokens: *const *mut c_types::c_char,
        __valuep: *mut *mut c_types::c_char,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut c_types::c_void,
        __src: *const c_types::c_void,
        __n: c_types::c_ulong,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut c_types::c_void,
        __src: *const c_types::c_void,
        __n: c_types::c_ulong,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut c_types::c_void,
        __src: *const c_types::c_void,
        __c: c_types::c_int,
        __n: size_t,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut c_types::c_void,
        __c: c_types::c_int,
        __n: c_types::c_ulong,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const c_types::c_void,
        __s2: *const c_types::c_void,
        __n: c_types::c_ulong,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const c_types::c_void,
        __c: c_types::c_int,
        __n: c_types::c_ulong,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut c_types::c_char,
        __src: *const c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut c_types::c_char,
        __src: *const c_types::c_char,
        __n: c_types::c_ulong,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut c_types::c_char,
        __src: *const c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut c_types::c_char,
        __src: *const c_types::c_char,
        __n: c_types::c_ulong,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const c_types::c_char, __s2: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const c_types::c_char,
        __s2: *const c_types::c_char,
        __n: c_types::c_ulong,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const c_types::c_char, __s2: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut c_types::c_char,
        __src: *const c_types::c_char,
        __n: c_types::c_ulong,
    ) -> c_types::c_ulong;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const c_types::c_ushort,
    pub __ctype_tolower: *const c_types::c_int,
    pub __ctype_toupper: *const c_types::c_int,
    pub __names: [*const c_types::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::core::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const c_types::c_char,
        __s2: *const c_types::c_char,
        __l: __locale_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut c_types::c_char,
        __src: *const c_types::c_char,
        __n: size_t,
        __l: __locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strndup(__string: *const c_types::c_char, __n: c_types::c_ulong)
        -> *mut c_types::c_char;
}
extern "C" {
    pub fn strchr(__s: *const c_types::c_char, __c: c_types::c_int) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const c_types::c_char, __c: c_types::c_int) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const c_types::c_char,
        __reject: *const c_types::c_char,
    ) -> c_types::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const c_types::c_char,
        __accept: *const c_types::c_char,
    ) -> c_types::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const c_types::c_char,
        __accept: *const c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const c_types::c_char,
        __needle: *const c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut c_types::c_char,
        __delim: *const c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut c_types::c_char,
        __delim: *const c_types::c_char,
        __save_ptr: *mut *mut c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut c_types::c_char,
        __delim: *const c_types::c_char,
        __save_ptr: *mut *mut c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strlen(__s: *const c_types::c_char) -> c_types::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const c_types::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: c_types::c_int) -> *mut c_types::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: c_types::c_int,
        __buf: *mut c_types::c_char,
        __buflen: size_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: c_types::c_int, __l: __locale_t) -> *mut c_types::c_char;
}
extern "C" {
    pub fn __bzero(__s: *mut c_types::c_void, __n: size_t);
}
extern "C" {
    pub fn bcopy(__src: *const c_types::c_void, __dest: *mut c_types::c_void, __n: size_t);
}
extern "C" {
    pub fn bzero(__s: *mut c_types::c_void, __n: c_types::c_ulong);
}
extern "C" {
    pub fn bcmp(
        __s1: *const c_types::c_void,
        __s2: *const c_types::c_void,
        __n: size_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn index(__s: *const c_types::c_char, __c: c_types::c_int) -> *mut c_types::c_char;
}
extern "C" {
    pub fn rindex(__s: *const c_types::c_char, __c: c_types::c_int) -> *mut c_types::c_char;
}
extern "C" {
    pub fn ffs(__i: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const c_types::c_char, __s2: *const c_types::c_char)
        -> c_types::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const c_types::c_char,
        __s2: *const c_types::c_char,
        __n: c_types::c_ulong,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut c_types::c_char,
        __delim: *const c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn strsignal(__sig: c_types::c_int) -> *mut c_types::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut c_types::c_char,
        __src: *const c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut c_types::c_char,
        __src: *const c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut c_types::c_char,
        __src: *const c_types::c_char,
        __n: size_t,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut c_types::c_char,
        __src: *const c_types::c_char,
        __n: c_types::c_ulong,
    ) -> *mut c_types::c_char;
}
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: c_types::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: c_types::c_uint,
    pub __wchb: [c_types::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::core::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::core::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = c_types::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: c_types::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::core::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_marker>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_marker>()))._pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
pub const __codecvt_result___codecvt_ok: __codecvt_result = 0;
pub const __codecvt_result___codecvt_partial: __codecvt_result = 1;
pub const __codecvt_result___codecvt_error: __codecvt_result = 2;
pub const __codecvt_result___codecvt_noconv: __codecvt_result = 3;
pub type __codecvt_result = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: c_types::c_int,
    pub _IO_read_ptr: *mut c_types::c_char,
    pub _IO_read_end: *mut c_types::c_char,
    pub _IO_read_base: *mut c_types::c_char,
    pub _IO_write_base: *mut c_types::c_char,
    pub _IO_write_ptr: *mut c_types::c_char,
    pub _IO_write_end: *mut c_types::c_char,
    pub _IO_buf_base: *mut c_types::c_char,
    pub _IO_buf_end: *mut c_types::c_char,
    pub _IO_save_base: *mut c_types::c_char,
    pub _IO_backup_base: *mut c_types::c_char,
    pub _IO_save_end: *mut c_types::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: c_types::c_int,
    pub _flags2: c_types::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: c_types::c_ushort,
    pub _vtable_offset: c_types::c_schar,
    pub _shortbuf: [c_types::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut c_types::c_void,
    pub __pad2: *mut c_types::c_void,
    pub __pad3: *mut c_types::c_void,
    pub __pad4: *mut c_types::c_void,
    pub __pad5: size_t,
    pub _mode: c_types::c_int,
    pub _unused2: [c_types::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::core::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut c_types::c_void,
        __buf: *mut c_types::c_char,
        __nbytes: size_t,
    ) -> __ssize_t,
>;
pub type __io_write_fn = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut c_types::c_void,
        __buf: *const c_types::c_char,
        __n: size_t,
    ) -> __ssize_t,
>;
pub type __io_seek_fn = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut c_types::c_void,
        __pos: *mut __off64_t,
        __w: c_types::c_int,
    ) -> c_types::c_int,
>;
pub type __io_close_fn =
    ::core::option::Option<unsafe extern "C" fn(__cookie: *mut c_types::c_void) -> c_types::c_int>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> c_types::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> c_types::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: c_types::c_int, __fp: *mut _IO_FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const c_types::c_char,
        arg3: *mut __va_list_tag,
        arg4: *mut c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(
        arg1: *mut _IO_FILE,
        arg2: *const c_types::c_char,
        arg3: *mut __va_list_tag,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: c_types::c_int, arg3: __ssize_t) -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut c_types::c_void, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn _IO_seekoff(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: c_types::c_int,
        arg4: c_types::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t, arg3: c_types::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type fpos_t = _G_fpos_t;
extern "C" {
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn rename(__old: *const c_types::c_char, __new: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: c_types::c_int,
        __old: *const c_types::c_char,
        __newfd: c_types::c_int,
        __new: *const c_types::c_char,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const c_types::c_char,
        __pfx: *const c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const c_types::c_char, __modes: *const c_types::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const c_types::c_char,
        __modes: *const c_types::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: c_types::c_int, __modes: *const c_types::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut c_types::c_void,
        __len: size_t,
        __modes: *const c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut c_types::c_char, __sizeloc: *mut size_t)
        -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut c_types::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut c_types::c_char,
        __modes: c_types::c_int,
        __n: size_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut c_types::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE, __format: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn printf(__format: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut c_types::c_char,
        __format: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const c_types::c_char,
        __arg: *mut __va_list_tag,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const c_types::c_char, __arg: *mut __va_list_tag) -> c_types::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut c_types::c_char,
        __format: *const c_types::c_char,
        __arg: *mut __va_list_tag,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut c_types::c_char,
        __maxlen: c_types::c_ulong,
        __format: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut c_types::c_char,
        __maxlen: c_types::c_ulong,
        __format: *const c_types::c_char,
        __arg: *mut __va_list_tag,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: c_types::c_int,
        __fmt: *const c_types::c_char,
        __arg: *mut __va_list_tag,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn dprintf(__fd: c_types::c_int, __fmt: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE, __format: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn scanf(__format: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const c_types::c_char,
        __format: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE, __format: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const c_types::c_char,
        __format: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const c_types::c_char,
        __arg: *mut __va_list_tag,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const c_types::c_char, __arg: *mut __va_list_tag) -> c_types::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const c_types::c_char,
        __format: *const c_types::c_char,
        __arg: *mut __va_list_tag,
    ) -> c_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const c_types::c_char,
        __arg: *mut __va_list_tag,
    ) -> c_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(__format: *const c_types::c_char, __arg: *mut __va_list_tag) -> c_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const c_types::c_char,
        __format: *const c_types::c_char,
        __arg: *mut __va_list_tag,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn getchar() -> c_types::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> c_types::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fputc(__c: c_types::c_int, __stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn putc(__c: c_types::c_int, __stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn putchar(__c: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: c_types::c_int, __stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: c_types::c_int, __stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn putw(__w: c_types::c_int, __stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut c_types::c_char,
        __n: c_types::c_int,
        __stream: *mut FILE,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut c_types::c_char,
        __n: *mut size_t,
        __delimiter: c_types::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut c_types::c_char,
        __n: *mut size_t,
        __delimiter: c_types::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut c_types::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const c_types::c_char, __stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn puts(__s: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn ungetc(__c: c_types::c_int, __stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut c_types::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const c_types::c_void,
        __size: size_t,
        __n: size_t,
        __s: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut c_types::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const c_types::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: c_types::c_long,
        __whence: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> c_types::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> c_types::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> c_types::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn perror(__s: *const c_types::c_char);
}
extern "C" {
    pub static mut sys_nerr: c_types::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const c_types::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn popen(__command: *const c_types::c_char, __modes: *const c_types::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn sl_wfx_init(context: *mut sl_wfx_context_t) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_deinit() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_enable_irq() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_disable_irq() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_shutdown() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_receive_frame(ctrl_reg: *mut u16) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_send_configuration(
        pds_data: *const c_types::c_char,
        pds_data_length: u32,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_control_gpio(gpio_label: u8, gpio_mode: u8, value: *mut u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_pta_settings(
        pta_mode: u8,
        request_signal_active_level: u8,
        priority_signal_active_level: u8,
        freq_signal_active_level: u8,
        grant_signal_active_level: u8,
        coex_type: u8,
        default_grant_state: u8,
        simultaneous_rx_access: u8,
        priority_sampling_time: u8,
        tx_rx_sampling_time: u8,
        freq_sampling_time: u8,
        grant_valid_time: u8,
        fem_control_time: u8,
        first_slot_time: u8,
        periodic_tx_rx_sampling_time: u16,
        coex_quota: u16,
        wlan_quota: u16,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_pta_priority(priority: u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_pta_state(pta_state: u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_prevent_rollback(magic_word: u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_get_opn(opn: *mut *mut u8) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_get_status_code(wfx_status: u32, command_id: u8) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_send_ethernet_frame(
        frame: *mut sl_wfx_send_frame_req_t,
        data_length: u32,
        interface: sl_wfx_interface_t,
        priority: u8,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_send_command(
        command_id: u8,
        data: *mut c_types::c_void,
        data_size: u32,
        interface: sl_wfx_interface_t,
        response: *mut *mut sl_wfx_generic_confirmation_t,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_send_request(
        id: u8,
        request: *mut sl_wfx_generic_message_t,
        request_length: u16,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_access_mode_message() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_mac_address(
        mac: *const sl_wfx_mac_address_t,
        interface: sl_wfx_interface_t,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_power_mode(mode: sl_wfx_pm_mode_t, interval: u16) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_wake_up_bit(state: u8) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_enable_device_power_save() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_disable_device_power_save() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_join_ibss_command(
        ssid: *const u8,
        ssid_length: u32,
        channel: u32,
        security_mode: u16,
        passkey: *const u8,
        passkey_length: u16,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_leave_ibss_command() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_get_signal_strength(rcpi: *mut u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_add_multicast_address(
        mac_address: *const sl_wfx_mac_address_t,
        interface: sl_wfx_interface_t,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_remove_multicast_address(
        mac_address: *const sl_wfx_mac_address_t,
        interface: sl_wfx_interface_t,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_arp_ip_address(arp_ip_addr: *mut u32, num_arp_ip_addr: u8) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_ns_ip_address(ns_ip_addr: *mut u8, num_ns_ip_addr: u8) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_broadcast_filter(filter: u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_unicast_filter(filter: u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_add_whitelist_address(mac_address: *const sl_wfx_mac_address_t) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_add_blacklist_address(mac_address: *const sl_wfx_mac_address_t) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_max_ap_client(max_clients: u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_max_ap_client_inactivity(inactivity_timeout: u32) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_scan_parameters(
        active_channel_time: u16,
        passive_channel_time: u16,
        num_probe_requestuests: u16,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_roam_parameters(
        rcpi_threshold: u8,
        rcpi_hysteresis: u8,
        beacon_lost_count: u8,
        channel_list: *const u8,
        channel_list_count: u8,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_tx_rate_parameters(
        rate_set_bitmask: sl_wfx_rate_set_bitmask_t,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_max_tx_power(max_tx_power: i32, interface: sl_wfx_interface_t)
        -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_get_max_tx_power(
        max_tx_power_rf_port_1: *mut i32,
        max_tx_power_rf_port_2: *mut i32,
        interface: sl_wfx_interface_t,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_get_pmk(
        password: *mut u8,
        password_length: *mut u32,
        interface: sl_wfx_interface_t,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_get_ap_client_signal_strength(
        client: *const sl_wfx_mac_address_t,
        signal_strength: *mut u32,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_send_join_command(
        ssid: *const u8,
        ssid_length: u32,
        bssid: *const sl_wfx_mac_address_t,
        channel: u16,
        security_mode: sl_wfx_security_mode_t,
        prevent_roaming: u8,
        management_frame_protection: u16,
        passkey: *const u8,
        passkey_length: u16,
        ie_data: *const u8,
        ie_data_length: u16,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_send_disconnect_command() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_send_scan_command(
        scan_mode: u16,
        channel_list: *const u8,
        channel_list_count: u16,
        ssid_list: *const sl_wfx_ssid_def_t,
        ssid_list_count: u16,
        ie_data: *const u8,
        ie_data_length: u16,
        bssid: *const u8,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_send_stop_scan_command() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_start_ap_command(
        channel: u16,
        ssid: *mut u8,
        ssid_length: u32,
        hidden_ssid: u8,
        client_isolation: u8,
        security_mode: sl_wfx_security_mode_t,
        management_frame_protection: u8,
        passkey: *const u8,
        passkey_length: u16,
        beacon_ie_data: *const u8,
        beacon_ie_data_length: u16,
        probe_response_ie_data: *const u8,
        probe_response_ie_data_length: u16,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_update_ap_command(
        beacon_ie_data_length: u16,
        probe_response_ie_data_length: u16,
        beacon_ie_data: *mut u32,
        probe_response_ie_data: *mut u32,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_stop_ap_command() -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_disconnect_ap_client_command(client: *const sl_wfx_mac_address_t) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_set_antenna_config(config: sl_wfx_antenna_config_t) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_allocate_command_buffer(
        buffer: *mut *mut sl_wfx_generic_message_t,
        command_id: u32,
        type_: sl_wfx_buffer_type_t,
        buffer_size: u32,
    ) -> sl_status_t;
}
extern "C" {
    pub fn sl_wfx_free_command_buffer(
        buffer: *mut sl_wfx_generic_message_t,
        command_id: u32,
        type_: sl_wfx_buffer_type_t,
    ) -> sl_status_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: c_types::c_uint,
    pub fp_offset: c_types::c_uint,
    pub overflow_arg_area: *mut c_types::c_void,
    pub reg_save_area: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
