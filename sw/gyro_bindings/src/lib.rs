#![no_std]
#![allow(nonstandard_style)]
extern crate c_types;
/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201505;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 23;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 32;
pub const _BITS_WCHAR_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 2147483647;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const _MATH_H_MATHDEF: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const PROPERTY_DISABLE: u32 = 0;
pub const PROPERTY_ENABLE: u32 = 1;
pub const LSM6DS3_I2C_ADD_L: u32 = 213;
pub const LSM6DS3_I2C_ADD_H: u32 = 215;
pub const LSM6DS3_ID: u32 = 105;
pub const LSM6DS3_FUNC_CFG_ACCESS: u32 = 1;
pub const LSM6DS3_SENSOR_SYNC_TIME_FRAME: u32 = 4;
pub const LSM6DS3_FIFO_CTRL1: u32 = 6;
pub const LSM6DS3_FIFO_CTRL2: u32 = 7;
pub const LSM6DS3_FIFO_CTRL3: u32 = 8;
pub const LSM6DS3_FIFO_CTRL4: u32 = 9;
pub const LSM6DS3_FIFO_CTRL5: u32 = 10;
pub const LSM6DS3_ORIENT_CFG_G: u32 = 11;
pub const LSM6DS3_INT1_CTRL: u32 = 13;
pub const LSM6DS3_INT2_CTRL: u32 = 14;
pub const LSM6DS3_WHO_AM_I: u32 = 15;
pub const LSM6DS3_CTRL1_XL: u32 = 16;
pub const LSM6DS3_CTRL2_G: u32 = 17;
pub const LSM6DS3_CTRL3_C: u32 = 18;
pub const LSM6DS3_CTRL4_C: u32 = 19;
pub const LSM6DS3_CTRL5_C: u32 = 20;
pub const LSM6DS3_CTRL6_C: u32 = 21;
pub const LSM6DS3_CTRL7_G: u32 = 22;
pub const LSM6DS3_CTRL8_XL: u32 = 23;
pub const LSM6DS3_CTRL9_XL: u32 = 24;
pub const LSM6DS3_CTRL10_C: u32 = 25;
pub const LSM6DS3_MASTER_CONFIG: u32 = 26;
pub const LSM6DS3_WAKE_UP_SRC: u32 = 27;
pub const LSM6DS3_TAP_SRC: u32 = 28;
pub const LSM6DS3_D6D_SRC: u32 = 29;
pub const LSM6DS3_STATUS_REG: u32 = 30;
pub const LSM6DS3_OUT_TEMP_L: u32 = 32;
pub const LSM6DS3_OUT_TEMP_H: u32 = 33;
pub const LSM6DS3_OUTX_L_G: u32 = 34;
pub const LSM6DS3_OUTX_H_G: u32 = 35;
pub const LSM6DS3_OUTY_L_G: u32 = 36;
pub const LSM6DS3_OUTY_H_G: u32 = 37;
pub const LSM6DS3_OUTZ_L_G: u32 = 38;
pub const LSM6DS3_OUTZ_H_G: u32 = 39;
pub const LSM6DS3_OUTX_L_XL: u32 = 40;
pub const LSM6DS3_OUTX_H_XL: u32 = 41;
pub const LSM6DS3_OUTY_L_XL: u32 = 42;
pub const LSM6DS3_OUTY_H_XL: u32 = 43;
pub const LSM6DS3_OUTZ_L_XL: u32 = 44;
pub const LSM6DS3_OUTZ_H_XL: u32 = 45;
pub const LSM6DS3_SENSORHUB1_REG: u32 = 46;
pub const LSM6DS3_SENSORHUB2_REG: u32 = 47;
pub const LSM6DS3_SENSORHUB3_REG: u32 = 48;
pub const LSM6DS3_SENSORHUB4_REG: u32 = 49;
pub const LSM6DS3_SENSORHUB5_REG: u32 = 50;
pub const LSM6DS3_SENSORHUB6_REG: u32 = 51;
pub const LSM6DS3_SENSORHUB7_REG: u32 = 52;
pub const LSM6DS3_SENSORHUB8_REG: u32 = 53;
pub const LSM6DS3_SENSORHUB9_REG: u32 = 54;
pub const LSM6DS3_SENSORHUB10_REG: u32 = 55;
pub const LSM6DS3_SENSORHUB11_REG: u32 = 56;
pub const LSM6DS3_SENSORHUB12_REG: u32 = 57;
pub const LSM6DS3_FIFO_STATUS1: u32 = 58;
pub const LSM6DS3_FIFO_STATUS2: u32 = 59;
pub const LSM6DS3_FIFO_STATUS3: u32 = 60;
pub const LSM6DS3_FIFO_STATUS4: u32 = 61;
pub const LSM6DS3_FIFO_DATA_OUT_L: u32 = 62;
pub const LSM6DS3_FIFO_DATA_OUT_H: u32 = 63;
pub const LSM6DS3_TIMESTAMP0_REG: u32 = 64;
pub const LSM6DS3_TIMESTAMP1_REG: u32 = 65;
pub const LSM6DS3_TIMESTAMP2_REG: u32 = 66;
pub const LSM6DS3_STEP_TIMESTAMP_L: u32 = 73;
pub const LSM6DS3_STEP_TIMESTAMP_H: u32 = 74;
pub const LSM6DS3_STEP_COUNTER_L: u32 = 75;
pub const LSM6DS3_STEP_COUNTER_H: u32 = 76;
pub const LSM6DS3_SENSORHUB13_REG: u32 = 77;
pub const LSM6DS3_SENSORHUB14_REG: u32 = 78;
pub const LSM6DS3_SENSORHUB15_REG: u32 = 79;
pub const LSM6DS3_SENSORHUB16_REG: u32 = 80;
pub const LSM6DS3_SENSORHUB17_REG: u32 = 81;
pub const LSM6DS3_SENSORHUB18_REG: u32 = 82;
pub const LSM6DS3_FUNC_SRC: u32 = 83;
pub const LSM6DS3_TAP_CFG: u32 = 88;
pub const LSM6DS3_TAP_THS_6D: u32 = 89;
pub const LSM6DS3_INT_DUR2: u32 = 90;
pub const LSM6DS3_WAKE_UP_THS: u32 = 91;
pub const LSM6DS3_WAKE_UP_DUR: u32 = 92;
pub const LSM6DS3_FREE_FALL: u32 = 93;
pub const LSM6DS3_MD1_CFG: u32 = 94;
pub const LSM6DS3_MD2_CFG: u32 = 95;
pub const LSM6DS3_OUT_MAG_RAW_X_L: u32 = 102;
pub const LSM6DS3_OUT_MAG_RAW_X_H: u32 = 103;
pub const LSM6DS3_OUT_MAG_RAW_Y_L: u32 = 104;
pub const LSM6DS3_OUT_MAG_RAW_Y_H: u32 = 105;
pub const LSM6DS3_OUT_MAG_RAW_Z_L: u32 = 106;
pub const LSM6DS3_OUT_MAG_RAW_Z_H: u32 = 107;
pub const LSM6DS3_SLV0_ADD: u32 = 2;
pub const LSM6DS3_SLV0_SUBADD: u32 = 3;
pub const LSM6DS3_SLAVE0_CONFIG: u32 = 4;
pub const LSM6DS3_SLV1_ADD: u32 = 5;
pub const LSM6DS3_SLV1_SUBADD: u32 = 6;
pub const LSM6DS3_SLAVE1_CONFIG: u32 = 7;
pub const LSM6DS3_SLV2_ADD: u32 = 8;
pub const LSM6DS3_SLV2_SUBADD: u32 = 9;
pub const LSM6DS3_SLAVE2_CONFIG: u32 = 10;
pub const LSM6DS3_SLV3_ADD: u32 = 11;
pub const LSM6DS3_SLV3_SUBADD: u32 = 12;
pub const LSM6DS3_SLAVE3_CONFIG: u32 = 13;
pub const LSM6DS3_DATAWRITE_SRC_MODE_SUB_SLV0: u32 = 14;
pub const LSM6DS3_PEDO_THS_REG: u32 = 15;
pub const LSM6DS3_SM_THS: u32 = 19;
pub const LSM6DS3_PEDO_DEB_REG: u32 = 20;
pub const LSM6DS3_STEP_COUNT_DELTA: u32 = 21;
pub const LSM6DS3_MAG_SI_XX: u32 = 36;
pub const LSM6DS3_MAG_SI_XY: u32 = 37;
pub const LSM6DS3_MAG_SI_XZ: u32 = 38;
pub const LSM6DS3_MAG_SI_YX: u32 = 39;
pub const LSM6DS3_MAG_SI_YY: u32 = 40;
pub const LSM6DS3_MAG_SI_YZ: u32 = 41;
pub const LSM6DS3_MAG_SI_ZX: u32 = 42;
pub const LSM6DS3_MAG_SI_ZY: u32 = 43;
pub const LSM6DS3_MAG_SI_ZZ: u32 = 44;
pub const LSM6DS3_MAG_OFFX_L: u32 = 45;
pub const LSM6DS3_MAG_OFFX_H: u32 = 46;
pub const LSM6DS3_MAG_OFFY_L: u32 = 47;
pub const LSM6DS3_MAG_OFFY_H: u32 = 48;
pub const LSM6DS3_MAG_OFFZ_L: u32 = 49;
pub const LSM6DS3_MAG_OFFZ_H: u32 = 50;
pub type int_least8_t = c_types::c_schar;
pub type int_least16_t = c_types::c_short;
pub type int_least32_t = c_types::c_int;
pub type int_least64_t = c_types::c_longlong;
pub type uint_least8_t = c_types::c_uchar;
pub type uint_least16_t = c_types::c_ushort;
pub type uint_least32_t = c_types::c_uint;
pub type uint_least64_t = c_types::c_ulonglong;
pub type int_fast8_t = c_types::c_schar;
pub type int_fast16_t = c_types::c_int;
pub type int_fast32_t = c_types::c_int;
pub type int_fast64_t = c_types::c_longlong;
pub type uint_fast8_t = c_types::c_uchar;
pub type uint_fast16_t = c_types::c_uint;
pub type uint_fast32_t = c_types::c_uint;
pub type uint_fast64_t = c_types::c_ulonglong;
pub type intmax_t = c_types::c_longlong;
pub type uintmax_t = c_types::c_ulonglong;
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut c_types::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut c_types::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: c_types::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: c_types::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __isinf(__value: f64) -> c_types::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> c_types::c_int;
}
extern "C" {
    pub fn isinf(__value: f64) -> c_types::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> c_types::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const c_types::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const c_types::c_char) -> f64;
}
extern "C" {
    pub fn __isnan(__value: f64) -> c_types::c_int;
}
extern "C" {
    pub fn isnan(__value: f64) -> c_types::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: c_types::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: c_types::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: c_types::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: c_types::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut c_types::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut c_types::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: c_types::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: c_types::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> c_types::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> c_types::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: c_types::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: c_types::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut c_types::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut c_types::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> c_types::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> c_types::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> c_types::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> c_types::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> c_types::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> c_types::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> c_types::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> c_types::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fpclassify(__value: f64) -> c_types::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> c_types::c_int;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut c_types::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut c_types::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: c_types::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: c_types::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __isinff(__value: f32) -> c_types::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> c_types::c_int;
}
extern "C" {
    pub fn isinff(__value: f32) -> c_types::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> c_types::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const c_types::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const c_types::c_char) -> f32;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> c_types::c_int;
}
extern "C" {
    pub fn isnanf(__value: f32) -> c_types::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: c_types::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: c_types::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: c_types::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: c_types::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut c_types::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut c_types::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: f64) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: f64) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: c_types::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: c_types::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> c_types::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> c_types::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: c_types::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: c_types::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut c_types::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut c_types::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> c_types::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> c_types::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> c_types::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> c_types::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> c_types::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> c_types::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> c_types::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> c_types::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> c_types::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> c_types::c_int;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn acosl(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosl(__x: f64) -> f64;
}
extern "C" {
    pub fn asinl(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinl(__x: f64) -> f64;
}
extern "C" {
    pub fn atanl(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanl(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2l(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2l(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cosl(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosl(__x: f64) -> f64;
}
extern "C" {
    pub fn sinl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinl(__x: f64) -> f64;
}
extern "C" {
    pub fn tanl(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanl(__x: f64) -> f64;
}
extern "C" {
    pub fn coshl(__x: f64) -> f64;
}
extern "C" {
    pub fn __coshl(__x: f64) -> f64;
}
extern "C" {
    pub fn sinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn tanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn acoshl(__x: f64) -> f64;
}
extern "C" {
    pub fn __acoshl(__x: f64) -> f64;
}
extern "C" {
    pub fn asinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn atanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn expl(__x: f64) -> f64;
}
extern "C" {
    pub fn __expl(__x: f64) -> f64;
}
extern "C" {
    pub fn frexpl(__x: f64, __exponent: *mut c_types::c_int) -> f64;
}
extern "C" {
    pub fn __frexpl(__x: f64, __exponent: *mut c_types::c_int) -> f64;
}
extern "C" {
    pub fn ldexpl(__x: f64, __exponent: c_types::c_int) -> f64;
}
extern "C" {
    pub fn __ldexpl(__x: f64, __exponent: c_types::c_int) -> f64;
}
extern "C" {
    pub fn logl(__x: f64) -> f64;
}
extern "C" {
    pub fn __logl(__x: f64) -> f64;
}
extern "C" {
    pub fn log10l(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10l(__x: f64) -> f64;
}
extern "C" {
    pub fn modfl(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modfl(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1l(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1l(__x: f64) -> f64;
}
extern "C" {
    pub fn log1pl(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1pl(__x: f64) -> f64;
}
extern "C" {
    pub fn logbl(__x: f64) -> f64;
}
extern "C" {
    pub fn __logbl(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2l(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2l(__x: f64) -> f64;
}
extern "C" {
    pub fn log2l(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2l(__x: f64) -> f64;
}
extern "C" {
    pub fn powl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __powl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn hypotl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypotl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn ceill(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceill(__x: f64) -> f64;
}
extern "C" {
    pub fn fabsl(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabsl(__x: f64) -> f64;
}
extern "C" {
    pub fn floorl(__x: f64) -> f64;
}
extern "C" {
    pub fn __floorl(__x: f64) -> f64;
}
extern "C" {
    pub fn fmodl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmodl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __isinfl(__value: f64) -> c_types::c_int;
}
extern "C" {
    pub fn __finitel(__value: f64) -> c_types::c_int;
}
extern "C" {
    pub fn isinfl(__value: f64) -> c_types::c_int;
}
extern "C" {
    pub fn finitel(__value: f64) -> c_types::c_int;
}
extern "C" {
    pub fn dreml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __dreml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significandl(__x: f64) -> f64;
}
extern "C" {
    pub fn __significandl(__x: f64) -> f64;
}
extern "C" {
    pub fn copysignl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysignl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nanl(__tagb: *const c_types::c_char) -> f64;
}
extern "C" {
    pub fn __nanl(__tagb: *const c_types::c_char) -> f64;
}
extern "C" {
    pub fn __isnanl(__value: f64) -> c_types::c_int;
}
extern "C" {
    pub fn isnanl(__value: f64) -> c_types::c_int;
}
extern "C" {
    pub fn j0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn jnl(arg1: c_types::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jnl(arg1: c_types::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn ynl(arg1: c_types::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __ynl(arg1: c_types::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn gammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal_r(arg1: f64, __signgamp: *mut c_types::c_int) -> f64;
}
extern "C" {
    pub fn __lgammal_r(arg1: f64, __signgamp: *mut c_types::c_int) -> f64;
}
extern "C" {
    pub fn rintl(__x: f64) -> f64;
}
extern "C" {
    pub fn __rintl(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafterl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttowardl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nexttowardl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn remainderl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainderl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbnl(__x: f64, __n: c_types::c_int) -> f64;
}
extern "C" {
    pub fn __scalbnl(__x: f64, __n: c_types::c_int) -> f64;
}
extern "C" {
    pub fn ilogbl(__x: f64) -> c_types::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: f64) -> c_types::c_int;
}
extern "C" {
    pub fn scalblnl(__x: f64, __n: c_types::c_long) -> f64;
}
extern "C" {
    pub fn __scalblnl(__x: f64, __n: c_types::c_long) -> f64;
}
extern "C" {
    pub fn nearbyintl(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyintl(__x: f64) -> f64;
}
extern "C" {
    pub fn roundl(__x: f64) -> f64;
}
extern "C" {
    pub fn __roundl(__x: f64) -> f64;
}
extern "C" {
    pub fn truncl(__x: f64) -> f64;
}
extern "C" {
    pub fn __truncl(__x: f64) -> f64;
}
extern "C" {
    pub fn remquol(__x: f64, __y: f64, __quo: *mut c_types::c_int) -> f64;
}
extern "C" {
    pub fn __remquol(__x: f64, __y: f64, __quo: *mut c_types::c_int) -> f64;
}
extern "C" {
    pub fn lrintl(__x: f64) -> c_types::c_long;
}
extern "C" {
    pub fn __lrintl(__x: f64) -> c_types::c_long;
}
extern "C" {
    pub fn llrintl(__x: f64) -> c_types::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: f64) -> c_types::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: f64) -> c_types::c_long;
}
extern "C" {
    pub fn __lroundl(__x: f64) -> c_types::c_long;
}
extern "C" {
    pub fn llroundl(__x: f64) -> c_types::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: f64) -> c_types::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdiml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmaxl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fminl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fminl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyl(__value: f64) -> c_types::c_int;
}
extern "C" {
    pub fn __signbitl(__value: f64) -> c_types::c_int;
}
extern "C" {
    pub fn fmal(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fmal(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalbl(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalbl(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub static mut signgam: c_types::c_int;
}
pub const FP_NAN: _bindgen_ty_1 = 0;
pub const FP_INFINITE: _bindgen_ty_1 = 1;
pub const FP_ZERO: _bindgen_ty_1 = 2;
pub const FP_SUBNORMAL: _bindgen_ty_1 = 3;
pub const FP_NORMAL: _bindgen_ty_1 = 4;
pub type _bindgen_ty_1 = u32;
pub const _LIB_VERSION_TYPE__IEEE_: _LIB_VERSION_TYPE = -1;
pub const _LIB_VERSION_TYPE__SVID_: _LIB_VERSION_TYPE = 0;
pub const _LIB_VERSION_TYPE__XOPEN_: _LIB_VERSION_TYPE = 1;
pub const _LIB_VERSION_TYPE__POSIX_: _LIB_VERSION_TYPE = 2;
pub const _LIB_VERSION_TYPE__ISOC_: _LIB_VERSION_TYPE = 3;
pub type _LIB_VERSION_TYPE = i32;
extern "C" {
    pub static mut _LIB_VERSION: _LIB_VERSION_TYPE;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct exception {
    pub type_: c_types::c_int,
    pub name: *mut c_types::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout_exception() {
    assert_eq!(
        ::core::mem::size_of::<exception>(),
        32usize,
        concat!("Size of: ", stringify!(exception))
    );
    assert_eq!(
        ::core::mem::align_of::<exception>(),
        4usize,
        concat!("Alignment of ", stringify!(exception))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception>())).arg1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception>())).arg2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception>())).retval as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(retval)
        )
    );
}
extern "C" {
    pub fn matherr(__exc: *mut exception) -> c_types::c_int;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct bitwise_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_bitwise_t() {
    assert_eq!(
        ::core::mem::size_of::<bitwise_t>(),
        1usize,
        concat!("Size of: ", stringify!(bitwise_t))
    );
    assert_eq!(
        ::core::mem::align_of::<bitwise_t>(),
        1usize,
        concat!("Alignment of ", stringify!(bitwise_t))
    );
}
impl bitwise_t {
    #[inline]
    pub fn bit0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bit0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bit1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bit1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bit2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bit2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bit3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bit3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bit4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bit4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bit5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bit5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bit6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bit6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bit7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bit7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bit0: u8,
        bit1: u8,
        bit2: u8,
        bit3: u8,
        bit4: u8,
        bit5: u8,
        bit6: u8,
        bit7: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bit0: u8 = unsafe { ::core::mem::transmute(bit0) };
            bit0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bit1: u8 = unsafe { ::core::mem::transmute(bit1) };
            bit1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bit2: u8 = unsafe { ::core::mem::transmute(bit2) };
            bit2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bit3: u8 = unsafe { ::core::mem::transmute(bit3) };
            bit3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let bit4: u8 = unsafe { ::core::mem::transmute(bit4) };
            bit4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let bit5: u8 = unsafe { ::core::mem::transmute(bit5) };
            bit5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let bit6: u8 = unsafe { ::core::mem::transmute(bit6) };
            bit6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let bit7: u8 = unsafe { ::core::mem::transmute(bit7) };
            bit7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @addtogroup  Interfaces_Functions"]
#[doc = " @brief       This section provide a set of functions used to read and"]
#[doc = "              write a generic register of the device."]
#[doc = "              MANDATORY: return 0 -> no Error."]
#[doc = " @{"]
#[doc = ""]
pub type stmdev_write_ptr = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut c_types::c_void, arg2: u8, arg3: *mut u8, arg4: u16) -> i32,
>;
pub type stmdev_read_ptr = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut c_types::c_void, arg2: u8, arg3: *mut u8, arg4: u16) -> i32,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct stmdev_ctx_t {
    #[doc = " Component mandatory fields"]
    pub write_reg: stmdev_write_ptr,
    pub read_reg: stmdev_read_ptr,
    #[doc = " Customizable optional pointer"]
    pub handle: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_stmdev_ctx_t() {
    assert_eq!(
        ::core::mem::size_of::<stmdev_ctx_t>(),
        12usize,
        concat!("Size of: ", stringify!(stmdev_ctx_t))
    );
    assert_eq!(
        ::core::mem::align_of::<stmdev_ctx_t>(),
        4usize,
        concat!("Alignment of ", stringify!(stmdev_ctx_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stmdev_ctx_t>())).write_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stmdev_ctx_t),
            "::",
            stringify!(write_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stmdev_ctx_t>())).read_reg as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stmdev_ctx_t),
            "::",
            stringify!(read_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stmdev_ctx_t>())).handle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stmdev_ctx_t),
            "::",
            stringify!(handle)
        )
    );
}
#[doc = " @defgroup    Generic address-data structure definition"]
#[doc = " @brief       This structure is useful to load a predefined configuration"]
#[doc = "              of a sensor."]
#[doc = "              You can create a sensor configuration by your own or using"]
#[doc = "              Unico / Unicleo tools available on STMicroelectronics"]
#[doc = "              web site."]
#[doc = ""]
#[doc = " @{"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ucf_line_t {
    pub address: u8,
    pub data: u8,
}
#[test]
fn bindgen_test_layout_ucf_line_t() {
    assert_eq!(
        ::core::mem::size_of::<ucf_line_t>(),
        2usize,
        concat!("Size of: ", stringify!(ucf_line_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ucf_line_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ucf_line_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ucf_line_t>())).address as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucf_line_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ucf_line_t>())).data as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ucf_line_t),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_func_cfg_access_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_func_cfg_access_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_func_cfg_access_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_func_cfg_access_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_func_cfg_access_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_func_cfg_access_t))
    );
}
impl lsm6ds3_func_cfg_access_t {
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn func_cfg_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_func_cfg_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        not_used_01: u8,
        func_cfg_en: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let func_cfg_en: u8 = unsafe { ::core::mem::transmute(func_cfg_en) };
            func_cfg_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_sensor_sync_time_frame_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_sensor_sync_time_frame_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_sensor_sync_time_frame_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_sensor_sync_time_frame_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_sensor_sync_time_frame_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(lsm6ds3_sensor_sync_time_frame_t)
        )
    );
}
impl lsm6ds3_sensor_sync_time_frame_t {
    #[inline]
    pub fn tph(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_tph(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(tph: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let tph: u8 = unsafe { ::core::mem::transmute(tph) };
            tph as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_fifo_ctrl1_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_fifo_ctrl1_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_fifo_ctrl1_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_fifo_ctrl1_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_fifo_ctrl1_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_fifo_ctrl1_t))
    );
}
impl lsm6ds3_fifo_ctrl1_t {
    #[inline]
    pub fn fth(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_fth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(fth: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let fth: u8 = unsafe { ::core::mem::transmute(fth) };
            fth as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_fifo_ctrl2_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_fifo_ctrl2_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_fifo_ctrl2_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_fifo_ctrl2_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_fifo_ctrl2_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_fifo_ctrl2_t))
    );
}
impl lsm6ds3_fifo_ctrl2_t {
    #[inline]
    pub fn fth(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_fth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn timer_pedo_fifo_drdy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_timer_pedo_fifo_drdy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timer_pedo_fifo_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_timer_pedo_fifo_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fth: u8,
        not_used_01: u8,
        timer_pedo_fifo_drdy: u8,
        timer_pedo_fifo_en: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let fth: u8 = unsafe { ::core::mem::transmute(fth) };
            fth as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let timer_pedo_fifo_drdy: u8 = unsafe { ::core::mem::transmute(timer_pedo_fifo_drdy) };
            timer_pedo_fifo_drdy as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let timer_pedo_fifo_en: u8 = unsafe { ::core::mem::transmute(timer_pedo_fifo_en) };
            timer_pedo_fifo_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_fifo_ctrl3_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_fifo_ctrl3_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_fifo_ctrl3_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_fifo_ctrl3_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_fifo_ctrl3_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_fifo_ctrl3_t))
    );
}
impl lsm6ds3_fifo_ctrl3_t {
    #[inline]
    pub fn dec_fifo_xl(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_dec_fifo_xl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dec_fifo_gyro(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_dec_fifo_gyro(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dec_fifo_xl: u8,
        dec_fifo_gyro: u8,
        not_used_01: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let dec_fifo_xl: u8 = unsafe { ::core::mem::transmute(dec_fifo_xl) };
            dec_fifo_xl as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let dec_fifo_gyro: u8 = unsafe { ::core::mem::transmute(dec_fifo_gyro) };
            dec_fifo_gyro as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_fifo_ctrl4_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_fifo_ctrl4_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_fifo_ctrl4_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_fifo_ctrl4_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_fifo_ctrl4_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_fifo_ctrl4_t))
    );
}
impl lsm6ds3_fifo_ctrl4_t {
    #[inline]
    pub fn dec_ds3_fifo(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_dec_ds3_fifo(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dec_ds4_fifo(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_dec_ds4_fifo(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn only_high_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_only_high_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dec_ds3_fifo: u8,
        dec_ds4_fifo: u8,
        only_high_data: u8,
        not_used_01: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let dec_ds3_fifo: u8 = unsafe { ::core::mem::transmute(dec_ds3_fifo) };
            dec_ds3_fifo as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let dec_ds4_fifo: u8 = unsafe { ::core::mem::transmute(dec_ds4_fifo) };
            dec_ds4_fifo as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let only_high_data: u8 = unsafe { ::core::mem::transmute(only_high_data) };
            only_high_data as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_fifo_ctrl5_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_fifo_ctrl5_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_fifo_ctrl5_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_fifo_ctrl5_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_fifo_ctrl5_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_fifo_ctrl5_t))
    );
}
impl lsm6ds3_fifo_ctrl5_t {
    #[inline]
    pub fn fifo_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_fifo_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn odr_fifo(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_odr_fifo(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fifo_mode: u8,
        odr_fifo: u8,
        not_used_01: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let fifo_mode: u8 = unsafe { ::core::mem::transmute(fifo_mode) };
            fifo_mode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let odr_fifo: u8 = unsafe { ::core::mem::transmute(odr_fifo) };
            odr_fifo as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_orient_cfg_g_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_orient_cfg_g_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_orient_cfg_g_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_orient_cfg_g_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_orient_cfg_g_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_orient_cfg_g_t))
    );
}
impl lsm6ds3_orient_cfg_g_t {
    #[inline]
    pub fn orient(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_orient(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn sign_g(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_sign_g(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        orient: u8,
        sign_g: u8,
        not_used_01: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let orient: u8 = unsafe { ::core::mem::transmute(orient) };
            orient as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let sign_g: u8 = unsafe { ::core::mem::transmute(sign_g) };
            sign_g as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_int1_ctrl_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_int1_ctrl_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_int1_ctrl_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_int1_ctrl_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_int1_ctrl_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_int1_ctrl_t))
    );
}
impl lsm6ds3_int1_ctrl_t {
    #[inline]
    pub fn int1_drdy_xl(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_drdy_xl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_drdy_g(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_drdy_g(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_boot(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_boot(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_fth(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_fth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_fifo_ovr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_fifo_ovr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_full_flag(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_full_flag(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_sign_mot(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_sign_mot(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_step_detector(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_step_detector(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        int1_drdy_xl: u8,
        int1_drdy_g: u8,
        int1_boot: u8,
        int1_fth: u8,
        int1_fifo_ovr: u8,
        int1_full_flag: u8,
        int1_sign_mot: u8,
        int1_step_detector: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let int1_drdy_xl: u8 = unsafe { ::core::mem::transmute(int1_drdy_xl) };
            int1_drdy_xl as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let int1_drdy_g: u8 = unsafe { ::core::mem::transmute(int1_drdy_g) };
            int1_drdy_g as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let int1_boot: u8 = unsafe { ::core::mem::transmute(int1_boot) };
            int1_boot as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let int1_fth: u8 = unsafe { ::core::mem::transmute(int1_fth) };
            int1_fth as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let int1_fifo_ovr: u8 = unsafe { ::core::mem::transmute(int1_fifo_ovr) };
            int1_fifo_ovr as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let int1_full_flag: u8 = unsafe { ::core::mem::transmute(int1_full_flag) };
            int1_full_flag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let int1_sign_mot: u8 = unsafe { ::core::mem::transmute(int1_sign_mot) };
            int1_sign_mot as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let int1_step_detector: u8 = unsafe { ::core::mem::transmute(int1_step_detector) };
            int1_step_detector as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_int2_ctrl_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_int2_ctrl_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_int2_ctrl_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_int2_ctrl_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_int2_ctrl_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_int2_ctrl_t))
    );
}
impl lsm6ds3_int2_ctrl_t {
    #[inline]
    pub fn int2_drdy_xl(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_drdy_xl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_drdy_g(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_drdy_g(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_drdy_temp(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_drdy_temp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_fth(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_fth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_fifo_ovr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_fifo_ovr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_full_flag(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_full_flag(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_step_count_ov(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_step_count_ov(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_step_delta(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_step_delta(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        int2_drdy_xl: u8,
        int2_drdy_g: u8,
        int2_drdy_temp: u8,
        int2_fth: u8,
        int2_fifo_ovr: u8,
        int2_full_flag: u8,
        int2_step_count_ov: u8,
        int2_step_delta: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let int2_drdy_xl: u8 = unsafe { ::core::mem::transmute(int2_drdy_xl) };
            int2_drdy_xl as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let int2_drdy_g: u8 = unsafe { ::core::mem::transmute(int2_drdy_g) };
            int2_drdy_g as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let int2_drdy_temp: u8 = unsafe { ::core::mem::transmute(int2_drdy_temp) };
            int2_drdy_temp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let int2_fth: u8 = unsafe { ::core::mem::transmute(int2_fth) };
            int2_fth as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let int2_fifo_ovr: u8 = unsafe { ::core::mem::transmute(int2_fifo_ovr) };
            int2_fifo_ovr as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let int2_full_flag: u8 = unsafe { ::core::mem::transmute(int2_full_flag) };
            int2_full_flag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let int2_step_count_ov: u8 = unsafe { ::core::mem::transmute(int2_step_count_ov) };
            int2_step_count_ov as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let int2_step_delta: u8 = unsafe { ::core::mem::transmute(int2_step_delta) };
            int2_step_delta as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_ctrl1_xl_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_ctrl1_xl_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_ctrl1_xl_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_ctrl1_xl_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_ctrl1_xl_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_ctrl1_xl_t))
    );
}
impl lsm6ds3_ctrl1_xl_t {
    #[inline]
    pub fn bw_xl(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_bw_xl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fs_xl(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_fs_xl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn odr_xl(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_odr_xl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bw_xl: u8,
        fs_xl: u8,
        odr_xl: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let bw_xl: u8 = unsafe { ::core::mem::transmute(bw_xl) };
            bw_xl as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let fs_xl: u8 = unsafe { ::core::mem::transmute(fs_xl) };
            fs_xl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let odr_xl: u8 = unsafe { ::core::mem::transmute(odr_xl) };
            odr_xl as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_ctrl2_g_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_ctrl2_g_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_ctrl2_g_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_ctrl2_g_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_ctrl2_g_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_ctrl2_g_t))
    );
}
impl lsm6ds3_ctrl2_g_t {
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fs_g(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_fs_g(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn odr_g(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_odr_g(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        not_used_01: u8,
        fs_g: u8,
        odr_g: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let fs_g: u8 = unsafe { ::core::mem::transmute(fs_g) };
            fs_g as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let odr_g: u8 = unsafe { ::core::mem::transmute(odr_g) };
            odr_g as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_ctrl3_c_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_ctrl3_c_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_ctrl3_c_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_ctrl3_c_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_ctrl3_c_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_ctrl3_c_t))
    );
}
impl lsm6ds3_ctrl3_c_t {
    #[inline]
    pub fn sw_reset(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sw_reset(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ble(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ble(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn if_inc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_if_inc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sim(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sim(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pp_od(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pp_od(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn h_lactive(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_h_lactive(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bdu(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bdu(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn boot(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_boot(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sw_reset: u8,
        ble: u8,
        if_inc: u8,
        sim: u8,
        pp_od: u8,
        h_lactive: u8,
        bdu: u8,
        boot: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sw_reset: u8 = unsafe { ::core::mem::transmute(sw_reset) };
            sw_reset as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ble: u8 = unsafe { ::core::mem::transmute(ble) };
            ble as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let if_inc: u8 = unsafe { ::core::mem::transmute(if_inc) };
            if_inc as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let sim: u8 = unsafe { ::core::mem::transmute(sim) };
            sim as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let pp_od: u8 = unsafe { ::core::mem::transmute(pp_od) };
            pp_od as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let h_lactive: u8 = unsafe { ::core::mem::transmute(h_lactive) };
            h_lactive as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let bdu: u8 = unsafe { ::core::mem::transmute(bdu) };
            bdu as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let boot: u8 = unsafe { ::core::mem::transmute(boot) };
            boot as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_ctrl4_c_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_ctrl4_c_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_ctrl4_c_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_ctrl4_c_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_ctrl4_c_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_ctrl4_c_t))
    );
}
impl lsm6ds3_ctrl4_c_t {
    #[inline]
    pub fn stop_on_fth(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_stop_on_fth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn i2c_disable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_i2c_disable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drdy_mask(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drdy_mask(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fifo_temp_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fifo_temp_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_on_int1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_on_int1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sleep_g(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sleep_g(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xl_bw_scal_odr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_xl_bw_scal_odr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        stop_on_fth: u8,
        not_used_01: u8,
        i2c_disable: u8,
        drdy_mask: u8,
        fifo_temp_en: u8,
        int2_on_int1: u8,
        sleep_g: u8,
        xl_bw_scal_odr: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let stop_on_fth: u8 = unsafe { ::core::mem::transmute(stop_on_fth) };
            stop_on_fth as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let i2c_disable: u8 = unsafe { ::core::mem::transmute(i2c_disable) };
            i2c_disable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let drdy_mask: u8 = unsafe { ::core::mem::transmute(drdy_mask) };
            drdy_mask as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let fifo_temp_en: u8 = unsafe { ::core::mem::transmute(fifo_temp_en) };
            fifo_temp_en as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let int2_on_int1: u8 = unsafe { ::core::mem::transmute(int2_on_int1) };
            int2_on_int1 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let sleep_g: u8 = unsafe { ::core::mem::transmute(sleep_g) };
            sleep_g as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let xl_bw_scal_odr: u8 = unsafe { ::core::mem::transmute(xl_bw_scal_odr) };
            xl_bw_scal_odr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_ctrl5_c_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_ctrl5_c_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_ctrl5_c_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_ctrl5_c_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_ctrl5_c_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_ctrl5_c_t))
    );
}
impl lsm6ds3_ctrl5_c_t {
    #[inline]
    pub fn st_xl(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_st_xl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn st_g(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_st_g(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rounding(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_rounding(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        st_xl: u8,
        st_g: u8,
        not_used_01: u8,
        rounding: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let st_xl: u8 = unsafe { ::core::mem::transmute(st_xl) };
            st_xl as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let st_g: u8 = unsafe { ::core::mem::transmute(st_g) };
            st_g as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let rounding: u8 = unsafe { ::core::mem::transmute(rounding) };
            rounding as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_ctrl6_c_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_ctrl6_c_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_ctrl6_c_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_ctrl6_c_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_ctrl6_c_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_ctrl6_c_t))
    );
}
impl lsm6ds3_ctrl6_c_t {
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn xl_hm_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_xl_hm_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn den_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_den_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        not_used_01: u8,
        xl_hm_mode: u8,
        den_mode: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let xl_hm_mode: u8 = unsafe { ::core::mem::transmute(xl_hm_mode) };
            xl_hm_mode as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let den_mode: u8 = unsafe { ::core::mem::transmute(den_mode) };
            den_mode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_ctrl7_g_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_ctrl7_g_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_ctrl7_g_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_ctrl7_g_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_ctrl7_g_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_ctrl7_g_t))
    );
}
impl lsm6ds3_ctrl7_g_t {
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rounding_status(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rounding_status(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hpcf_g(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_hpcf_g(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_g_rst(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hp_g_rst(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_g_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hp_g_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn g_hm_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_g_hm_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        not_used_01: u8,
        rounding_status: u8,
        hpcf_g: u8,
        hp_g_rst: u8,
        hp_g_en: u8,
        g_hm_mode: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rounding_status: u8 = unsafe { ::core::mem::transmute(rounding_status) };
            rounding_status as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let hpcf_g: u8 = unsafe { ::core::mem::transmute(hpcf_g) };
            hpcf_g as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let hp_g_rst: u8 = unsafe { ::core::mem::transmute(hp_g_rst) };
            hp_g_rst as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let hp_g_en: u8 = unsafe { ::core::mem::transmute(hp_g_en) };
            hp_g_en as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let g_hm_mode: u8 = unsafe { ::core::mem::transmute(g_hm_mode) };
            g_hm_mode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_ctrl8_xl_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_ctrl8_xl_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_ctrl8_xl_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_ctrl8_xl_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_ctrl8_xl_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_ctrl8_xl_t))
    );
}
impl lsm6ds3_ctrl8_xl_t {
    #[inline]
    pub fn low_pass_on_6d(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_low_pass_on_6d(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hp_slope_xl_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hp_slope_xl_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_used_02(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_02(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn hpcf_xl(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_hpcf_xl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn lpf2_xl_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lpf2_xl_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        low_pass_on_6d: u8,
        not_used_01: u8,
        hp_slope_xl_en: u8,
        not_used_02: u8,
        hpcf_xl: u8,
        lpf2_xl_en: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let low_pass_on_6d: u8 = unsafe { ::core::mem::transmute(low_pass_on_6d) };
            low_pass_on_6d as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hp_slope_xl_en: u8 = unsafe { ::core::mem::transmute(hp_slope_xl_en) };
            hp_slope_xl_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let not_used_02: u8 = unsafe { ::core::mem::transmute(not_used_02) };
            not_used_02 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let hpcf_xl: u8 = unsafe { ::core::mem::transmute(hpcf_xl) };
            hpcf_xl as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let lpf2_xl_en: u8 = unsafe { ::core::mem::transmute(lpf2_xl_en) };
            lpf2_xl_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_ctrl9_xl_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_ctrl9_xl_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_ctrl9_xl_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_ctrl9_xl_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_ctrl9_xl_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_ctrl9_xl_t))
    );
}
impl lsm6ds3_ctrl9_xl_t {
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn soft_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_soft_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xen_xl(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_xen_xl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn yen_xl(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_yen_xl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn zen_xl(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_zen_xl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_used_02(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_02(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        not_used_01: u8,
        soft_en: u8,
        xen_xl: u8,
        yen_xl: u8,
        zen_xl: u8,
        not_used_02: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let soft_en: u8 = unsafe { ::core::mem::transmute(soft_en) };
            soft_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let xen_xl: u8 = unsafe { ::core::mem::transmute(xen_xl) };
            xen_xl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let yen_xl: u8 = unsafe { ::core::mem::transmute(yen_xl) };
            yen_xl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let zen_xl: u8 = unsafe { ::core::mem::transmute(zen_xl) };
            zen_xl as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let not_used_02: u8 = unsafe { ::core::mem::transmute(not_used_02) };
            not_used_02 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_ctrl10_c_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_ctrl10_c_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_ctrl10_c_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_ctrl10_c_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_ctrl10_c_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_ctrl10_c_t))
    );
}
impl lsm6ds3_ctrl10_c_t {
    #[inline]
    pub fn sign_motion_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sign_motion_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pedo_rst_step(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pedo_rst_step(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn func_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_func_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xen_g(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_xen_g(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn yen_g(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_yen_g(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn zen_g(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_zen_g(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sign_motion_en: u8,
        pedo_rst_step: u8,
        func_en: u8,
        xen_g: u8,
        yen_g: u8,
        zen_g: u8,
        not_used_01: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sign_motion_en: u8 = unsafe { ::core::mem::transmute(sign_motion_en) };
            sign_motion_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let pedo_rst_step: u8 = unsafe { ::core::mem::transmute(pedo_rst_step) };
            pedo_rst_step as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let func_en: u8 = unsafe { ::core::mem::transmute(func_en) };
            func_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let xen_g: u8 = unsafe { ::core::mem::transmute(xen_g) };
            xen_g as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let yen_g: u8 = unsafe { ::core::mem::transmute(yen_g) };
            yen_g as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let zen_g: u8 = unsafe { ::core::mem::transmute(zen_g) };
            zen_g as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_master_config_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_master_config_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_master_config_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_master_config_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_master_config_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_master_config_t))
    );
}
impl lsm6ds3_master_config_t {
    #[inline]
    pub fn master_on(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_master_on(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn iron_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_iron_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pass_through_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pass_through_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pull_up_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pull_up_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start_config(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_start_config(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn data_valid_sel_fifo(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_data_valid_sel_fifo(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drdy_on_int1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drdy_on_int1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        master_on: u8,
        iron_en: u8,
        pass_through_mode: u8,
        pull_up_en: u8,
        start_config: u8,
        not_used_01: u8,
        data_valid_sel_fifo: u8,
        drdy_on_int1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let master_on: u8 = unsafe { ::core::mem::transmute(master_on) };
            master_on as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let iron_en: u8 = unsafe { ::core::mem::transmute(iron_en) };
            iron_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pass_through_mode: u8 = unsafe { ::core::mem::transmute(pass_through_mode) };
            pass_through_mode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let pull_up_en: u8 = unsafe { ::core::mem::transmute(pull_up_en) };
            pull_up_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let start_config: u8 = unsafe { ::core::mem::transmute(start_config) };
            start_config as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let data_valid_sel_fifo: u8 = unsafe { ::core::mem::transmute(data_valid_sel_fifo) };
            data_valid_sel_fifo as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let drdy_on_int1: u8 = unsafe { ::core::mem::transmute(drdy_on_int1) };
            drdy_on_int1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_wake_up_src_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_wake_up_src_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_wake_up_src_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_wake_up_src_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_wake_up_src_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_wake_up_src_t))
    );
}
impl lsm6ds3_wake_up_src_t {
    #[inline]
    pub fn z_wu(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_z_wu(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn y_wu(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_y_wu(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x_wu(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_x_wu(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wu_ia(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wu_ia(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sleep_state_ia(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sleep_state_ia(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ff_ia(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ff_ia(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        z_wu: u8,
        y_wu: u8,
        x_wu: u8,
        wu_ia: u8,
        sleep_state_ia: u8,
        ff_ia: u8,
        not_used_01: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let z_wu: u8 = unsafe { ::core::mem::transmute(z_wu) };
            z_wu as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let y_wu: u8 = unsafe { ::core::mem::transmute(y_wu) };
            y_wu as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let x_wu: u8 = unsafe { ::core::mem::transmute(x_wu) };
            x_wu as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wu_ia: u8 = unsafe { ::core::mem::transmute(wu_ia) };
            wu_ia as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let sleep_state_ia: u8 = unsafe { ::core::mem::transmute(sleep_state_ia) };
            sleep_state_ia as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ff_ia: u8 = unsafe { ::core::mem::transmute(ff_ia) };
            ff_ia as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_tap_src_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_tap_src_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_tap_src_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_tap_src_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_tap_src_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_tap_src_t))
    );
}
impl lsm6ds3_tap_src_t {
    #[inline]
    pub fn z_tap(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_z_tap(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn y_tap(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_y_tap(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x_tap(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_x_tap(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tap_sign(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tap_sign(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn double_tap(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_double_tap(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn single_tap(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_single_tap(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tap_ia(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tap_ia(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        z_tap: u8,
        y_tap: u8,
        x_tap: u8,
        tap_sign: u8,
        double_tap: u8,
        single_tap: u8,
        tap_ia: u8,
        not_used_01: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let z_tap: u8 = unsafe { ::core::mem::transmute(z_tap) };
            z_tap as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let y_tap: u8 = unsafe { ::core::mem::transmute(y_tap) };
            y_tap as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let x_tap: u8 = unsafe { ::core::mem::transmute(x_tap) };
            x_tap as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tap_sign: u8 = unsafe { ::core::mem::transmute(tap_sign) };
            tap_sign as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let double_tap: u8 = unsafe { ::core::mem::transmute(double_tap) };
            double_tap as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let single_tap: u8 = unsafe { ::core::mem::transmute(single_tap) };
            single_tap as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tap_ia: u8 = unsafe { ::core::mem::transmute(tap_ia) };
            tap_ia as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_d6d_src_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_d6d_src_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_d6d_src_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_d6d_src_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_d6d_src_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_d6d_src_t))
    );
}
impl lsm6ds3_d6d_src_t {
    #[inline]
    pub fn xl(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_xl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xh(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_xh(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn yl(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_yl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn yh(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_yh(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn zl(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_zl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn zh(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_zh(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn d6d_ia(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_d6d_ia(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        xl: u8,
        xh: u8,
        yl: u8,
        yh: u8,
        zl: u8,
        zh: u8,
        d6d_ia: u8,
        not_used_01: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let xl: u8 = unsafe { ::core::mem::transmute(xl) };
            xl as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let xh: u8 = unsafe { ::core::mem::transmute(xh) };
            xh as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let yl: u8 = unsafe { ::core::mem::transmute(yl) };
            yl as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let yh: u8 = unsafe { ::core::mem::transmute(yh) };
            yh as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let zl: u8 = unsafe { ::core::mem::transmute(zl) };
            zl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let zh: u8 = unsafe { ::core::mem::transmute(zh) };
            zh as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let d6d_ia: u8 = unsafe { ::core::mem::transmute(d6d_ia) };
            d6d_ia as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_status_reg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_status_reg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_status_reg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_status_reg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_status_reg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_status_reg_t))
    );
}
impl lsm6ds3_status_reg_t {
    #[inline]
    pub fn xlda(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_xlda(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gda(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gda(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tda(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tda(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        xlda: u8,
        gda: u8,
        tda: u8,
        not_used_01: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let xlda: u8 = unsafe { ::core::mem::transmute(xlda) };
            xlda as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let gda: u8 = unsafe { ::core::mem::transmute(gda) };
            gda as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tda: u8 = unsafe { ::core::mem::transmute(tda) };
            tda as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_sensorhub1_reg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_sensorhub1_reg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_sensorhub1_reg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_sensorhub1_reg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_sensorhub1_reg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_sensorhub1_reg_t))
    );
}
impl lsm6ds3_sensorhub1_reg_t {
    #[inline]
    pub fn shub1_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub1_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub1_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub1_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub1_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub1_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub1_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub1_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub1_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub1_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub1_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub1_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub1_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub1_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub1_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub1_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        shub1_0: u8,
        shub1_1: u8,
        shub1_2: u8,
        shub1_3: u8,
        shub1_4: u8,
        shub1_5: u8,
        shub1_6: u8,
        shub1_7: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shub1_0: u8 = unsafe { ::core::mem::transmute(shub1_0) };
            shub1_0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let shub1_1: u8 = unsafe { ::core::mem::transmute(shub1_1) };
            shub1_1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let shub1_2: u8 = unsafe { ::core::mem::transmute(shub1_2) };
            shub1_2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let shub1_3: u8 = unsafe { ::core::mem::transmute(shub1_3) };
            shub1_3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let shub1_4: u8 = unsafe { ::core::mem::transmute(shub1_4) };
            shub1_4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let shub1_5: u8 = unsafe { ::core::mem::transmute(shub1_5) };
            shub1_5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let shub1_6: u8 = unsafe { ::core::mem::transmute(shub1_6) };
            shub1_6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let shub1_7: u8 = unsafe { ::core::mem::transmute(shub1_7) };
            shub1_7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_sensorhub2_reg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_sensorhub2_reg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_sensorhub2_reg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_sensorhub2_reg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_sensorhub2_reg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_sensorhub2_reg_t))
    );
}
impl lsm6ds3_sensorhub2_reg_t {
    #[inline]
    pub fn shub2_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub2_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub2_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub2_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub2_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub2_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub2_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub2_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub2_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub2_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub2_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub2_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub2_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub2_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub2_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub2_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        shub2_0: u8,
        shub2_1: u8,
        shub2_2: u8,
        shub2_3: u8,
        shub2_4: u8,
        shub2_5: u8,
        shub2_6: u8,
        shub2_7: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shub2_0: u8 = unsafe { ::core::mem::transmute(shub2_0) };
            shub2_0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let shub2_1: u8 = unsafe { ::core::mem::transmute(shub2_1) };
            shub2_1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let shub2_2: u8 = unsafe { ::core::mem::transmute(shub2_2) };
            shub2_2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let shub2_3: u8 = unsafe { ::core::mem::transmute(shub2_3) };
            shub2_3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let shub2_4: u8 = unsafe { ::core::mem::transmute(shub2_4) };
            shub2_4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let shub2_5: u8 = unsafe { ::core::mem::transmute(shub2_5) };
            shub2_5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let shub2_6: u8 = unsafe { ::core::mem::transmute(shub2_6) };
            shub2_6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let shub2_7: u8 = unsafe { ::core::mem::transmute(shub2_7) };
            shub2_7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_sensorhub3_reg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_sensorhub3_reg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_sensorhub3_reg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_sensorhub3_reg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_sensorhub3_reg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_sensorhub3_reg_t))
    );
}
impl lsm6ds3_sensorhub3_reg_t {
    #[inline]
    pub fn shub3_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub3_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub3_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub3_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub3_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub3_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub3_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub3_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub3_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub3_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub3_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub3_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub3_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub3_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub3_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub3_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        shub3_0: u8,
        shub3_1: u8,
        shub3_2: u8,
        shub3_3: u8,
        shub3_4: u8,
        shub3_5: u8,
        shub3_6: u8,
        shub3_7: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shub3_0: u8 = unsafe { ::core::mem::transmute(shub3_0) };
            shub3_0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let shub3_1: u8 = unsafe { ::core::mem::transmute(shub3_1) };
            shub3_1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let shub3_2: u8 = unsafe { ::core::mem::transmute(shub3_2) };
            shub3_2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let shub3_3: u8 = unsafe { ::core::mem::transmute(shub3_3) };
            shub3_3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let shub3_4: u8 = unsafe { ::core::mem::transmute(shub3_4) };
            shub3_4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let shub3_5: u8 = unsafe { ::core::mem::transmute(shub3_5) };
            shub3_5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let shub3_6: u8 = unsafe { ::core::mem::transmute(shub3_6) };
            shub3_6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let shub3_7: u8 = unsafe { ::core::mem::transmute(shub3_7) };
            shub3_7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_sensorhub4_reg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_sensorhub4_reg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_sensorhub4_reg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_sensorhub4_reg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_sensorhub4_reg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_sensorhub4_reg_t))
    );
}
impl lsm6ds3_sensorhub4_reg_t {
    #[inline]
    pub fn shub4_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub4_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub4_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub4_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub4_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub4_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub4_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub4_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub4_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub4_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub4_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub4_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub4_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub4_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub4_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub4_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        shub4_0: u8,
        shub4_1: u8,
        shub4_2: u8,
        shub4_3: u8,
        shub4_4: u8,
        shub4_5: u8,
        shub4_6: u8,
        shub4_7: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shub4_0: u8 = unsafe { ::core::mem::transmute(shub4_0) };
            shub4_0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let shub4_1: u8 = unsafe { ::core::mem::transmute(shub4_1) };
            shub4_1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let shub4_2: u8 = unsafe { ::core::mem::transmute(shub4_2) };
            shub4_2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let shub4_3: u8 = unsafe { ::core::mem::transmute(shub4_3) };
            shub4_3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let shub4_4: u8 = unsafe { ::core::mem::transmute(shub4_4) };
            shub4_4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let shub4_5: u8 = unsafe { ::core::mem::transmute(shub4_5) };
            shub4_5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let shub4_6: u8 = unsafe { ::core::mem::transmute(shub4_6) };
            shub4_6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let shub4_7: u8 = unsafe { ::core::mem::transmute(shub4_7) };
            shub4_7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_sensorhub5_reg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_sensorhub5_reg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_sensorhub5_reg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_sensorhub5_reg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_sensorhub5_reg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_sensorhub5_reg_t))
    );
}
impl lsm6ds3_sensorhub5_reg_t {
    #[inline]
    pub fn shub5_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub5_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub5_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub5_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub5_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub5_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub5_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub5_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub5_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub5_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub5_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub5_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub5_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub5_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub5_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub5_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        shub5_0: u8,
        shub5_1: u8,
        shub5_2: u8,
        shub5_3: u8,
        shub5_4: u8,
        shub5_5: u8,
        shub5_6: u8,
        shub5_7: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shub5_0: u8 = unsafe { ::core::mem::transmute(shub5_0) };
            shub5_0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let shub5_1: u8 = unsafe { ::core::mem::transmute(shub5_1) };
            shub5_1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let shub5_2: u8 = unsafe { ::core::mem::transmute(shub5_2) };
            shub5_2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let shub5_3: u8 = unsafe { ::core::mem::transmute(shub5_3) };
            shub5_3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let shub5_4: u8 = unsafe { ::core::mem::transmute(shub5_4) };
            shub5_4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let shub5_5: u8 = unsafe { ::core::mem::transmute(shub5_5) };
            shub5_5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let shub5_6: u8 = unsafe { ::core::mem::transmute(shub5_6) };
            shub5_6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let shub5_7: u8 = unsafe { ::core::mem::transmute(shub5_7) };
            shub5_7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_sensorhub6_reg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_sensorhub6_reg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_sensorhub6_reg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_sensorhub6_reg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_sensorhub6_reg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_sensorhub6_reg_t))
    );
}
impl lsm6ds3_sensorhub6_reg_t {
    #[inline]
    pub fn shub6_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub6_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub6_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub6_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub6_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub6_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub6_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub6_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub6_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub6_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub6_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub6_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub6_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub6_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub6_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub6_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        shub6_0: u8,
        shub6_1: u8,
        shub6_2: u8,
        shub6_3: u8,
        shub6_4: u8,
        shub6_5: u8,
        shub6_6: u8,
        shub6_7: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shub6_0: u8 = unsafe { ::core::mem::transmute(shub6_0) };
            shub6_0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let shub6_1: u8 = unsafe { ::core::mem::transmute(shub6_1) };
            shub6_1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let shub6_2: u8 = unsafe { ::core::mem::transmute(shub6_2) };
            shub6_2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let shub6_3: u8 = unsafe { ::core::mem::transmute(shub6_3) };
            shub6_3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let shub6_4: u8 = unsafe { ::core::mem::transmute(shub6_4) };
            shub6_4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let shub6_5: u8 = unsafe { ::core::mem::transmute(shub6_5) };
            shub6_5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let shub6_6: u8 = unsafe { ::core::mem::transmute(shub6_6) };
            shub6_6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let shub6_7: u8 = unsafe { ::core::mem::transmute(shub6_7) };
            shub6_7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_sensorhub7_reg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_sensorhub7_reg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_sensorhub7_reg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_sensorhub7_reg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_sensorhub7_reg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_sensorhub7_reg_t))
    );
}
impl lsm6ds3_sensorhub7_reg_t {
    #[inline]
    pub fn shub7_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub7_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub7_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub7_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub7_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub7_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub7_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub7_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub7_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub7_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub7_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub7_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub7_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub7_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub7_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub7_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        shub7_0: u8,
        shub7_1: u8,
        shub7_2: u8,
        shub7_3: u8,
        shub7_4: u8,
        shub7_5: u8,
        shub7_6: u8,
        shub7_7: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shub7_0: u8 = unsafe { ::core::mem::transmute(shub7_0) };
            shub7_0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let shub7_1: u8 = unsafe { ::core::mem::transmute(shub7_1) };
            shub7_1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let shub7_2: u8 = unsafe { ::core::mem::transmute(shub7_2) };
            shub7_2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let shub7_3: u8 = unsafe { ::core::mem::transmute(shub7_3) };
            shub7_3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let shub7_4: u8 = unsafe { ::core::mem::transmute(shub7_4) };
            shub7_4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let shub7_5: u8 = unsafe { ::core::mem::transmute(shub7_5) };
            shub7_5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let shub7_6: u8 = unsafe { ::core::mem::transmute(shub7_6) };
            shub7_6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let shub7_7: u8 = unsafe { ::core::mem::transmute(shub7_7) };
            shub7_7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_sensorhub8_reg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_sensorhub8_reg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_sensorhub8_reg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_sensorhub8_reg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_sensorhub8_reg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_sensorhub8_reg_t))
    );
}
impl lsm6ds3_sensorhub8_reg_t {
    #[inline]
    pub fn shub8_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub8_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub8_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub8_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub8_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub8_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub8_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub8_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub8_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub8_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub8_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub8_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub8_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub8_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub8_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub8_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        shub8_0: u8,
        shub8_1: u8,
        shub8_2: u8,
        shub8_3: u8,
        shub8_4: u8,
        shub8_5: u8,
        shub8_6: u8,
        shub8_7: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shub8_0: u8 = unsafe { ::core::mem::transmute(shub8_0) };
            shub8_0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let shub8_1: u8 = unsafe { ::core::mem::transmute(shub8_1) };
            shub8_1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let shub8_2: u8 = unsafe { ::core::mem::transmute(shub8_2) };
            shub8_2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let shub8_3: u8 = unsafe { ::core::mem::transmute(shub8_3) };
            shub8_3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let shub8_4: u8 = unsafe { ::core::mem::transmute(shub8_4) };
            shub8_4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let shub8_5: u8 = unsafe { ::core::mem::transmute(shub8_5) };
            shub8_5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let shub8_6: u8 = unsafe { ::core::mem::transmute(shub8_6) };
            shub8_6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let shub8_7: u8 = unsafe { ::core::mem::transmute(shub8_7) };
            shub8_7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_sensorhub9_reg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_sensorhub9_reg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_sensorhub9_reg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_sensorhub9_reg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_sensorhub9_reg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_sensorhub9_reg_t))
    );
}
impl lsm6ds3_sensorhub9_reg_t {
    #[inline]
    pub fn shub9_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub9_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub9_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub9_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub9_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub9_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub9_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub9_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub9_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub9_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub9_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub9_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub9_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub9_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub9_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub9_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        shub9_0: u8,
        shub9_1: u8,
        shub9_2: u8,
        shub9_3: u8,
        shub9_4: u8,
        shub9_5: u8,
        shub9_6: u8,
        shub9_7: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shub9_0: u8 = unsafe { ::core::mem::transmute(shub9_0) };
            shub9_0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let shub9_1: u8 = unsafe { ::core::mem::transmute(shub9_1) };
            shub9_1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let shub9_2: u8 = unsafe { ::core::mem::transmute(shub9_2) };
            shub9_2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let shub9_3: u8 = unsafe { ::core::mem::transmute(shub9_3) };
            shub9_3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let shub9_4: u8 = unsafe { ::core::mem::transmute(shub9_4) };
            shub9_4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let shub9_5: u8 = unsafe { ::core::mem::transmute(shub9_5) };
            shub9_5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let shub9_6: u8 = unsafe { ::core::mem::transmute(shub9_6) };
            shub9_6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let shub9_7: u8 = unsafe { ::core::mem::transmute(shub9_7) };
            shub9_7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_sensorhub10_reg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_sensorhub10_reg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_sensorhub10_reg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_sensorhub10_reg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_sensorhub10_reg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_sensorhub10_reg_t))
    );
}
impl lsm6ds3_sensorhub10_reg_t {
    #[inline]
    pub fn shub10_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub10_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub10_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub10_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub10_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub10_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub10_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub10_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub10_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub10_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub10_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub10_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub10_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub10_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub10_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub10_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        shub10_0: u8,
        shub10_1: u8,
        shub10_2: u8,
        shub10_3: u8,
        shub10_4: u8,
        shub10_5: u8,
        shub10_6: u8,
        shub10_7: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shub10_0: u8 = unsafe { ::core::mem::transmute(shub10_0) };
            shub10_0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let shub10_1: u8 = unsafe { ::core::mem::transmute(shub10_1) };
            shub10_1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let shub10_2: u8 = unsafe { ::core::mem::transmute(shub10_2) };
            shub10_2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let shub10_3: u8 = unsafe { ::core::mem::transmute(shub10_3) };
            shub10_3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let shub10_4: u8 = unsafe { ::core::mem::transmute(shub10_4) };
            shub10_4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let shub10_5: u8 = unsafe { ::core::mem::transmute(shub10_5) };
            shub10_5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let shub10_6: u8 = unsafe { ::core::mem::transmute(shub10_6) };
            shub10_6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let shub10_7: u8 = unsafe { ::core::mem::transmute(shub10_7) };
            shub10_7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_sensorhub11_reg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_sensorhub11_reg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_sensorhub11_reg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_sensorhub11_reg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_sensorhub11_reg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_sensorhub11_reg_t))
    );
}
impl lsm6ds3_sensorhub11_reg_t {
    #[inline]
    pub fn shub11_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub11_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub11_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub11_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub11_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub11_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub11_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub11_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub11_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub11_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub11_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub11_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub11_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub11_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub11_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub11_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        shub11_0: u8,
        shub11_1: u8,
        shub11_2: u8,
        shub11_3: u8,
        shub11_4: u8,
        shub11_5: u8,
        shub11_6: u8,
        shub11_7: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shub11_0: u8 = unsafe { ::core::mem::transmute(shub11_0) };
            shub11_0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let shub11_1: u8 = unsafe { ::core::mem::transmute(shub11_1) };
            shub11_1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let shub11_2: u8 = unsafe { ::core::mem::transmute(shub11_2) };
            shub11_2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let shub11_3: u8 = unsafe { ::core::mem::transmute(shub11_3) };
            shub11_3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let shub11_4: u8 = unsafe { ::core::mem::transmute(shub11_4) };
            shub11_4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let shub11_5: u8 = unsafe { ::core::mem::transmute(shub11_5) };
            shub11_5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let shub11_6: u8 = unsafe { ::core::mem::transmute(shub11_6) };
            shub11_6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let shub11_7: u8 = unsafe { ::core::mem::transmute(shub11_7) };
            shub11_7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_sensorhub12_reg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_sensorhub12_reg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_sensorhub12_reg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_sensorhub12_reg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_sensorhub12_reg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_sensorhub12_reg_t))
    );
}
impl lsm6ds3_sensorhub12_reg_t {
    #[inline]
    pub fn shub12_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub12_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub12_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub12_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub12_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub12_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub12_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub12_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub12_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub12_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub12_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub12_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub12_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub12_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub12_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub12_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        shub12_0: u8,
        shub12_1: u8,
        shub12_2: u8,
        shub12_3: u8,
        shub12_4: u8,
        shub12_5: u8,
        shub12_6: u8,
        shub12_7: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shub12_0: u8 = unsafe { ::core::mem::transmute(shub12_0) };
            shub12_0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let shub12_1: u8 = unsafe { ::core::mem::transmute(shub12_1) };
            shub12_1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let shub12_2: u8 = unsafe { ::core::mem::transmute(shub12_2) };
            shub12_2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let shub12_3: u8 = unsafe { ::core::mem::transmute(shub12_3) };
            shub12_3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let shub12_4: u8 = unsafe { ::core::mem::transmute(shub12_4) };
            shub12_4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let shub12_5: u8 = unsafe { ::core::mem::transmute(shub12_5) };
            shub12_5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let shub12_6: u8 = unsafe { ::core::mem::transmute(shub12_6) };
            shub12_6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let shub12_7: u8 = unsafe { ::core::mem::transmute(shub12_7) };
            shub12_7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_fifo_status1_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_fifo_status1_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_fifo_status1_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_fifo_status1_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_fifo_status1_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_fifo_status1_t))
    );
}
impl lsm6ds3_fifo_status1_t {
    #[inline]
    pub fn diff_fifo(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_diff_fifo(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(diff_fifo: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let diff_fifo: u8 = unsafe { ::core::mem::transmute(diff_fifo) };
            diff_fifo as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_fifo_status2_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_fifo_status2_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_fifo_status2_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_fifo_status2_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_fifo_status2_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_fifo_status2_t))
    );
}
impl lsm6ds3_fifo_status2_t {
    #[inline]
    pub fn diff_fifo(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_diff_fifo(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn fifo_empty(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fifo_empty(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fifo_full(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fifo_full(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fifo_over_run(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fifo_over_run(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fth(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        diff_fifo: u8,
        fifo_empty: u8,
        fifo_full: u8,
        fifo_over_run: u8,
        fth: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let diff_fifo: u8 = unsafe { ::core::mem::transmute(diff_fifo) };
            diff_fifo as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let fifo_empty: u8 = unsafe { ::core::mem::transmute(fifo_empty) };
            fifo_empty as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let fifo_full: u8 = unsafe { ::core::mem::transmute(fifo_full) };
            fifo_full as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let fifo_over_run: u8 = unsafe { ::core::mem::transmute(fifo_over_run) };
            fifo_over_run as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let fth: u8 = unsafe { ::core::mem::transmute(fth) };
            fth as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_fifo_status3_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_fifo_status3_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_fifo_status3_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_fifo_status3_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_fifo_status3_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_fifo_status3_t))
    );
}
impl lsm6ds3_fifo_status3_t {
    #[inline]
    pub fn fifo_pattern(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_fifo_pattern(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(fifo_pattern: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let fifo_pattern: u8 = unsafe { ::core::mem::transmute(fifo_pattern) };
            fifo_pattern as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_fifo_status4_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_fifo_status4_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_fifo_status4_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_fifo_status4_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_fifo_status4_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_fifo_status4_t))
    );
}
impl lsm6ds3_fifo_status4_t {
    #[inline]
    pub fn fifo_pattern(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_fifo_pattern(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fifo_pattern: u8,
        not_used_01: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let fifo_pattern: u8 = unsafe { ::core::mem::transmute(fifo_pattern) };
            fifo_pattern as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_sensorhub13_reg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_sensorhub13_reg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_sensorhub13_reg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_sensorhub13_reg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_sensorhub13_reg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_sensorhub13_reg_t))
    );
}
impl lsm6ds3_sensorhub13_reg_t {
    #[inline]
    pub fn shub13_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub13_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub13_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub13_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub13_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub13_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub13_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub13_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub13_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub13_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub13_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub13_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub13_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub13_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub13_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub13_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        shub13_0: u8,
        shub13_1: u8,
        shub13_2: u8,
        shub13_3: u8,
        shub13_4: u8,
        shub13_5: u8,
        shub13_6: u8,
        shub13_7: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shub13_0: u8 = unsafe { ::core::mem::transmute(shub13_0) };
            shub13_0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let shub13_1: u8 = unsafe { ::core::mem::transmute(shub13_1) };
            shub13_1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let shub13_2: u8 = unsafe { ::core::mem::transmute(shub13_2) };
            shub13_2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let shub13_3: u8 = unsafe { ::core::mem::transmute(shub13_3) };
            shub13_3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let shub13_4: u8 = unsafe { ::core::mem::transmute(shub13_4) };
            shub13_4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let shub13_5: u8 = unsafe { ::core::mem::transmute(shub13_5) };
            shub13_5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let shub13_6: u8 = unsafe { ::core::mem::transmute(shub13_6) };
            shub13_6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let shub13_7: u8 = unsafe { ::core::mem::transmute(shub13_7) };
            shub13_7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_sensorhub14_reg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_sensorhub14_reg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_sensorhub14_reg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_sensorhub14_reg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_sensorhub14_reg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_sensorhub14_reg_t))
    );
}
impl lsm6ds3_sensorhub14_reg_t {
    #[inline]
    pub fn shub14_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub14_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub14_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub14_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub14_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub14_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub14_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub14_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub14_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub14_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub14_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub14_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub14_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub14_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub14_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub14_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        shub14_0: u8,
        shub14_1: u8,
        shub14_2: u8,
        shub14_3: u8,
        shub14_4: u8,
        shub14_5: u8,
        shub14_6: u8,
        shub14_7: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shub14_0: u8 = unsafe { ::core::mem::transmute(shub14_0) };
            shub14_0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let shub14_1: u8 = unsafe { ::core::mem::transmute(shub14_1) };
            shub14_1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let shub14_2: u8 = unsafe { ::core::mem::transmute(shub14_2) };
            shub14_2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let shub14_3: u8 = unsafe { ::core::mem::transmute(shub14_3) };
            shub14_3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let shub14_4: u8 = unsafe { ::core::mem::transmute(shub14_4) };
            shub14_4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let shub14_5: u8 = unsafe { ::core::mem::transmute(shub14_5) };
            shub14_5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let shub14_6: u8 = unsafe { ::core::mem::transmute(shub14_6) };
            shub14_6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let shub14_7: u8 = unsafe { ::core::mem::transmute(shub14_7) };
            shub14_7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_sensorhub15_reg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_sensorhub15_reg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_sensorhub15_reg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_sensorhub15_reg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_sensorhub15_reg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_sensorhub15_reg_t))
    );
}
impl lsm6ds3_sensorhub15_reg_t {
    #[inline]
    pub fn shub15_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub15_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub15_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub15_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub15_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub15_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub15_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub15_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub15_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub15_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub15_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub15_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub15_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub15_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub15_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub15_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        shub15_0: u8,
        shub15_1: u8,
        shub15_2: u8,
        shub15_3: u8,
        shub15_4: u8,
        shub15_5: u8,
        shub15_6: u8,
        shub15_7: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shub15_0: u8 = unsafe { ::core::mem::transmute(shub15_0) };
            shub15_0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let shub15_1: u8 = unsafe { ::core::mem::transmute(shub15_1) };
            shub15_1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let shub15_2: u8 = unsafe { ::core::mem::transmute(shub15_2) };
            shub15_2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let shub15_3: u8 = unsafe { ::core::mem::transmute(shub15_3) };
            shub15_3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let shub15_4: u8 = unsafe { ::core::mem::transmute(shub15_4) };
            shub15_4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let shub15_5: u8 = unsafe { ::core::mem::transmute(shub15_5) };
            shub15_5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let shub15_6: u8 = unsafe { ::core::mem::transmute(shub15_6) };
            shub15_6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let shub15_7: u8 = unsafe { ::core::mem::transmute(shub15_7) };
            shub15_7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_sensorhub16_reg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_sensorhub16_reg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_sensorhub16_reg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_sensorhub16_reg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_sensorhub16_reg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_sensorhub16_reg_t))
    );
}
impl lsm6ds3_sensorhub16_reg_t {
    #[inline]
    pub fn shub16_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub16_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub16_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub16_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub16_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub16_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub16_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub16_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub16_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub16_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub16_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub16_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub16_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub16_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub16_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub16_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        shub16_0: u8,
        shub16_1: u8,
        shub16_2: u8,
        shub16_3: u8,
        shub16_4: u8,
        shub16_5: u8,
        shub16_6: u8,
        shub16_7: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shub16_0: u8 = unsafe { ::core::mem::transmute(shub16_0) };
            shub16_0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let shub16_1: u8 = unsafe { ::core::mem::transmute(shub16_1) };
            shub16_1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let shub16_2: u8 = unsafe { ::core::mem::transmute(shub16_2) };
            shub16_2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let shub16_3: u8 = unsafe { ::core::mem::transmute(shub16_3) };
            shub16_3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let shub16_4: u8 = unsafe { ::core::mem::transmute(shub16_4) };
            shub16_4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let shub16_5: u8 = unsafe { ::core::mem::transmute(shub16_5) };
            shub16_5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let shub16_6: u8 = unsafe { ::core::mem::transmute(shub16_6) };
            shub16_6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let shub16_7: u8 = unsafe { ::core::mem::transmute(shub16_7) };
            shub16_7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_sensorhub17_reg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_sensorhub17_reg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_sensorhub17_reg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_sensorhub17_reg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_sensorhub17_reg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_sensorhub17_reg_t))
    );
}
impl lsm6ds3_sensorhub17_reg_t {
    #[inline]
    pub fn shub17_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub17_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub17_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub17_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub17_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub17_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub17_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub17_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub17_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub17_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub17_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub17_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub17_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub17_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub17_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub17_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        shub17_0: u8,
        shub17_1: u8,
        shub17_2: u8,
        shub17_3: u8,
        shub17_4: u8,
        shub17_5: u8,
        shub17_6: u8,
        shub17_7: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shub17_0: u8 = unsafe { ::core::mem::transmute(shub17_0) };
            shub17_0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let shub17_1: u8 = unsafe { ::core::mem::transmute(shub17_1) };
            shub17_1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let shub17_2: u8 = unsafe { ::core::mem::transmute(shub17_2) };
            shub17_2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let shub17_3: u8 = unsafe { ::core::mem::transmute(shub17_3) };
            shub17_3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let shub17_4: u8 = unsafe { ::core::mem::transmute(shub17_4) };
            shub17_4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let shub17_5: u8 = unsafe { ::core::mem::transmute(shub17_5) };
            shub17_5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let shub17_6: u8 = unsafe { ::core::mem::transmute(shub17_6) };
            shub17_6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let shub17_7: u8 = unsafe { ::core::mem::transmute(shub17_7) };
            shub17_7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_sensorhub18_reg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_sensorhub18_reg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_sensorhub18_reg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_sensorhub18_reg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_sensorhub18_reg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_sensorhub18_reg_t))
    );
}
impl lsm6ds3_sensorhub18_reg_t {
    #[inline]
    pub fn shub18_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub18_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub18_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub18_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub18_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub18_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub18_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub18_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub18_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub18_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub18_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub18_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub18_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub18_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shub18_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shub18_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        shub18_0: u8,
        shub18_1: u8,
        shub18_2: u8,
        shub18_3: u8,
        shub18_4: u8,
        shub18_5: u8,
        shub18_6: u8,
        shub18_7: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shub18_0: u8 = unsafe { ::core::mem::transmute(shub18_0) };
            shub18_0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let shub18_1: u8 = unsafe { ::core::mem::transmute(shub18_1) };
            shub18_1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let shub18_2: u8 = unsafe { ::core::mem::transmute(shub18_2) };
            shub18_2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let shub18_3: u8 = unsafe { ::core::mem::transmute(shub18_3) };
            shub18_3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let shub18_4: u8 = unsafe { ::core::mem::transmute(shub18_4) };
            shub18_4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let shub18_5: u8 = unsafe { ::core::mem::transmute(shub18_5) };
            shub18_5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let shub18_6: u8 = unsafe { ::core::mem::transmute(shub18_6) };
            shub18_6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let shub18_7: u8 = unsafe { ::core::mem::transmute(shub18_7) };
            shub18_7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_func_src_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_func_src_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_func_src_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_func_src_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_func_src_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_func_src_t))
    );
}
impl lsm6ds3_func_src_t {
    #[inline]
    pub fn sensor_hub_end_op(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sensor_hub_end_op(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn si_end_op(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_si_end_op(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn step_overflow(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_step_overflow(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn step_detected(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_step_detected(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tilt_ia(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tilt_ia(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sign_motion_ia(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sign_motion_ia(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn step_count_delta_ia(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_step_count_delta_ia(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sensor_hub_end_op: u8,
        si_end_op: u8,
        not_used_01: u8,
        step_overflow: u8,
        step_detected: u8,
        tilt_ia: u8,
        sign_motion_ia: u8,
        step_count_delta_ia: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sensor_hub_end_op: u8 = unsafe { ::core::mem::transmute(sensor_hub_end_op) };
            sensor_hub_end_op as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let si_end_op: u8 = unsafe { ::core::mem::transmute(si_end_op) };
            si_end_op as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let step_overflow: u8 = unsafe { ::core::mem::transmute(step_overflow) };
            step_overflow as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let step_detected: u8 = unsafe { ::core::mem::transmute(step_detected) };
            step_detected as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tilt_ia: u8 = unsafe { ::core::mem::transmute(tilt_ia) };
            tilt_ia as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let sign_motion_ia: u8 = unsafe { ::core::mem::transmute(sign_motion_ia) };
            sign_motion_ia as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let step_count_delta_ia: u8 = unsafe { ::core::mem::transmute(step_count_delta_ia) };
            step_count_delta_ia as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_tap_cfg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_tap_cfg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_tap_cfg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_tap_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_tap_cfg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_tap_cfg_t))
    );
}
impl lsm6ds3_tap_cfg_t {
    #[inline]
    pub fn lir(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lir(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tap_z_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tap_z_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tap_y_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tap_y_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tap_x_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tap_x_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slope_fds(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slope_fds(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tilt_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tilt_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pedo_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pedo_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timer_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_timer_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lir: u8,
        tap_z_en: u8,
        tap_y_en: u8,
        tap_x_en: u8,
        slope_fds: u8,
        tilt_en: u8,
        pedo_en: u8,
        timer_en: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let lir: u8 = unsafe { ::core::mem::transmute(lir) };
            lir as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tap_z_en: u8 = unsafe { ::core::mem::transmute(tap_z_en) };
            tap_z_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tap_y_en: u8 = unsafe { ::core::mem::transmute(tap_y_en) };
            tap_y_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tap_x_en: u8 = unsafe { ::core::mem::transmute(tap_x_en) };
            tap_x_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let slope_fds: u8 = unsafe { ::core::mem::transmute(slope_fds) };
            slope_fds as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tilt_en: u8 = unsafe { ::core::mem::transmute(tilt_en) };
            tilt_en as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let pedo_en: u8 = unsafe { ::core::mem::transmute(pedo_en) };
            pedo_en as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let timer_en: u8 = unsafe { ::core::mem::transmute(timer_en) };
            timer_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_tap_ths_6d_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_tap_ths_6d_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_tap_ths_6d_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_tap_ths_6d_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_tap_ths_6d_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_tap_ths_6d_t))
    );
}
impl lsm6ds3_tap_ths_6d_t {
    #[inline]
    pub fn tap_ths(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_tap_ths(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sixd_ths(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_sixd_ths(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn d4d_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_d4d_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tap_ths: u8,
        sixd_ths: u8,
        d4d_en: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let tap_ths: u8 = unsafe { ::core::mem::transmute(tap_ths) };
            tap_ths as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let sixd_ths: u8 = unsafe { ::core::mem::transmute(sixd_ths) };
            sixd_ths as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let d4d_en: u8 = unsafe { ::core::mem::transmute(d4d_en) };
            d4d_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_int_dur2_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_int_dur2_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_int_dur2_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_int_dur2_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_int_dur2_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_int_dur2_t))
    );
}
impl lsm6ds3_int_dur2_t {
    #[inline]
    pub fn shock(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_shock(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn quiet(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_quiet(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn dur(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_dur(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        shock: u8,
        quiet: u8,
        dur: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let shock: u8 = unsafe { ::core::mem::transmute(shock) };
            shock as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let quiet: u8 = unsafe { ::core::mem::transmute(quiet) };
            quiet as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let dur: u8 = unsafe { ::core::mem::transmute(dur) };
            dur as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_wake_up_ths_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_wake_up_ths_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_wake_up_ths_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_wake_up_ths_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_wake_up_ths_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_wake_up_ths_t))
    );
}
impl lsm6ds3_wake_up_ths_t {
    #[inline]
    pub fn wk_ths(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_wk_ths(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn inactivity(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inactivity(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn single_double_tap(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_single_double_tap(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wk_ths: u8,
        inactivity: u8,
        single_double_tap: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let wk_ths: u8 = unsafe { ::core::mem::transmute(wk_ths) };
            wk_ths as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let inactivity: u8 = unsafe { ::core::mem::transmute(inactivity) };
            inactivity as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let single_double_tap: u8 = unsafe { ::core::mem::transmute(single_double_tap) };
            single_double_tap as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_wake_up_dur_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_wake_up_dur_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_wake_up_dur_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_wake_up_dur_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_wake_up_dur_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_wake_up_dur_t))
    );
}
impl lsm6ds3_wake_up_dur_t {
    #[inline]
    pub fn sleep_dur(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_sleep_dur(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn timer_hr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_timer_hr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wake_dur(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_wake_dur(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ff_dur(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ff_dur(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sleep_dur: u8,
        timer_hr: u8,
        wake_dur: u8,
        ff_dur: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let sleep_dur: u8 = unsafe { ::core::mem::transmute(sleep_dur) };
            sleep_dur as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let timer_hr: u8 = unsafe { ::core::mem::transmute(timer_hr) };
            timer_hr as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let wake_dur: u8 = unsafe { ::core::mem::transmute(wake_dur) };
            wake_dur as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ff_dur: u8 = unsafe { ::core::mem::transmute(ff_dur) };
            ff_dur as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_free_fall_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_free_fall_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_free_fall_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_free_fall_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_free_fall_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_free_fall_t))
    );
}
impl lsm6ds3_free_fall_t {
    #[inline]
    pub fn ff_ths(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_ff_ths(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ff_dur(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_ff_dur(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ff_ths: u8, ff_dur: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let ff_ths: u8 = unsafe { ::core::mem::transmute(ff_ths) };
            ff_ths as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let ff_dur: u8 = unsafe { ::core::mem::transmute(ff_dur) };
            ff_dur as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_md1_cfg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_md1_cfg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_md1_cfg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_md1_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_md1_cfg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_md1_cfg_t))
    );
}
impl lsm6ds3_md1_cfg_t {
    #[inline]
    pub fn int1_timer(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_timer(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_tilt(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_tilt(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_6d(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_6d(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_double_tap(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_double_tap(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_ff(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_ff(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_wu(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_wu(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_single_tap(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_single_tap(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_inact_state(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_inact_state(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        int1_timer: u8,
        int1_tilt: u8,
        int1_6d: u8,
        int1_double_tap: u8,
        int1_ff: u8,
        int1_wu: u8,
        int1_single_tap: u8,
        int1_inact_state: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let int1_timer: u8 = unsafe { ::core::mem::transmute(int1_timer) };
            int1_timer as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let int1_tilt: u8 = unsafe { ::core::mem::transmute(int1_tilt) };
            int1_tilt as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let int1_6d: u8 = unsafe { ::core::mem::transmute(int1_6d) };
            int1_6d as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let int1_double_tap: u8 = unsafe { ::core::mem::transmute(int1_double_tap) };
            int1_double_tap as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let int1_ff: u8 = unsafe { ::core::mem::transmute(int1_ff) };
            int1_ff as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let int1_wu: u8 = unsafe { ::core::mem::transmute(int1_wu) };
            int1_wu as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let int1_single_tap: u8 = unsafe { ::core::mem::transmute(int1_single_tap) };
            int1_single_tap as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let int1_inact_state: u8 = unsafe { ::core::mem::transmute(int1_inact_state) };
            int1_inact_state as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_md2_cfg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_md2_cfg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_md2_cfg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_md2_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_md2_cfg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_md2_cfg_t))
    );
}
impl lsm6ds3_md2_cfg_t {
    #[inline]
    pub fn int2_iron(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_iron(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_tilt(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_tilt(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_6d(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_6d(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_double_tap(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_double_tap(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_ff(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_ff(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_wu(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_wu(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_single_tap(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_single_tap(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_inact_state(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_inact_state(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        int2_iron: u8,
        int2_tilt: u8,
        int2_6d: u8,
        int2_double_tap: u8,
        int2_ff: u8,
        int2_wu: u8,
        int2_single_tap: u8,
        int2_inact_state: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let int2_iron: u8 = unsafe { ::core::mem::transmute(int2_iron) };
            int2_iron as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let int2_tilt: u8 = unsafe { ::core::mem::transmute(int2_tilt) };
            int2_tilt as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let int2_6d: u8 = unsafe { ::core::mem::transmute(int2_6d) };
            int2_6d as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let int2_double_tap: u8 = unsafe { ::core::mem::transmute(int2_double_tap) };
            int2_double_tap as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let int2_ff: u8 = unsafe { ::core::mem::transmute(int2_ff) };
            int2_ff as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let int2_wu: u8 = unsafe { ::core::mem::transmute(int2_wu) };
            int2_wu as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let int2_single_tap: u8 = unsafe { ::core::mem::transmute(int2_single_tap) };
            int2_single_tap as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let int2_inact_state: u8 = unsafe { ::core::mem::transmute(int2_inact_state) };
            int2_inact_state as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_slv0_add_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_slv0_add_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_slv0_add_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_slv0_add_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_slv0_add_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_slv0_add_t))
    );
}
impl lsm6ds3_slv0_add_t {
    #[inline]
    pub fn rw_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rw_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slave0_add(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_slave0_add(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(rw_0: u8, slave0_add: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rw_0: u8 = unsafe { ::core::mem::transmute(rw_0) };
            rw_0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let slave0_add: u8 = unsafe { ::core::mem::transmute(slave0_add) };
            slave0_add as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_slv0_subadd_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_slv0_subadd_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_slv0_subadd_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_slv0_subadd_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_slv0_subadd_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_slv0_subadd_t))
    );
}
impl lsm6ds3_slv0_subadd_t {
    #[inline]
    pub fn slave0_reg(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_slave0_reg(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(slave0_reg: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let slave0_reg: u8 = unsafe { ::core::mem::transmute(slave0_reg) };
            slave0_reg as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_slave0_config_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_slave0_config_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_slave0_config_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_slave0_config_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_slave0_config_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_slave0_config_t))
    );
}
impl lsm6ds3_slave0_config_t {
    #[inline]
    pub fn slave0_numop(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_slave0_numop(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn src_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_src_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aux_sens_on(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_aux_sens_on(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn slave0_rate(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_slave0_rate(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slave0_numop: u8,
        src_mode: u8,
        aux_sens_on: u8,
        slave0_rate: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let slave0_numop: u8 = unsafe { ::core::mem::transmute(slave0_numop) };
            slave0_numop as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let src_mode: u8 = unsafe { ::core::mem::transmute(src_mode) };
            src_mode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let aux_sens_on: u8 = unsafe { ::core::mem::transmute(aux_sens_on) };
            aux_sens_on as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let slave0_rate: u8 = unsafe { ::core::mem::transmute(slave0_rate) };
            slave0_rate as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_slv1_add_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_slv1_add_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_slv1_add_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_slv1_add_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_slv1_add_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_slv1_add_t))
    );
}
impl lsm6ds3_slv1_add_t {
    #[inline]
    pub fn r_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_r_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slave1_add(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_slave1_add(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(r_1: u8, slave1_add: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let r_1: u8 = unsafe { ::core::mem::transmute(r_1) };
            r_1 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let slave1_add: u8 = unsafe { ::core::mem::transmute(slave1_add) };
            slave1_add as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_slv1_subadd_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_slv1_subadd_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_slv1_subadd_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_slv1_subadd_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_slv1_subadd_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_slv1_subadd_t))
    );
}
impl lsm6ds3_slv1_subadd_t {
    #[inline]
    pub fn slave1_reg(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_slave1_reg(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(slave1_reg: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let slave1_reg: u8 = unsafe { ::core::mem::transmute(slave1_reg) };
            slave1_reg as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_slave1_config_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_slave1_config_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_slave1_config_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_slave1_config_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_slave1_config_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_slave1_config_t))
    );
}
impl lsm6ds3_slave1_config_t {
    #[inline]
    pub fn slave1_numop(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_slave1_numop(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn slave1_rate(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_slave1_rate(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slave1_numop: u8,
        not_used_01: u8,
        slave1_rate: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let slave1_numop: u8 = unsafe { ::core::mem::transmute(slave1_numop) };
            slave1_numop as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let slave1_rate: u8 = unsafe { ::core::mem::transmute(slave1_rate) };
            slave1_rate as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_slv2_add_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_slv2_add_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_slv2_add_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_slv2_add_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_slv2_add_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_slv2_add_t))
    );
}
impl lsm6ds3_slv2_add_t {
    #[inline]
    pub fn r_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_r_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slave2_add(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_slave2_add(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(r_2: u8, slave2_add: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let r_2: u8 = unsafe { ::core::mem::transmute(r_2) };
            r_2 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let slave2_add: u8 = unsafe { ::core::mem::transmute(slave2_add) };
            slave2_add as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_slv2_subadd_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_slv2_subadd_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_slv2_subadd_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_slv2_subadd_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_slv2_subadd_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_slv2_subadd_t))
    );
}
impl lsm6ds3_slv2_subadd_t {
    #[inline]
    pub fn slave2_reg(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_slave2_reg(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(slave2_reg: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let slave2_reg: u8 = unsafe { ::core::mem::transmute(slave2_reg) };
            slave2_reg as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_slave2_config_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_slave2_config_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_slave2_config_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_slave2_config_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_slave2_config_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_slave2_config_t))
    );
}
impl lsm6ds3_slave2_config_t {
    #[inline]
    pub fn slave2_numop(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_slave2_numop(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn slave2_rate(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_slave2_rate(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slave2_numop: u8,
        not_used_01: u8,
        slave2_rate: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let slave2_numop: u8 = unsafe { ::core::mem::transmute(slave2_numop) };
            slave2_numop as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let slave2_rate: u8 = unsafe { ::core::mem::transmute(slave2_rate) };
            slave2_rate as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_slv3_add_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_slv3_add_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_slv3_add_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_slv3_add_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_slv3_add_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_slv3_add_t))
    );
}
impl lsm6ds3_slv3_add_t {
    #[inline]
    pub fn r_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_r_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slave3_add(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_slave3_add(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(r_3: u8, slave3_add: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let r_3: u8 = unsafe { ::core::mem::transmute(r_3) };
            r_3 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let slave3_add: u8 = unsafe { ::core::mem::transmute(slave3_add) };
            slave3_add as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_slv3_subadd_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_slv3_subadd_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_slv3_subadd_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_slv3_subadd_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_slv3_subadd_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_slv3_subadd_t))
    );
}
impl lsm6ds3_slv3_subadd_t {
    #[inline]
    pub fn slave3_reg(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_slave3_reg(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(slave3_reg: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let slave3_reg: u8 = unsafe { ::core::mem::transmute(slave3_reg) };
            slave3_reg as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_slave3_config_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_slave3_config_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_slave3_config_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_slave3_config_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_slave3_config_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_slave3_config_t))
    );
}
impl lsm6ds3_slave3_config_t {
    #[inline]
    pub fn slave3_numop(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_slave3_numop(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn slave3_rate(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_slave3_rate(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slave3_numop: u8,
        not_used_01: u8,
        slave3_rate: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let slave3_numop: u8 = unsafe { ::core::mem::transmute(slave3_numop) };
            slave3_numop as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let slave3_rate: u8 = unsafe { ::core::mem::transmute(slave3_rate) };
            slave3_rate as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_datawrite_src_mode_sub_slv0_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_datawrite_src_mode_sub_slv0_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_datawrite_src_mode_sub_slv0_t>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(lsm6ds3_datawrite_src_mode_sub_slv0_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_datawrite_src_mode_sub_slv0_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(lsm6ds3_datawrite_src_mode_sub_slv0_t)
        )
    );
}
impl lsm6ds3_datawrite_src_mode_sub_slv0_t {
    #[inline]
    pub fn slave_dataw(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_slave_dataw(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(slave_dataw: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let slave_dataw: u8 = unsafe { ::core::mem::transmute(slave_dataw) };
            slave_dataw as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_pedo_ths_reg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_pedo_ths_reg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_pedo_ths_reg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_pedo_ths_reg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_pedo_ths_reg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_pedo_ths_reg_t))
    );
}
impl lsm6ds3_pedo_ths_reg_t {
    #[inline]
    pub fn ths_min(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_ths_min(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn not_used_01(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_not_used_01(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pedo_4g(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pedo_4g(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ths_min: u8,
        not_used_01: u8,
        pedo_4g: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let ths_min: u8 = unsafe { ::core::mem::transmute(ths_min) };
            ths_min as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let not_used_01: u8 = unsafe { ::core::mem::transmute(not_used_01) };
            not_used_01 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let pedo_4g: u8 = unsafe { ::core::mem::transmute(pedo_4g) };
            pedo_4g as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_sm_ths_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_sm_ths_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_sm_ths_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_sm_ths_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_sm_ths_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_sm_ths_t))
    );
}
impl lsm6ds3_sm_ths_t {
    #[inline]
    pub fn sm_ths(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_sm_ths(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(sm_ths: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let sm_ths: u8 = unsafe { ::core::mem::transmute(sm_ths) };
            sm_ths as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_pedo_deb_reg_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_pedo_deb_reg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_pedo_deb_reg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_pedo_deb_reg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_pedo_deb_reg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_pedo_deb_reg_t))
    );
}
impl lsm6ds3_pedo_deb_reg_t {
    #[inline]
    pub fn deb_step(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_deb_step(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn deb_time(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_deb_time(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(deb_step: u8, deb_time: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let deb_step: u8 = unsafe { ::core::mem::transmute(deb_step) };
            deb_step as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let deb_time: u8 = unsafe { ::core::mem::transmute(deb_time) };
            deb_time as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_step_count_delta_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_step_count_delta_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_step_count_delta_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_step_count_delta_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_step_count_delta_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_step_count_delta_t))
    );
}
impl lsm6ds3_step_count_delta_t {
    #[inline]
    pub fn sc_delta(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_sc_delta(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(sc_delta: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let sc_delta: u8 = unsafe { ::core::mem::transmute(sc_delta) };
            sc_delta as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @defgroup LSM6DS3_Register_Union"]
#[doc = " @brief    This union group all the registers that has a bit-field"]
#[doc = "           description."]
#[doc = "           This union is useful but not need by the driver."]
#[doc = ""]
#[doc = "           REMOVING this union you are compliant with:"]
#[doc = "           MISRA-C 2012 [Rule 19.2] -> \" Union are not allowed \""]
#[doc = ""]
#[doc = " @{"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub union lsm6ds3_reg_t {
    pub func_cfg_access: lsm6ds3_func_cfg_access_t,
    pub sensor_sync_time_frame: lsm6ds3_sensor_sync_time_frame_t,
    pub fifo_ctrl1: lsm6ds3_fifo_ctrl1_t,
    pub fifo_ctrl2: lsm6ds3_fifo_ctrl2_t,
    pub fifo_ctrl3: lsm6ds3_fifo_ctrl3_t,
    pub fifo_ctrl4: lsm6ds3_fifo_ctrl4_t,
    pub fifo_ctrl5: lsm6ds3_fifo_ctrl5_t,
    pub orient_cfg_g: lsm6ds3_orient_cfg_g_t,
    pub int1_ctrl: lsm6ds3_int1_ctrl_t,
    pub int2_ctrl: lsm6ds3_int2_ctrl_t,
    pub ctrl1_xl: lsm6ds3_ctrl1_xl_t,
    pub ctrl2_g: lsm6ds3_ctrl2_g_t,
    pub ctrl3_c: lsm6ds3_ctrl3_c_t,
    pub ctrl4_c: lsm6ds3_ctrl4_c_t,
    pub ctrl5_c: lsm6ds3_ctrl5_c_t,
    pub ctrl6_c: lsm6ds3_ctrl6_c_t,
    pub ctrl7_g: lsm6ds3_ctrl7_g_t,
    pub ctrl8_xl: lsm6ds3_ctrl8_xl_t,
    pub ctrl9_xl: lsm6ds3_ctrl9_xl_t,
    pub ctrl10_c: lsm6ds3_ctrl10_c_t,
    pub master_config: lsm6ds3_master_config_t,
    pub wake_up_src: lsm6ds3_wake_up_src_t,
    pub tap_src: lsm6ds3_tap_src_t,
    pub d6d_src: lsm6ds3_d6d_src_t,
    pub status_reg: lsm6ds3_status_reg_t,
    pub sensorhub1_reg: lsm6ds3_sensorhub1_reg_t,
    pub sensorhub2_reg: lsm6ds3_sensorhub2_reg_t,
    pub sensorhub3_reg: lsm6ds3_sensorhub3_reg_t,
    pub sensorhub4_reg: lsm6ds3_sensorhub4_reg_t,
    pub sensorhub5_reg: lsm6ds3_sensorhub5_reg_t,
    pub sensorhub6_reg: lsm6ds3_sensorhub6_reg_t,
    pub sensorhub7_reg: lsm6ds3_sensorhub7_reg_t,
    pub sensorhub8_reg: lsm6ds3_sensorhub8_reg_t,
    pub sensorhub9_reg: lsm6ds3_sensorhub9_reg_t,
    pub sensorhub10_reg: lsm6ds3_sensorhub10_reg_t,
    pub sensorhub11_reg: lsm6ds3_sensorhub11_reg_t,
    pub sensorhub12_reg: lsm6ds3_sensorhub12_reg_t,
    pub fifo_status1: lsm6ds3_fifo_status1_t,
    pub fifo_status2: lsm6ds3_fifo_status2_t,
    pub fifo_status3: lsm6ds3_fifo_status3_t,
    pub fifo_status4: lsm6ds3_fifo_status4_t,
    pub sensorhub13_reg: lsm6ds3_sensorhub13_reg_t,
    pub sensorhub14_reg: lsm6ds3_sensorhub14_reg_t,
    pub sensorhub15_reg: lsm6ds3_sensorhub15_reg_t,
    pub sensorhub16_reg: lsm6ds3_sensorhub16_reg_t,
    pub sensorhub17_reg: lsm6ds3_sensorhub17_reg_t,
    pub sensorhub18_reg: lsm6ds3_sensorhub18_reg_t,
    pub func_src: lsm6ds3_func_src_t,
    pub tap_cfg: lsm6ds3_tap_cfg_t,
    pub tap_ths_6d: lsm6ds3_tap_ths_6d_t,
    pub int_dur2: lsm6ds3_int_dur2_t,
    pub wake_up_ths: lsm6ds3_wake_up_ths_t,
    pub wake_up_dur: lsm6ds3_wake_up_dur_t,
    pub free_fall: lsm6ds3_free_fall_t,
    pub md1_cfg: lsm6ds3_md1_cfg_t,
    pub md2_cfg: lsm6ds3_md2_cfg_t,
    pub slv0_add: lsm6ds3_slv0_add_t,
    pub slv0_subadd: lsm6ds3_slv0_subadd_t,
    pub slave0_config: lsm6ds3_slave0_config_t,
    pub slv1_add: lsm6ds3_slv1_add_t,
    pub slv1_subadd: lsm6ds3_slv1_subadd_t,
    pub slave1_config: lsm6ds3_slave1_config_t,
    pub slv2_add: lsm6ds3_slv2_add_t,
    pub slv2_subadd: lsm6ds3_slv2_subadd_t,
    pub slave2_config: lsm6ds3_slave2_config_t,
    pub slv3_add: lsm6ds3_slv3_add_t,
    pub slv3_subadd: lsm6ds3_slv3_subadd_t,
    pub slave3_config: lsm6ds3_slave3_config_t,
    pub datawrite_src_mode_sub_slv0: lsm6ds3_datawrite_src_mode_sub_slv0_t,
    pub pedo_ths_reg: lsm6ds3_pedo_ths_reg_t,
    pub sm_ths: lsm6ds3_sm_ths_t,
    pub pedo_deb_reg: lsm6ds3_pedo_deb_reg_t,
    pub step_count_delta: lsm6ds3_step_count_delta_t,
    pub bitwise: bitwise_t,
    pub byte: u8,
    _bindgen_union_align: u8,
}
#[test]
fn bindgen_test_layout_lsm6ds3_reg_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_reg_t>(),
        1usize,
        concat!("Size of: ", stringify!(lsm6ds3_reg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_reg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_reg_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).func_cfg_access as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(func_cfg_access)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lsm6ds3_reg_t>())).sensor_sync_time_frame as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(sensor_sync_time_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).fifo_ctrl1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(fifo_ctrl1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).fifo_ctrl2 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(fifo_ctrl2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).fifo_ctrl3 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(fifo_ctrl3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).fifo_ctrl4 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(fifo_ctrl4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).fifo_ctrl5 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(fifo_ctrl5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).orient_cfg_g as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(orient_cfg_g)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).int1_ctrl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(int1_ctrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).int2_ctrl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(int2_ctrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).ctrl1_xl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(ctrl1_xl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).ctrl2_g as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(ctrl2_g)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).ctrl3_c as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(ctrl3_c)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).ctrl4_c as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(ctrl4_c)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).ctrl5_c as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(ctrl5_c)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).ctrl6_c as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(ctrl6_c)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).ctrl7_g as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(ctrl7_g)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).ctrl8_xl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(ctrl8_xl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).ctrl9_xl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(ctrl9_xl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).ctrl10_c as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(ctrl10_c)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).master_config as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(master_config)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).wake_up_src as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(wake_up_src)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).tap_src as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(tap_src)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).d6d_src as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(d6d_src)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).status_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(status_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).sensorhub1_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(sensorhub1_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).sensorhub2_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(sensorhub2_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).sensorhub3_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(sensorhub3_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).sensorhub4_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(sensorhub4_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).sensorhub5_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(sensorhub5_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).sensorhub6_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(sensorhub6_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).sensorhub7_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(sensorhub7_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).sensorhub8_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(sensorhub8_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).sensorhub9_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(sensorhub9_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).sensorhub10_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(sensorhub10_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).sensorhub11_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(sensorhub11_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).sensorhub12_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(sensorhub12_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).fifo_status1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(fifo_status1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).fifo_status2 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(fifo_status2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).fifo_status3 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(fifo_status3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).fifo_status4 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(fifo_status4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).sensorhub13_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(sensorhub13_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).sensorhub14_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(sensorhub14_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).sensorhub15_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(sensorhub15_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).sensorhub16_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(sensorhub16_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).sensorhub17_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(sensorhub17_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).sensorhub18_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(sensorhub18_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).func_src as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(func_src)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).tap_cfg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(tap_cfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).tap_ths_6d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(tap_ths_6d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).int_dur2 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(int_dur2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).wake_up_ths as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(wake_up_ths)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).wake_up_dur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(wake_up_dur)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).free_fall as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(free_fall)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).md1_cfg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(md1_cfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).md2_cfg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(md2_cfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).slv0_add as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(slv0_add)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).slv0_subadd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(slv0_subadd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).slave0_config as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(slave0_config)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).slv1_add as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(slv1_add)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).slv1_subadd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(slv1_subadd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).slave1_config as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(slave1_config)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).slv2_add as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(slv2_add)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).slv2_subadd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(slv2_subadd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).slave2_config as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(slave2_config)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).slv3_add as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(slv3_add)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).slv3_subadd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(slv3_subadd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).slave3_config as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(slave3_config)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lsm6ds3_reg_t>())).datawrite_src_mode_sub_slv0 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(datawrite_src_mode_sub_slv0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).pedo_ths_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(pedo_ths_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).sm_ths as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(sm_ths)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).pedo_deb_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(pedo_deb_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).step_count_delta as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(step_count_delta)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).bitwise as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(bitwise)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_reg_t>())).byte as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_reg_t),
            "::",
            stringify!(byte)
        )
    );
}
extern "C" {
    #[doc = " @}"]
    #[doc = ""]
    pub fn lsm6ds3_read_reg(ctx: *mut stmdev_ctx_t, reg: u8, data: *mut u8, len: u16) -> i32;
}
extern "C" {
    pub fn lsm6ds3_write_reg(ctx: *mut stmdev_ctx_t, reg: u8, data: *mut u8, len: u16) -> i32;
}
extern "C" {
    pub fn lsm6ds3_from_fs2g_to_mg(lsb: i16) -> float_t;
}
extern "C" {
    pub fn lsm6ds3_from_fs4g_to_mg(lsb: i16) -> float_t;
}
extern "C" {
    pub fn lsm6ds3_from_fs8g_to_mg(lsb: i16) -> float_t;
}
extern "C" {
    pub fn lsm6ds3_from_fs16g_to_mg(lsb: i16) -> float_t;
}
extern "C" {
    pub fn lsm6ds3_from_fs125dps_to_mdps(lsb: i16) -> float_t;
}
extern "C" {
    pub fn lsm6ds3_from_fs250dps_to_mdps(lsb: i16) -> float_t;
}
extern "C" {
    pub fn lsm6ds3_from_fs500dps_to_mdps(lsb: i16) -> float_t;
}
extern "C" {
    pub fn lsm6ds3_from_fs1000dps_to_mdps(lsb: i16) -> float_t;
}
extern "C" {
    pub fn lsm6ds3_from_fs2000dps_to_mdps(lsb: i16) -> float_t;
}
extern "C" {
    pub fn lsm6ds3_from_lsb_to_celsius(lsb: i16) -> float_t;
}
pub const lsm6ds3_gy_orient_t_LSM6DS3_GY_ORIENT_XYZ: lsm6ds3_gy_orient_t = 0;
pub const lsm6ds3_gy_orient_t_LSM6DS3_GY_ORIENT_XZY: lsm6ds3_gy_orient_t = 1;
pub const lsm6ds3_gy_orient_t_LSM6DS3_GY_ORIENT_YXZ: lsm6ds3_gy_orient_t = 2;
pub const lsm6ds3_gy_orient_t_LSM6DS3_GY_ORIENT_YZX: lsm6ds3_gy_orient_t = 3;
pub const lsm6ds3_gy_orient_t_LSM6DS3_GY_ORIENT_ZXY: lsm6ds3_gy_orient_t = 4;
pub const lsm6ds3_gy_orient_t_LSM6DS3_GY_ORIENT_ZYX: lsm6ds3_gy_orient_t = 5;
pub type lsm6ds3_gy_orient_t = u32;
extern "C" {
    pub fn lsm6ds3_gy_data_orient_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_gy_orient_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_gy_data_orient_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_gy_orient_t)
        -> i32;
}
pub const lsm6ds3_gy_sgn_t_LSM6DS3_GY_SIGN_PPP: lsm6ds3_gy_sgn_t = 0;
pub const lsm6ds3_gy_sgn_t_LSM6DS3_GY_SIGN_PPN: lsm6ds3_gy_sgn_t = 1;
pub const lsm6ds3_gy_sgn_t_LSM6DS3_GY_SIGN_PNP: lsm6ds3_gy_sgn_t = 2;
pub const lsm6ds3_gy_sgn_t_LSM6DS3_GY_SIGN_NPP: lsm6ds3_gy_sgn_t = 4;
pub const lsm6ds3_gy_sgn_t_LSM6DS3_GY_SIGN_NNP: lsm6ds3_gy_sgn_t = 6;
pub const lsm6ds3_gy_sgn_t_LSM6DS3_GY_SIGN_NPN: lsm6ds3_gy_sgn_t = 5;
pub const lsm6ds3_gy_sgn_t_LSM6DS3_GY_SIGN_PNN: lsm6ds3_gy_sgn_t = 3;
pub const lsm6ds3_gy_sgn_t_LSM6DS3_GY_SIGN_NNN: lsm6ds3_gy_sgn_t = 7;
pub type lsm6ds3_gy_sgn_t = u32;
extern "C" {
    pub fn lsm6ds3_gy_data_sign_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_gy_sgn_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_gy_data_sign_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_gy_sgn_t) -> i32;
}
pub const lsm6ds3_xl_fs_t_LSM6DS3_2g: lsm6ds3_xl_fs_t = 0;
pub const lsm6ds3_xl_fs_t_LSM6DS3_16g: lsm6ds3_xl_fs_t = 1;
pub const lsm6ds3_xl_fs_t_LSM6DS3_4g: lsm6ds3_xl_fs_t = 2;
pub const lsm6ds3_xl_fs_t_LSM6DS3_8g: lsm6ds3_xl_fs_t = 3;
pub type lsm6ds3_xl_fs_t = u32;
extern "C" {
    pub fn lsm6ds3_xl_full_scale_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_xl_fs_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_xl_full_scale_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_xl_fs_t) -> i32;
}
pub const lsm6ds3_odr_xl_t_LSM6DS3_XL_ODR_OFF: lsm6ds3_odr_xl_t = 0;
pub const lsm6ds3_odr_xl_t_LSM6DS3_XL_ODR_12Hz5: lsm6ds3_odr_xl_t = 1;
pub const lsm6ds3_odr_xl_t_LSM6DS3_XL_ODR_26Hz: lsm6ds3_odr_xl_t = 2;
pub const lsm6ds3_odr_xl_t_LSM6DS3_XL_ODR_52Hz: lsm6ds3_odr_xl_t = 3;
pub const lsm6ds3_odr_xl_t_LSM6DS3_XL_ODR_104Hz: lsm6ds3_odr_xl_t = 4;
pub const lsm6ds3_odr_xl_t_LSM6DS3_XL_ODR_208Hz: lsm6ds3_odr_xl_t = 5;
pub const lsm6ds3_odr_xl_t_LSM6DS3_XL_ODR_416Hz: lsm6ds3_odr_xl_t = 6;
pub const lsm6ds3_odr_xl_t_LSM6DS3_XL_ODR_833Hz: lsm6ds3_odr_xl_t = 7;
pub const lsm6ds3_odr_xl_t_LSM6DS3_XL_ODR_1k66Hz: lsm6ds3_odr_xl_t = 8;
pub const lsm6ds3_odr_xl_t_LSM6DS3_XL_ODR_3k33Hz: lsm6ds3_odr_xl_t = 9;
pub const lsm6ds3_odr_xl_t_LSM6DS3_XL_ODR_6k66Hz: lsm6ds3_odr_xl_t = 10;
pub type lsm6ds3_odr_xl_t = u32;
extern "C" {
    pub fn lsm6ds3_xl_data_rate_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_odr_xl_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_xl_data_rate_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_odr_xl_t) -> i32;
}
pub const lsm6ds3_fs_g_t_LSM6DS3_250dps: lsm6ds3_fs_g_t = 0;
pub const lsm6ds3_fs_g_t_LSM6DS3_125dps: lsm6ds3_fs_g_t = 1;
pub const lsm6ds3_fs_g_t_LSM6DS3_500dps: lsm6ds3_fs_g_t = 2;
pub const lsm6ds3_fs_g_t_LSM6DS3_1000dps: lsm6ds3_fs_g_t = 4;
pub const lsm6ds3_fs_g_t_LSM6DS3_2000dps: lsm6ds3_fs_g_t = 6;
pub type lsm6ds3_fs_g_t = u32;
extern "C" {
    pub fn lsm6ds3_gy_full_scale_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_fs_g_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_gy_full_scale_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_fs_g_t) -> i32;
}
pub const lsm6ds3_odr_g_t_LSM6DS3_GY_ODR_OFF: lsm6ds3_odr_g_t = 0;
pub const lsm6ds3_odr_g_t_LSM6DS3_GY_ODR_12Hz5: lsm6ds3_odr_g_t = 1;
pub const lsm6ds3_odr_g_t_LSM6DS3_GY_ODR_26Hz: lsm6ds3_odr_g_t = 2;
pub const lsm6ds3_odr_g_t_LSM6DS3_GY_ODR_52Hz: lsm6ds3_odr_g_t = 3;
pub const lsm6ds3_odr_g_t_LSM6DS3_GY_ODR_104Hz: lsm6ds3_odr_g_t = 4;
pub const lsm6ds3_odr_g_t_LSM6DS3_GY_ODR_208Hz: lsm6ds3_odr_g_t = 5;
pub const lsm6ds3_odr_g_t_LSM6DS3_GY_ODR_416Hz: lsm6ds3_odr_g_t = 6;
pub const lsm6ds3_odr_g_t_LSM6DS3_GY_ODR_833Hz: lsm6ds3_odr_g_t = 7;
pub const lsm6ds3_odr_g_t_LSM6DS3_GY_ODR_1k66Hz: lsm6ds3_odr_g_t = 8;
pub type lsm6ds3_odr_g_t = u32;
extern "C" {
    pub fn lsm6ds3_gy_data_rate_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_odr_g_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_gy_data_rate_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_odr_g_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_block_data_update_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_block_data_update_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
pub const lsm6ds3_xl_hm_mode_t_LSM6DS3_XL_HIGH_PERFORMANCE: lsm6ds3_xl_hm_mode_t = 0;
pub const lsm6ds3_xl_hm_mode_t_LSM6DS3_XL_NORMAL: lsm6ds3_xl_hm_mode_t = 1;
pub type lsm6ds3_xl_hm_mode_t = u32;
extern "C" {
    pub fn lsm6ds3_xl_power_mode_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_xl_hm_mode_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_xl_power_mode_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_xl_hm_mode_t)
        -> i32;
}
pub const lsm6ds3_rnd_stat_t_LSM6DS3_STAT_RND_DISABLE: lsm6ds3_rnd_stat_t = 0;
pub const lsm6ds3_rnd_stat_t_LSM6DS3_STAT_RND_ENABLE: lsm6ds3_rnd_stat_t = 1;
pub type lsm6ds3_rnd_stat_t = u32;
extern "C" {
    pub fn lsm6ds3_rounding_on_status_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_rnd_stat_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_rounding_on_status_get(
        ctx: *mut stmdev_ctx_t,
        val: *mut lsm6ds3_rnd_stat_t,
    ) -> i32;
}
pub const lsm6ds3_g_hm_mode_t_LSM6DS3_GY_HIGH_PERFORMANCE: lsm6ds3_g_hm_mode_t = 0;
pub const lsm6ds3_g_hm_mode_t_LSM6DS3_GY_NORMAL: lsm6ds3_g_hm_mode_t = 1;
pub type lsm6ds3_g_hm_mode_t = u32;
extern "C" {
    pub fn lsm6ds3_gy_power_mode_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_g_hm_mode_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_gy_power_mode_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_g_hm_mode_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_xl_axis_x_data_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_xl_axis_x_data_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_xl_axis_y_data_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_xl_axis_y_data_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_xl_axis_z_data_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_xl_axis_z_data_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_gy_axis_x_data_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_gy_axis_x_data_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_gy_axis_y_data_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_gy_axis_y_data_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_gy_axis_z_data_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_gy_axis_z_data_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_all_src_t {
    pub wake_up_src: lsm6ds3_wake_up_src_t,
    pub tap_src: lsm6ds3_tap_src_t,
    pub d6d_src: lsm6ds3_d6d_src_t,
    pub func_src: lsm6ds3_func_src_t,
}
#[test]
fn bindgen_test_layout_lsm6ds3_all_src_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_all_src_t>(),
        4usize,
        concat!("Size of: ", stringify!(lsm6ds3_all_src_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_all_src_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_all_src_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_all_src_t>())).wake_up_src as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_all_src_t),
            "::",
            stringify!(wake_up_src)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_all_src_t>())).tap_src as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_all_src_t),
            "::",
            stringify!(tap_src)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_all_src_t>())).d6d_src as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_all_src_t),
            "::",
            stringify!(d6d_src)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_all_src_t>())).func_src as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_all_src_t),
            "::",
            stringify!(func_src)
        )
    );
}
extern "C" {
    pub fn lsm6ds3_all_sources_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_all_src_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_status_reg_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_status_reg_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_xl_flag_data_ready_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_gy_flag_data_ready_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_temp_flag_data_ready_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_timestamp_raw_get(ctx: *mut stmdev_ctx_t, buff: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_timestamp_rst_set(ctx: *mut stmdev_ctx_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_timestamp_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_timestamp_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
pub const lsm6ds3_ts_res_t_LSM6DS3_LSB_6ms4: lsm6ds3_ts_res_t = 0;
pub const lsm6ds3_ts_res_t_LSM6DS3_LSB_25us: lsm6ds3_ts_res_t = 1;
pub type lsm6ds3_ts_res_t = u32;
extern "C" {
    pub fn lsm6ds3_timestamp_res_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_ts_res_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_timestamp_res_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_ts_res_t) -> i32;
}
pub const lsm6ds3_rounding_t_LSM6DS3_ROUND_DISABLE: lsm6ds3_rounding_t = 0;
pub const lsm6ds3_rounding_t_LSM6DS3_ROUND_XL: lsm6ds3_rounding_t = 1;
pub const lsm6ds3_rounding_t_LSM6DS3_ROUND_GY: lsm6ds3_rounding_t = 2;
pub const lsm6ds3_rounding_t_LSM6DS3_ROUND_GY_XL: lsm6ds3_rounding_t = 3;
pub const lsm6ds3_rounding_t_LSM6DS3_ROUND_SH1_TO_SH6: lsm6ds3_rounding_t = 4;
pub const lsm6ds3_rounding_t_LSM6DS3_ROUND_XL_SH1_TO_SH6: lsm6ds3_rounding_t = 5;
pub const lsm6ds3_rounding_t_LSM6DS3_ROUND_GY_XL_SH1_TO_SH12: lsm6ds3_rounding_t = 6;
pub const lsm6ds3_rounding_t_LSM6DS3_ROUND_GY_XL_SH1_TO_SH6: lsm6ds3_rounding_t = 7;
pub type lsm6ds3_rounding_t = u32;
extern "C" {
    pub fn lsm6ds3_rounding_mode_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_rounding_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_rounding_mode_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_rounding_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_temperature_raw_get(ctx: *mut stmdev_ctx_t, buff: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_angular_rate_raw_get(ctx: *mut stmdev_ctx_t, buff: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_acceleration_raw_get(ctx: *mut stmdev_ctx_t, buff: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_fifo_raw_data_get(ctx: *mut stmdev_ctx_t, buffer: *mut u8, len: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_number_of_steps_get(ctx: *mut stmdev_ctx_t, buff: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_mag_calibrated_raw_get(ctx: *mut stmdev_ctx_t, buff: *mut u8) -> i32;
}
pub const lsm6ds3_func_cfg_en_t_LSM6DS3_USER_BANK: lsm6ds3_func_cfg_en_t = 0;
pub const lsm6ds3_func_cfg_en_t_LSM6DS3_EMBEDDED_FUNC_BANK: lsm6ds3_func_cfg_en_t = 1;
pub type lsm6ds3_func_cfg_en_t = u32;
extern "C" {
    pub fn lsm6ds3_mem_bank_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_func_cfg_en_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_mem_bank_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_func_cfg_en_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_device_id_get(ctx: *mut stmdev_ctx_t, buff: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_reset_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_reset_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
pub const lsm6ds3_ble_t_LSM6DS3_LSB_AT_LOW_ADD: lsm6ds3_ble_t = 0;
pub const lsm6ds3_ble_t_LSM6DS3_MSB_AT_LOW_ADD: lsm6ds3_ble_t = 1;
pub type lsm6ds3_ble_t = u32;
extern "C" {
    pub fn lsm6ds3_data_format_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_ble_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_data_format_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_ble_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_auto_increment_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_auto_increment_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_boot_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_boot_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
pub const lsm6ds3_st_xl_t_LSM6DS3_XL_ST_DISABLE: lsm6ds3_st_xl_t = 0;
pub const lsm6ds3_st_xl_t_LSM6DS3_XL_ST_POSITIVE: lsm6ds3_st_xl_t = 1;
pub const lsm6ds3_st_xl_t_LSM6DS3_XL_ST_NEGATIVE: lsm6ds3_st_xl_t = 2;
pub type lsm6ds3_st_xl_t = u32;
extern "C" {
    pub fn lsm6ds3_xl_self_test_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_st_xl_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_xl_self_test_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_st_xl_t) -> i32;
}
pub const lsm6ds3_st_g_t_LSM6DS3_GY_ST_DISABLE: lsm6ds3_st_g_t = 0;
pub const lsm6ds3_st_g_t_LSM6DS3_GY_ST_POSITIVE: lsm6ds3_st_g_t = 1;
pub const lsm6ds3_st_g_t_LSM6DS3_GY_ST_NEGATIVE: lsm6ds3_st_g_t = 3;
pub type lsm6ds3_st_g_t = u32;
extern "C" {
    pub fn lsm6ds3_gy_self_test_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_st_g_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_gy_self_test_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_st_g_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_filter_settling_mask_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_filter_settling_mask_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
pub const lsm6ds3_hpcf_g_t_LSM6DS3_HP_CUT_OFF_8mHz1: lsm6ds3_hpcf_g_t = 0;
pub const lsm6ds3_hpcf_g_t_LSM6DS3_HP_CUT_OFF_32mHz4: lsm6ds3_hpcf_g_t = 1;
pub const lsm6ds3_hpcf_g_t_LSM6DS3_HP_CUT_OFF_2Hz07: lsm6ds3_hpcf_g_t = 2;
pub const lsm6ds3_hpcf_g_t_LSM6DS3_HP_CUT_OFF_16Hz32: lsm6ds3_hpcf_g_t = 3;
pub type lsm6ds3_hpcf_g_t = u32;
extern "C" {
    pub fn lsm6ds3_gy_hp_bandwidth_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_hpcf_g_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_gy_hp_bandwidth_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_hpcf_g_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_gy_hp_reset_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_gy_hp_reset_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
pub const lsm6ds3_hp_bw_t_LSM6DS3_XL_HP_ODR_DIV_4: lsm6ds3_hp_bw_t = 0;
pub const lsm6ds3_hp_bw_t_LSM6DS3_XL_HP_ODR_DIV_100: lsm6ds3_hp_bw_t = 1;
pub const lsm6ds3_hp_bw_t_LSM6DS3_XL_HP_ODR_DIV_9: lsm6ds3_hp_bw_t = 2;
pub const lsm6ds3_hp_bw_t_LSM6DS3_XL_HP_ODR_DIV_400: lsm6ds3_hp_bw_t = 3;
pub type lsm6ds3_hp_bw_t = u32;
extern "C" {
    pub fn lsm6ds3_xl_hp_bandwidth_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_hp_bw_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_xl_hp_bandwidth_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_hp_bw_t) -> i32;
}
pub const lsm6ds3_lp_bw_t_LSM6DS3_XL_LP_ODR_DIV_50: lsm6ds3_lp_bw_t = 0;
pub const lsm6ds3_lp_bw_t_LSM6DS3_XL_LP_ODR_DIV_100: lsm6ds3_lp_bw_t = 1;
pub const lsm6ds3_lp_bw_t_LSM6DS3_XL_LP_ODR_DIV_9: lsm6ds3_lp_bw_t = 2;
pub const lsm6ds3_lp_bw_t_LSM6DS3_XL_LP_ODR_DIV_400: lsm6ds3_lp_bw_t = 3;
pub type lsm6ds3_lp_bw_t = u32;
extern "C" {
    pub fn lsm6ds3_xl_lp2_bandwidth_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_lp_bw_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_xl_lp2_bandwidth_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_lp_bw_t) -> i32;
}
pub const lsm6ds3_bw_xl_t_LSM6DS3_ANTI_ALIASING_400Hz: lsm6ds3_bw_xl_t = 0;
pub const lsm6ds3_bw_xl_t_LSM6DS3_ANTI_ALIASING_200Hz: lsm6ds3_bw_xl_t = 1;
pub const lsm6ds3_bw_xl_t_LSM6DS3_ANTI_ALIASING_100Hz: lsm6ds3_bw_xl_t = 2;
pub const lsm6ds3_bw_xl_t_LSM6DS3_ANTI_ALIASING_50Hz: lsm6ds3_bw_xl_t = 3;
pub type lsm6ds3_bw_xl_t = u32;
extern "C" {
    pub fn lsm6ds3_xl_filter_analog_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_bw_xl_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_xl_filter_analog_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_bw_xl_t) -> i32;
}
pub const lsm6ds3_sim_t_LSM6DS3_SPI_4_WIRE: lsm6ds3_sim_t = 0;
pub const lsm6ds3_sim_t_LSM6DS3_SPI_3_WIRE: lsm6ds3_sim_t = 1;
pub type lsm6ds3_sim_t = u32;
extern "C" {
    pub fn lsm6ds3_spi_mode_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_sim_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_spi_mode_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_sim_t) -> i32;
}
pub const lsm6ds3_i2c_dis_t_LSM6DS3_I2C_ENABLE: lsm6ds3_i2c_dis_t = 0;
pub const lsm6ds3_i2c_dis_t_LSM6DS3_I2C_DISABLE: lsm6ds3_i2c_dis_t = 1;
pub type lsm6ds3_i2c_dis_t = u32;
extern "C" {
    pub fn lsm6ds3_i2c_interface_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_i2c_dis_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_i2c_interface_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_i2c_dis_t) -> i32;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_int1_route_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_int1_route_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_int1_route_t>(),
        3usize,
        concat!("Size of: ", stringify!(lsm6ds3_int1_route_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_int1_route_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_int1_route_t))
    );
}
impl lsm6ds3_int1_route_t {
    #[inline]
    pub fn int1_drdy_xl(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_drdy_xl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_drdy_g(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_drdy_g(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_boot(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_boot(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_fth(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_fth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_fifo_ovr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_fifo_ovr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_full_flag(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_full_flag(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_sign_mot(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_sign_mot(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_step_detector(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_step_detector(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_timer(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_timer(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_tilt(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_tilt(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_6d(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_6d(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_double_tap(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_double_tap(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_ff(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_ff(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_wu(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_wu(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_single_tap(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_single_tap(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int1_inact_state(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int1_inact_state(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drdy_on_int1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drdy_on_int1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        int1_drdy_xl: u8,
        int1_drdy_g: u8,
        int1_boot: u8,
        int1_fth: u8,
        int1_fifo_ovr: u8,
        int1_full_flag: u8,
        int1_sign_mot: u8,
        int1_step_detector: u8,
        int1_timer: u8,
        int1_tilt: u8,
        int1_6d: u8,
        int1_double_tap: u8,
        int1_ff: u8,
        int1_wu: u8,
        int1_single_tap: u8,
        int1_inact_state: u8,
        drdy_on_int1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let int1_drdy_xl: u8 = unsafe { ::core::mem::transmute(int1_drdy_xl) };
            int1_drdy_xl as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let int1_drdy_g: u8 = unsafe { ::core::mem::transmute(int1_drdy_g) };
            int1_drdy_g as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let int1_boot: u8 = unsafe { ::core::mem::transmute(int1_boot) };
            int1_boot as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let int1_fth: u8 = unsafe { ::core::mem::transmute(int1_fth) };
            int1_fth as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let int1_fifo_ovr: u8 = unsafe { ::core::mem::transmute(int1_fifo_ovr) };
            int1_fifo_ovr as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let int1_full_flag: u8 = unsafe { ::core::mem::transmute(int1_full_flag) };
            int1_full_flag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let int1_sign_mot: u8 = unsafe { ::core::mem::transmute(int1_sign_mot) };
            int1_sign_mot as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let int1_step_detector: u8 = unsafe { ::core::mem::transmute(int1_step_detector) };
            int1_step_detector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let int1_timer: u8 = unsafe { ::core::mem::transmute(int1_timer) };
            int1_timer as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let int1_tilt: u8 = unsafe { ::core::mem::transmute(int1_tilt) };
            int1_tilt as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let int1_6d: u8 = unsafe { ::core::mem::transmute(int1_6d) };
            int1_6d as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let int1_double_tap: u8 = unsafe { ::core::mem::transmute(int1_double_tap) };
            int1_double_tap as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let int1_ff: u8 = unsafe { ::core::mem::transmute(int1_ff) };
            int1_ff as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let int1_wu: u8 = unsafe { ::core::mem::transmute(int1_wu) };
            int1_wu as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let int1_single_tap: u8 = unsafe { ::core::mem::transmute(int1_single_tap) };
            int1_single_tap as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let int1_inact_state: u8 = unsafe { ::core::mem::transmute(int1_inact_state) };
            int1_inact_state as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let drdy_on_int1: u8 = unsafe { ::core::mem::transmute(drdy_on_int1) };
            drdy_on_int1 as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn lsm6ds3_pin_int1_route_set(
        ctx: *mut stmdev_ctx_t,
        val: *mut lsm6ds3_int1_route_t,
    ) -> i32;
}
extern "C" {
    pub fn lsm6ds3_pin_int1_route_get(
        ctx: *mut stmdev_ctx_t,
        val: *mut lsm6ds3_int1_route_t,
    ) -> i32;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_int2_route_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
}
#[test]
fn bindgen_test_layout_lsm6ds3_int2_route_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_int2_route_t>(),
        3usize,
        concat!("Size of: ", stringify!(lsm6ds3_int2_route_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_int2_route_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_int2_route_t))
    );
}
impl lsm6ds3_int2_route_t {
    #[inline]
    pub fn int2_drdy_xl(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_drdy_xl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_drdy_g(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_drdy_g(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_drdy_temp(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_drdy_temp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_fth(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_fth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_fifo_ovr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_fifo_ovr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_full_flag(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_full_flag(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_step_count_ov(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_step_count_ov(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_step_delta(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_step_delta(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_iron(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_iron(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_tilt(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_tilt(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_6d(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_6d(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_double_tap(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_double_tap(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_ff(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_ff(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_wu(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_wu(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_single_tap(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_single_tap(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int2_inact_state(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_int2_inact_state(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start_config(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_start_config(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        int2_drdy_xl: u8,
        int2_drdy_g: u8,
        int2_drdy_temp: u8,
        int2_fth: u8,
        int2_fifo_ovr: u8,
        int2_full_flag: u8,
        int2_step_count_ov: u8,
        int2_step_delta: u8,
        int2_iron: u8,
        int2_tilt: u8,
        int2_6d: u8,
        int2_double_tap: u8,
        int2_ff: u8,
        int2_wu: u8,
        int2_single_tap: u8,
        int2_inact_state: u8,
        start_config: u8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let int2_drdy_xl: u8 = unsafe { ::core::mem::transmute(int2_drdy_xl) };
            int2_drdy_xl as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let int2_drdy_g: u8 = unsafe { ::core::mem::transmute(int2_drdy_g) };
            int2_drdy_g as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let int2_drdy_temp: u8 = unsafe { ::core::mem::transmute(int2_drdy_temp) };
            int2_drdy_temp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let int2_fth: u8 = unsafe { ::core::mem::transmute(int2_fth) };
            int2_fth as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let int2_fifo_ovr: u8 = unsafe { ::core::mem::transmute(int2_fifo_ovr) };
            int2_fifo_ovr as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let int2_full_flag: u8 = unsafe { ::core::mem::transmute(int2_full_flag) };
            int2_full_flag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let int2_step_count_ov: u8 = unsafe { ::core::mem::transmute(int2_step_count_ov) };
            int2_step_count_ov as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let int2_step_delta: u8 = unsafe { ::core::mem::transmute(int2_step_delta) };
            int2_step_delta as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let int2_iron: u8 = unsafe { ::core::mem::transmute(int2_iron) };
            int2_iron as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let int2_tilt: u8 = unsafe { ::core::mem::transmute(int2_tilt) };
            int2_tilt as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let int2_6d: u8 = unsafe { ::core::mem::transmute(int2_6d) };
            int2_6d as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let int2_double_tap: u8 = unsafe { ::core::mem::transmute(int2_double_tap) };
            int2_double_tap as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let int2_ff: u8 = unsafe { ::core::mem::transmute(int2_ff) };
            int2_ff as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let int2_wu: u8 = unsafe { ::core::mem::transmute(int2_wu) };
            int2_wu as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let int2_single_tap: u8 = unsafe { ::core::mem::transmute(int2_single_tap) };
            int2_single_tap as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let int2_inact_state: u8 = unsafe { ::core::mem::transmute(int2_inact_state) };
            int2_inact_state as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let start_config: u8 = unsafe { ::core::mem::transmute(start_config) };
            start_config as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn lsm6ds3_pin_int2_route_set(
        ctx: *mut stmdev_ctx_t,
        val: *mut lsm6ds3_int2_route_t,
    ) -> i32;
}
extern "C" {
    pub fn lsm6ds3_pin_int2_route_get(
        ctx: *mut stmdev_ctx_t,
        val: *mut lsm6ds3_int2_route_t,
    ) -> i32;
}
pub const lsm6ds3_pp_od_t_LSM6DS3_PUSH_PULL: lsm6ds3_pp_od_t = 0;
pub const lsm6ds3_pp_od_t_LSM6DS3_OPEN_DRAIN: lsm6ds3_pp_od_t = 1;
pub type lsm6ds3_pp_od_t = u32;
extern "C" {
    pub fn lsm6ds3_pin_mode_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_pp_od_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_pin_mode_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_pp_od_t) -> i32;
}
pub const lsm6ds3_pin_pol_t_LSM6DS3_ACTIVE_HIGH: lsm6ds3_pin_pol_t = 0;
pub const lsm6ds3_pin_pol_t_LSM6DS3_ACTIVE_LOW: lsm6ds3_pin_pol_t = 1;
pub type lsm6ds3_pin_pol_t = u32;
extern "C" {
    pub fn lsm6ds3_pin_polarity_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_pin_pol_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_pin_polarity_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_pin_pol_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_all_on_int1_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_all_on_int1_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
pub const lsm6ds3_lir_t_LSM6DS3_INT_PULSED: lsm6ds3_lir_t = 0;
pub const lsm6ds3_lir_t_LSM6DS3_INT_LATCHED: lsm6ds3_lir_t = 1;
pub type lsm6ds3_lir_t = u32;
extern "C" {
    pub fn lsm6ds3_int_notification_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_lir_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_int_notification_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_lir_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_wkup_src_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_wake_up_src_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_wkup_threshold_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_wkup_threshold_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_wkup_dur_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_wkup_dur_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_gy_sleep_mode_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_gy_sleep_mode_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_act_mode_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_act_mode_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_act_sleep_dur_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_act_sleep_dur_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_tap_src_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_tap_src_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_tap_detection_on_z_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_tap_detection_on_z_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_tap_detection_on_y_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_tap_detection_on_y_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_tap_detection_on_x_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_tap_detection_on_x_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_tap_threshold_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_tap_threshold_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_tap_shock_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_tap_shock_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_tap_quiet_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_tap_quiet_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_tap_dur_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_tap_dur_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
pub const lsm6ds3_tap_md_t_LSM6DS3_ONLY_DOUBLE: lsm6ds3_tap_md_t = 1;
pub const lsm6ds3_tap_md_t_LSM6DS3_SINGLE_DOUBLE: lsm6ds3_tap_md_t = 0;
pub type lsm6ds3_tap_md_t = u32;
extern "C" {
    pub fn lsm6ds3_tap_mode_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_tap_md_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_tap_mode_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_tap_md_t) -> i32;
}
pub const lsm6ds3_low_pass_on_6d_t_LSM6DS3_ODR_DIV_2_FEED: lsm6ds3_low_pass_on_6d_t = 0;
pub const lsm6ds3_low_pass_on_6d_t_LSM6DS3_LPF2_FEED: lsm6ds3_low_pass_on_6d_t = 1;
pub type lsm6ds3_low_pass_on_6d_t = u32;
extern "C" {
    pub fn lsm6ds3_6d_feed_data_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_low_pass_on_6d_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_6d_feed_data_get(
        ctx: *mut stmdev_ctx_t,
        val: *mut lsm6ds3_low_pass_on_6d_t,
    ) -> i32;
}
extern "C" {
    pub fn lsm6ds3_6d_src_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_d6d_src_t) -> i32;
}
pub const lsm6ds3_sixd_ths_t_LSM6DS3_DEG_80: lsm6ds3_sixd_ths_t = 0;
pub const lsm6ds3_sixd_ths_t_LSM6DS3_DEG_70: lsm6ds3_sixd_ths_t = 1;
pub const lsm6ds3_sixd_ths_t_LSM6DS3_DEG_60: lsm6ds3_sixd_ths_t = 2;
pub const lsm6ds3_sixd_ths_t_LSM6DS3_DEG_50: lsm6ds3_sixd_ths_t = 3;
pub type lsm6ds3_sixd_ths_t = u32;
extern "C" {
    pub fn lsm6ds3_6d_threshold_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_sixd_ths_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_6d_threshold_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_sixd_ths_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_4d_mode_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_4d_mode_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
pub const lsm6ds3_ff_ths_t_LSM6DS3_156_mg: lsm6ds3_ff_ths_t = 0;
pub const lsm6ds3_ff_ths_t_LSM6DS3_219_mg: lsm6ds3_ff_ths_t = 1;
pub const lsm6ds3_ff_ths_t_LSM6DS3_250_mg: lsm6ds3_ff_ths_t = 2;
pub const lsm6ds3_ff_ths_t_LSM6DS3_312_mg: lsm6ds3_ff_ths_t = 3;
pub const lsm6ds3_ff_ths_t_LSM6DS3_344_mg: lsm6ds3_ff_ths_t = 4;
pub const lsm6ds3_ff_ths_t_LSM6DS3_406_mg: lsm6ds3_ff_ths_t = 5;
pub const lsm6ds3_ff_ths_t_LSM6DS3_469_mg: lsm6ds3_ff_ths_t = 6;
pub const lsm6ds3_ff_ths_t_LSM6DS3_500_mg: lsm6ds3_ff_ths_t = 7;
pub type lsm6ds3_ff_ths_t = u32;
extern "C" {
    pub fn lsm6ds3_ff_threshold_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_ff_ths_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_ff_threshold_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_ff_ths_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_ff_dur_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_ff_dur_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_fifo_watermark_set(ctx: *mut stmdev_ctx_t, val: u16) -> i32;
}
extern "C" {
    pub fn lsm6ds3_fifo_watermark_get(ctx: *mut stmdev_ctx_t, val: *mut u16) -> i32;
}
pub const lsm6ds3_tmr_ped_fifo_drdy_t_LSM6DS3_TRG_XL_GY_DRDY: lsm6ds3_tmr_ped_fifo_drdy_t = 0;
pub const lsm6ds3_tmr_ped_fifo_drdy_t_LSM6DS3_TRG_STEP_DETECT: lsm6ds3_tmr_ped_fifo_drdy_t = 1;
pub type lsm6ds3_tmr_ped_fifo_drdy_t = u32;
extern "C" {
    pub fn lsm6ds3_fifo_write_trigger_set(
        ctx: *mut stmdev_ctx_t,
        val: lsm6ds3_tmr_ped_fifo_drdy_t,
    ) -> i32;
}
extern "C" {
    pub fn lsm6ds3_fifo_write_trigger_get(
        ctx: *mut stmdev_ctx_t,
        val: *mut lsm6ds3_tmr_ped_fifo_drdy_t,
    ) -> i32;
}
extern "C" {
    pub fn lsm6ds3_fifo_pedo_batch_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_fifo_pedo_batch_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
pub const lsm6ds3_dec_fifo_xl_t_LSM6DS3_FIFO_XL_DISABLE: lsm6ds3_dec_fifo_xl_t = 0;
pub const lsm6ds3_dec_fifo_xl_t_LSM6DS3_FIFO_XL_NO_DEC: lsm6ds3_dec_fifo_xl_t = 1;
pub const lsm6ds3_dec_fifo_xl_t_LSM6DS3_FIFO_XL_DEC_2: lsm6ds3_dec_fifo_xl_t = 2;
pub const lsm6ds3_dec_fifo_xl_t_LSM6DS3_FIFO_XL_DEC_3: lsm6ds3_dec_fifo_xl_t = 3;
pub const lsm6ds3_dec_fifo_xl_t_LSM6DS3_FIFO_XL_DEC_4: lsm6ds3_dec_fifo_xl_t = 4;
pub const lsm6ds3_dec_fifo_xl_t_LSM6DS3_FIFO_XL_DEC_8: lsm6ds3_dec_fifo_xl_t = 5;
pub const lsm6ds3_dec_fifo_xl_t_LSM6DS3_FIFO_XL_DEC_16: lsm6ds3_dec_fifo_xl_t = 6;
pub const lsm6ds3_dec_fifo_xl_t_LSM6DS3_FIFO_XL_DEC_32: lsm6ds3_dec_fifo_xl_t = 7;
pub type lsm6ds3_dec_fifo_xl_t = u32;
extern "C" {
    pub fn lsm6ds3_fifo_xl_batch_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_dec_fifo_xl_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_fifo_xl_batch_get(
        ctx: *mut stmdev_ctx_t,
        val: *mut lsm6ds3_dec_fifo_xl_t,
    ) -> i32;
}
pub const lsm6ds3_dec_fifo_gyro_t_LSM6DS3_FIFO_GY_DISABLE: lsm6ds3_dec_fifo_gyro_t = 0;
pub const lsm6ds3_dec_fifo_gyro_t_LSM6DS3_FIFO_GY_NO_DEC: lsm6ds3_dec_fifo_gyro_t = 1;
pub const lsm6ds3_dec_fifo_gyro_t_LSM6DS3_FIFO_GY_DEC_2: lsm6ds3_dec_fifo_gyro_t = 2;
pub const lsm6ds3_dec_fifo_gyro_t_LSM6DS3_FIFO_GY_DEC_3: lsm6ds3_dec_fifo_gyro_t = 3;
pub const lsm6ds3_dec_fifo_gyro_t_LSM6DS3_FIFO_GY_DEC_4: lsm6ds3_dec_fifo_gyro_t = 4;
pub const lsm6ds3_dec_fifo_gyro_t_LSM6DS3_FIFO_GY_DEC_8: lsm6ds3_dec_fifo_gyro_t = 5;
pub const lsm6ds3_dec_fifo_gyro_t_LSM6DS3_FIFO_GY_DEC_16: lsm6ds3_dec_fifo_gyro_t = 6;
pub const lsm6ds3_dec_fifo_gyro_t_LSM6DS3_FIFO_GY_DEC_32: lsm6ds3_dec_fifo_gyro_t = 7;
pub type lsm6ds3_dec_fifo_gyro_t = u32;
extern "C" {
    pub fn lsm6ds3_fifo_gy_batch_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_dec_fifo_gyro_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_fifo_gy_batch_get(
        ctx: *mut stmdev_ctx_t,
        val: *mut lsm6ds3_dec_fifo_gyro_t,
    ) -> i32;
}
pub const lsm6ds3_dec_ds3_fifo_t_LSM6DS3_FIFO_DS3_DISABLE: lsm6ds3_dec_ds3_fifo_t = 0;
pub const lsm6ds3_dec_ds3_fifo_t_LSM6DS3_FIFO_DS3_NO_DEC: lsm6ds3_dec_ds3_fifo_t = 1;
pub const lsm6ds3_dec_ds3_fifo_t_LSM6DS3_FIFO_DS3_DEC_2: lsm6ds3_dec_ds3_fifo_t = 2;
pub const lsm6ds3_dec_ds3_fifo_t_LSM6DS3_FIFO_DS3_DEC_3: lsm6ds3_dec_ds3_fifo_t = 3;
pub const lsm6ds3_dec_ds3_fifo_t_LSM6DS3_FIFO_DS3_DEC_4: lsm6ds3_dec_ds3_fifo_t = 4;
pub const lsm6ds3_dec_ds3_fifo_t_LSM6DS3_FIFO_DS3_DEC_8: lsm6ds3_dec_ds3_fifo_t = 5;
pub const lsm6ds3_dec_ds3_fifo_t_LSM6DS3_FIFO_DS3_DEC_16: lsm6ds3_dec_ds3_fifo_t = 6;
pub const lsm6ds3_dec_ds3_fifo_t_LSM6DS3_FIFO_DS3_DEC_32: lsm6ds3_dec_ds3_fifo_t = 7;
pub type lsm6ds3_dec_ds3_fifo_t = u32;
extern "C" {
    pub fn lsm6ds3_fifo_dataset_3_batch_set(
        ctx: *mut stmdev_ctx_t,
        val: lsm6ds3_dec_ds3_fifo_t,
    ) -> i32;
}
extern "C" {
    pub fn lsm6ds3_fifo_dataset_3_batch_get(
        ctx: *mut stmdev_ctx_t,
        val: *mut lsm6ds3_dec_ds3_fifo_t,
    ) -> i32;
}
pub const lsm6ds3_dec_ds4_fifo_t_LSM6DS3_FIFO_DS4_DISABLE: lsm6ds3_dec_ds4_fifo_t = 0;
pub const lsm6ds3_dec_ds4_fifo_t_LSM6DS3_FIFO_DS4_NO_DEC: lsm6ds3_dec_ds4_fifo_t = 1;
pub const lsm6ds3_dec_ds4_fifo_t_LSM6DS3_FIFO_DS4_DEC_2: lsm6ds3_dec_ds4_fifo_t = 2;
pub const lsm6ds3_dec_ds4_fifo_t_LSM6DS3_FIFO_DS4_DEC_3: lsm6ds3_dec_ds4_fifo_t = 3;
pub const lsm6ds3_dec_ds4_fifo_t_LSM6DS3_FIFO_DS4_DEC_4: lsm6ds3_dec_ds4_fifo_t = 4;
pub const lsm6ds3_dec_ds4_fifo_t_LSM6DS3_FIFO_DS4_DEC_8: lsm6ds3_dec_ds4_fifo_t = 5;
pub const lsm6ds3_dec_ds4_fifo_t_LSM6DS3_FIFO_DS4_DEC_16: lsm6ds3_dec_ds4_fifo_t = 6;
pub const lsm6ds3_dec_ds4_fifo_t_LSM6DS3_FIFO_DS4_DEC_32: lsm6ds3_dec_ds4_fifo_t = 7;
pub type lsm6ds3_dec_ds4_fifo_t = u32;
extern "C" {
    pub fn lsm6ds3_fifo_dataset_4_batch_set(
        ctx: *mut stmdev_ctx_t,
        val: lsm6ds3_dec_ds4_fifo_t,
    ) -> i32;
}
extern "C" {
    pub fn lsm6ds3_fifo_dataset_4_batch_get(
        ctx: *mut stmdev_ctx_t,
        val: *mut lsm6ds3_dec_ds4_fifo_t,
    ) -> i32;
}
extern "C" {
    pub fn lsm6ds3_fifo_xl_gy_8bit_format_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_fifo_xl_gy_8bit_format_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
pub const lsm6ds3_fifo_md_t_LSM6DS3_BYPASS_MODE: lsm6ds3_fifo_md_t = 0;
pub const lsm6ds3_fifo_md_t_LSM6DS3_FIFO_MODE: lsm6ds3_fifo_md_t = 1;
pub const lsm6ds3_fifo_md_t_LSM6DS3_STREAM_TO_FIFO_MODE: lsm6ds3_fifo_md_t = 3;
pub const lsm6ds3_fifo_md_t_LSM6DS3_BYPASS_TO_STREAM_MODE: lsm6ds3_fifo_md_t = 4;
pub const lsm6ds3_fifo_md_t_LSM6DS3_STREAM_MODE: lsm6ds3_fifo_md_t = 6;
pub type lsm6ds3_fifo_md_t = u32;
extern "C" {
    pub fn lsm6ds3_fifo_mode_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_fifo_md_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_fifo_mode_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_fifo_md_t) -> i32;
}
pub const lsm6ds3_odr_fifo_t_LSM6DS3_FIFO_DISABLE: lsm6ds3_odr_fifo_t = 0;
pub const lsm6ds3_odr_fifo_t_LSM6DS3_FIFO_12Hz5: lsm6ds3_odr_fifo_t = 1;
pub const lsm6ds3_odr_fifo_t_LSM6DS3_FIFO_26Hz: lsm6ds3_odr_fifo_t = 2;
pub const lsm6ds3_odr_fifo_t_LSM6DS3_FIFO_52Hz: lsm6ds3_odr_fifo_t = 3;
pub const lsm6ds3_odr_fifo_t_LSM6DS3_FIFO_104Hz: lsm6ds3_odr_fifo_t = 4;
pub const lsm6ds3_odr_fifo_t_LSM6DS3_FIFO_208Hz: lsm6ds3_odr_fifo_t = 5;
pub const lsm6ds3_odr_fifo_t_LSM6DS3_FIFO_416Hz: lsm6ds3_odr_fifo_t = 6;
pub const lsm6ds3_odr_fifo_t_LSM6DS3_FIFO_833Hz: lsm6ds3_odr_fifo_t = 7;
pub const lsm6ds3_odr_fifo_t_LSM6DS3_FIFO_1k66Hz: lsm6ds3_odr_fifo_t = 8;
pub const lsm6ds3_odr_fifo_t_LSM6DS3_FIFO_3k33Hz: lsm6ds3_odr_fifo_t = 9;
pub const lsm6ds3_odr_fifo_t_LSM6DS3_FIFO_6k66Hz: lsm6ds3_odr_fifo_t = 10;
pub type lsm6ds3_odr_fifo_t = u32;
extern "C" {
    pub fn lsm6ds3_fifo_data_rate_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_odr_fifo_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_fifo_data_rate_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_odr_fifo_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_fifo_stop_on_wtm_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_fifo_stop_on_wtm_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_fifo_temp_batch_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_fifo_temp_batch_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_fifo_data_level_get(ctx: *mut stmdev_ctx_t, val: *mut u16) -> i32;
}
extern "C" {
    pub fn lsm6ds3_fifo_full_flag_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_fifo_ovr_flag_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_fifo_wtm_flag_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_fifo_pattern_get(ctx: *mut stmdev_ctx_t, val: *mut u16) -> i32;
}
pub const lsm6ds3_den_mode_t_LSM6DS3_DEN_DISABLE: lsm6ds3_den_mode_t = 0;
pub const lsm6ds3_den_mode_t_LSM6DS3_LEVEL_FIFO: lsm6ds3_den_mode_t = 6;
pub const lsm6ds3_den_mode_t_LSM6DS3_LEVEL_LETCHED: lsm6ds3_den_mode_t = 3;
pub const lsm6ds3_den_mode_t_LSM6DS3_LEVEL_TRIGGER: lsm6ds3_den_mode_t = 2;
pub const lsm6ds3_den_mode_t_LSM6DS3_EDGE_TRIGGER: lsm6ds3_den_mode_t = 4;
pub type lsm6ds3_den_mode_t = u32;
extern "C" {
    pub fn lsm6ds3_den_mode_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_den_mode_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_den_mode_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_den_mode_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_pedo_step_reset_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_pedo_step_reset_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_pedo_timestamp_raw_get(ctx: *mut stmdev_ctx_t, buff: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_pedo_step_detect_flag_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_pedo_sens_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_pedo_sens_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_pedo_threshold_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_pedo_threshold_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
pub const lsm6ds3_pedo_fs_t_LSM6DS3_PEDO_AT_2g: lsm6ds3_pedo_fs_t = 0;
pub const lsm6ds3_pedo_fs_t_LSM6DS3_PEDO_AT_4g: lsm6ds3_pedo_fs_t = 1;
pub type lsm6ds3_pedo_fs_t = u32;
extern "C" {
    pub fn lsm6ds3_pedo_full_scale_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_pedo_fs_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_pedo_full_scale_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_pedo_fs_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_pedo_debounce_steps_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_pedo_debounce_steps_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_pedo_timeout_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_pedo_timeout_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_motion_sens_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_motion_sens_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_motion_event_flag_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_motion_threshold_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_motion_threshold_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_sc_delta_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_sc_delta_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_tilt_event_flag_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_tilt_sens_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_tilt_sens_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_mag_soft_iron_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_mag_soft_iron_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_mag_hard_iron_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_mag_hard_iron_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_mag_soft_iron_end_op_flag_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_mag_soft_iron_coeff_set(ctx: *mut stmdev_ctx_t, buff: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_mag_soft_iron_coeff_get(ctx: *mut stmdev_ctx_t, buff: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_mag_offset_set(ctx: *mut stmdev_ctx_t, buff: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_mag_offset_get(ctx: *mut stmdev_ctx_t, buff: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_sh_sync_sens_frame_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_sh_sync_sens_frame_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_sh_master_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_sh_master_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_sh_pass_through_set(ctx: *mut stmdev_ctx_t, val: u8) -> i32;
}
extern "C" {
    pub fn lsm6ds3_sh_pass_through_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
pub const lsm6ds3_sh_pin_md_t_LSM6DS3_EXT_PULL_UP: lsm6ds3_sh_pin_md_t = 0;
pub const lsm6ds3_sh_pin_md_t_LSM6DS3_INTERNAL_PULL_UP: lsm6ds3_sh_pin_md_t = 1;
pub type lsm6ds3_sh_pin_md_t = u32;
extern "C" {
    pub fn lsm6ds3_sh_pin_mode_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_sh_pin_md_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_sh_pin_mode_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_sh_pin_md_t) -> i32;
}
pub const lsm6ds3_start_cfg_t_LSM6DS3_XL_GY_DRDY: lsm6ds3_start_cfg_t = 0;
pub const lsm6ds3_start_cfg_t_LSM6DS3_EXT_ON_INT2_PIN: lsm6ds3_start_cfg_t = 1;
pub type lsm6ds3_start_cfg_t = u32;
extern "C" {
    pub fn lsm6ds3_sh_syncro_mode_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_start_cfg_t) -> i32;
}
extern "C" {
    pub fn lsm6ds3_sh_syncro_mode_get(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_start_cfg_t)
        -> i32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_sh_read_t {
    pub sh_byte_1: lsm6ds3_sensorhub1_reg_t,
    pub sh_byte_2: lsm6ds3_sensorhub2_reg_t,
    pub sh_byte_3: lsm6ds3_sensorhub3_reg_t,
    pub sh_byte_4: lsm6ds3_sensorhub4_reg_t,
    pub sh_byte_5: lsm6ds3_sensorhub5_reg_t,
    pub sh_byte_6: lsm6ds3_sensorhub6_reg_t,
    pub sh_byte_7: lsm6ds3_sensorhub7_reg_t,
    pub sh_byte_8: lsm6ds3_sensorhub8_reg_t,
    pub sh_byte_9: lsm6ds3_sensorhub9_reg_t,
    pub sh_byte_10: lsm6ds3_sensorhub10_reg_t,
    pub sh_byte_11: lsm6ds3_sensorhub11_reg_t,
    pub sh_byte_12: lsm6ds3_sensorhub12_reg_t,
    pub sh_byte_13: lsm6ds3_sensorhub13_reg_t,
    pub sh_byte_14: lsm6ds3_sensorhub14_reg_t,
    pub sh_byte_15: lsm6ds3_sensorhub15_reg_t,
    pub sh_byte_16: lsm6ds3_sensorhub16_reg_t,
    pub sh_byte_17: lsm6ds3_sensorhub17_reg_t,
    pub sh_byte_18: lsm6ds3_sensorhub18_reg_t,
}
#[test]
fn bindgen_test_layout_lsm6ds3_sh_read_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_sh_read_t>(),
        18usize,
        concat!("Size of: ", stringify!(lsm6ds3_sh_read_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_sh_read_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_sh_read_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_sh_read_t>())).sh_byte_1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_read_t),
            "::",
            stringify!(sh_byte_1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_sh_read_t>())).sh_byte_2 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_read_t),
            "::",
            stringify!(sh_byte_2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_sh_read_t>())).sh_byte_3 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_read_t),
            "::",
            stringify!(sh_byte_3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_sh_read_t>())).sh_byte_4 as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_read_t),
            "::",
            stringify!(sh_byte_4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_sh_read_t>())).sh_byte_5 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_read_t),
            "::",
            stringify!(sh_byte_5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_sh_read_t>())).sh_byte_6 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_read_t),
            "::",
            stringify!(sh_byte_6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_sh_read_t>())).sh_byte_7 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_read_t),
            "::",
            stringify!(sh_byte_7)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_sh_read_t>())).sh_byte_8 as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_read_t),
            "::",
            stringify!(sh_byte_8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_sh_read_t>())).sh_byte_9 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_read_t),
            "::",
            stringify!(sh_byte_9)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_sh_read_t>())).sh_byte_10 as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_read_t),
            "::",
            stringify!(sh_byte_10)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_sh_read_t>())).sh_byte_11 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_read_t),
            "::",
            stringify!(sh_byte_11)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_sh_read_t>())).sh_byte_12 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_read_t),
            "::",
            stringify!(sh_byte_12)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_sh_read_t>())).sh_byte_13 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_read_t),
            "::",
            stringify!(sh_byte_13)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_sh_read_t>())).sh_byte_14 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_read_t),
            "::",
            stringify!(sh_byte_14)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_sh_read_t>())).sh_byte_15 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_read_t),
            "::",
            stringify!(sh_byte_15)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_sh_read_t>())).sh_byte_16 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_read_t),
            "::",
            stringify!(sh_byte_16)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_sh_read_t>())).sh_byte_17 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_read_t),
            "::",
            stringify!(sh_byte_17)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_sh_read_t>())).sh_byte_18 as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_read_t),
            "::",
            stringify!(sh_byte_18)
        )
    );
}
extern "C" {
    pub fn lsm6ds3_sh_read_data_raw_get(
        ctx: *mut stmdev_ctx_t,
        buff: *mut lsm6ds3_sh_read_t,
    ) -> i32;
}
pub const lsm6ds3_aux_sens_on_t_LSM6DS3_SLV_0: lsm6ds3_aux_sens_on_t = 0;
pub const lsm6ds3_aux_sens_on_t_LSM6DS3_SLV_0_1: lsm6ds3_aux_sens_on_t = 1;
pub const lsm6ds3_aux_sens_on_t_LSM6DS3_SLV_0_1_2: lsm6ds3_aux_sens_on_t = 2;
pub const lsm6ds3_aux_sens_on_t_LSM6DS3_SLV_0_1_2_3: lsm6ds3_aux_sens_on_t = 3;
pub type lsm6ds3_aux_sens_on_t = u32;
extern "C" {
    pub fn lsm6ds3_sh_num_of_dev_connected_set(
        ctx: *mut stmdev_ctx_t,
        val: lsm6ds3_aux_sens_on_t,
    ) -> i32;
}
extern "C" {
    pub fn lsm6ds3_sh_num_of_dev_connected_get(
        ctx: *mut stmdev_ctx_t,
        val: *mut lsm6ds3_aux_sens_on_t,
    ) -> i32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_sh_cfg_write_t {
    pub slv0_add: u8,
    pub slv0_subadd: u8,
    pub slv0_data: u8,
}
#[test]
fn bindgen_test_layout_lsm6ds3_sh_cfg_write_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_sh_cfg_write_t>(),
        3usize,
        concat!("Size of: ", stringify!(lsm6ds3_sh_cfg_write_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_sh_cfg_write_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_sh_cfg_write_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lsm6ds3_sh_cfg_write_t>())).slv0_add as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_cfg_write_t),
            "::",
            stringify!(slv0_add)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lsm6ds3_sh_cfg_write_t>())).slv0_subadd as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_cfg_write_t),
            "::",
            stringify!(slv0_subadd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lsm6ds3_sh_cfg_write_t>())).slv0_data as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_cfg_write_t),
            "::",
            stringify!(slv0_data)
        )
    );
}
extern "C" {
    pub fn lsm6ds3_sh_cfg_write(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_sh_cfg_write_t) -> i32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lsm6ds3_sh_cfg_read_t {
    pub slv_add: u8,
    pub slv_subadd: u8,
    pub slv_len: u8,
}
#[test]
fn bindgen_test_layout_lsm6ds3_sh_cfg_read_t() {
    assert_eq!(
        ::core::mem::size_of::<lsm6ds3_sh_cfg_read_t>(),
        3usize,
        concat!("Size of: ", stringify!(lsm6ds3_sh_cfg_read_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lsm6ds3_sh_cfg_read_t>(),
        1usize,
        concat!("Alignment of ", stringify!(lsm6ds3_sh_cfg_read_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_sh_cfg_read_t>())).slv_add as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_cfg_read_t),
            "::",
            stringify!(slv_add)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lsm6ds3_sh_cfg_read_t>())).slv_subadd as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_cfg_read_t),
            "::",
            stringify!(slv_subadd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lsm6ds3_sh_cfg_read_t>())).slv_len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lsm6ds3_sh_cfg_read_t),
            "::",
            stringify!(slv_len)
        )
    );
}
extern "C" {
    pub fn lsm6ds3_sh_slv0_cfg_read(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_sh_cfg_read_t)
        -> i32;
}
extern "C" {
    pub fn lsm6ds3_sh_slv1_cfg_read(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_sh_cfg_read_t)
        -> i32;
}
extern "C" {
    pub fn lsm6ds3_sh_slv2_cfg_read(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_sh_cfg_read_t)
        -> i32;
}
extern "C" {
    pub fn lsm6ds3_sh_slv3_cfg_read(ctx: *mut stmdev_ctx_t, val: *mut lsm6ds3_sh_cfg_read_t)
        -> i32;
}
extern "C" {
    pub fn lsm6ds3_sh_end_op_flag_get(ctx: *mut stmdev_ctx_t, val: *mut u8) -> i32;
}
pub const lsm6ds3_slope_fds_t_LSM6DS3_USE_SLOPE: lsm6ds3_slope_fds_t = 0;
pub const lsm6ds3_slope_fds_t_LSM6DS3_USE_HPF: lsm6ds3_slope_fds_t = 1;
pub type lsm6ds3_slope_fds_t = u32;
extern "C" {
    pub fn lsm6ds3_xl_hp_path_internal_set(ctx: *mut stmdev_ctx_t, val: lsm6ds3_slope_fds_t)
        -> i32;
}
extern "C" {
    pub fn lsm6ds3_xl_hp_path_internal_get(
        ctx: *mut stmdev_ctx_t,
        val: *mut lsm6ds3_slope_fds_t,
    ) -> i32;
}
